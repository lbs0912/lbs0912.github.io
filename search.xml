<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode题解-003]]></title>
    <url>%2F2020%2F02%2F23%2Fleetcode-003%2F</url>
    <content type="text"><![CDATA[记录LeetCode题目笔记，汇总LeetCode解答记录 Overview LeetCode-191. Number of 1 Bits （位1的个数） LeetCode-338. Counting Bits（比特位计数） LeetCode-409. Longest Palindrome （最长回文串） LeetCode-223. Rectangle Area（矩形面积） LeetCode-476. Number Complement（数字的补数） 191. Number of 1 Bits（位1的个数）Description LeetCode-191. Number of 1 Bits（位1的个数） 本问题中，计数了一个无符号整数的位，结果称为 pop count，或 汉明权重。 Approach 1：除K取余法Analysis 除K取余法，利用 num%2 和 num/2 不断取出数字的二进制数值。 需要注意的是，在如Java语言中，不能使用 while(num&gt;0) 进行判断。因为Java编译器使用二进制补码记法来表示有符号整数。例如输入 11111111111111111111111111111101， 会被作为 -3 处理。 因此，在Java中应该避免取模和除法操作，使用 (num&amp;1) == 1 代替 num%2；使用无符号右移 num &gt;&gt;&gt; 1 代替 num/2。 在C++中，若使用无符号类型 uint32_t 作为输入类型，可以直接使用 while(num&gt;0) 作为循环判断。 Java 中，&gt;&gt;&gt; 为无符号右移，&gt;&gt; 为有符号右移。 时间复杂度：O(1)。运行时间依赖于数字 n 的位数。本题中是一个32位数字，因此时间复杂度位为 O(1)。 空间复杂度：O(1)，没有使用额外的空间。 Solution C++ 123456789101112class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int total = 0; while(n&gt;0)&#123; //输入类型为无符号类型，因此可以直接使用n&gt;0进行判断 total += n%2; n /=2; // n = n &gt;&gt;1; //也可使用移位操作 &#125; return total; &#125;&#125;; Java 1234567891011121314public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int total = 0; while(n != 0)&#123; if((n&amp;1) == 1)&#123; total++; //不要使用取模操作 &#125; n = n &gt;&gt;&gt; 1; //会有负数情况，因此应该使用无符号右移 //Java 中，`&gt;&gt;&gt;` 为无符号右移，`&gt;&gt;` 为有符号右移。 &#125; return total; &#125;&#125; 或者采用如下实现 1234567891011public int hammingWeight(int n) &#123; int bits = 0; int mask = 1; for (int i = 0; i &lt; 32; i++) &#123; //最大32位 if ((n &amp; mask) != 0) &#123; bits++; &#125; mask &lt;&lt;= 1; &#125; return bits;&#125; Approach 2：位操作小技巧 - n&amp;(n-1)Analysis对前面的算法进行优化。 不再检查数字的每一个位，而是不断把数字最后一个 1 反转，并把计数加1。当数字变成 0 的时候偶，我们就知道它没有 1 的位了，此时返回计数。 这里关键的想法是对于任意数字 n ，将 n 和 n - 1 做与运算，不断循环，最后一定会把 1 的位变成 0。 为什么？考虑 n 和 n - 1 的二进制表示。 在二进制表示中，数字 n 中最低位的 1 总是对应 n - 1 中的 0。因此，将 n 和 n - 1 与运算总是能把 n 中最低位的 1 变成 0 ，并保持其他位不变。 使用这个小技巧，代码变得非常简单。 时间复杂度：O(1)。运行时间依赖于数字 n 的位数。本题中是一个32位数字，因此时间复杂度位为 O(1)。 空间复杂度：O(1)，没有使用额外的空间。 Method Java 1234567891011public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int sum = 0; while(n!=0)&#123; sum++; n = n&amp;(n-1); &#125; return sum; &#125;&#125; Approach 3：字符串长度+正则匹配Analysic JS中，toString(radix) 方法可以将数字转换为基于 radix 的进制数（若 radix 缺省，则默认转换为 10 进制数）。 首先，使用 toString(2) 方法，将数字转换为 2 进制字符串 然后，使用正则匹配，滤除字符串中的 0，得到新的字符串 最后，新字符串的长度即数字中 1 的个数 Solution JS 1234567/** * @param &#123;number&#125; n - a positive integer * @return &#123;number&#125; */var hammingWeight = function(n) &#123; return n.toString(2).replace(/0/g,'').length; &#125;; Approach 4：使用内置函数Analysis Java中，函数 Integer.bitCount() 可以返回数字中2进制格式下 1 的个数。 The java.lang.Integer.bitCount() method returns the number of one-bits in the two’s complement binary representation of the specified int value i. This is sometimes referred to as the population count. 类似的，C++内置的 __builtin_popcount() 函数也可以返回数字中2进制格式下 1 的个数。 Method C++ 123456class Solution &#123;public: int hammingWeight(uint32_t n) &#123; return __builtin_popcount(n); &#125;&#125;; Java 123456public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; return Integer.bitCount(n); &#125;&#125; 338. Counting Bits（比特位计数）Description LeetCode-338. Counting Bits（比特位计数） Approach 1-Pop countAnalysis本问题可以看做 LeetCode- 191. Number of 1 Bits 的后续。 191. Number of 1 Bits 问题中，计数了一个无符号整数的位，结果称为 pop count，或 汉明权重。 现在，我们先默认这个概念。假设我们有函数 int popcount(int x)，可以返回一个给定非负整数的位计数。我们只需要在 [0, num] 范围内循环并将结果存到一个列表中。 时间复杂度：O(nk)。对于每个整数 x，我们需要 O(k) 次操作，其中 k 是 x 的位数。 空间复杂度：O(n)。 Solution Java 1234567891011121314151617class Solution &#123; public int[] countBits(int num) &#123; int[] ans = new int[num+1]; for(int i=0;i&lt;= num;i++)&#123; ans[i] = popCount(i); &#125; return ans; &#125; private int popCount(int x) &#123; int count = 0; while(x!=0)&#123; count++; x = x&amp;(x-1); &#125; return count; &#125;&#125; C++ 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; res(num+1,0); for(int i=0;i&lt;=num;i++)&#123; res[i] = popCount(i); &#125; return res; &#125;private: int popCount(int num)&#123; int count = 0; while(num)&#123; count ++; num &amp;= num-1; &#125; return count; &#125;&#125;; Approach 2-动态规划+最高有效位Analysis利用已有的计数结果来生成新的计数结果。 假设有一个整数 1x = (1001011101)_2 = (605)_&#123;10&#125; 我们已经计算了从 0 到 x - 1 的全部结果。 我们知道，x 与 我们计算过的一个数只有一位之差 1x&apos; = (1011101)_2 = (93)_&#123;10&#125; 它们只在最高有效位上不同。 让我们以二进制形式检查 [0, 3] 的范围 1234567891011(0) = (0)_2(1) = (1)_2(2) = (10)_2(3) = (11)_2(4) = (100)_2(5) = (101)_2 可以看出， 2 和 3 的二进制形式可以通过给 0 和 1 的二进制形式在前面加上 1 来得到。因此，它们的 pop count 只相差 1。 类似的，我们可以使用 [0, 3] 作为蓝本来得到 [4, 7]，使用 [0, 7] 作为蓝本来得到 [8, 15]，即根据区间 [0, b) 的结果去产生区间 [b, 2b) 的结果，其中 b 为 1b = 2^m &gt; x （m=0,1,2...） 总之，对于 pop count P(x)，我们有以下的状态转移函数 1P(x + b) = P(x) + 1, b = 2^m &gt; x （m=0,1,2...） 时间复杂度：O(n)。对每个整数 x，只需要常数时间。 空间复杂度：O(n)。需要 O(n) 的空间来存储结果。 Solution Java 12345678910111213141516class Solution &#123; public int[] countBits(int num) &#123; int[] res = new int[num+1]; int i=0,b=1; //边界条件 while(b&lt;=num)&#123; // generate [b, 2b) or [b, num) from [0, b) while(i&lt;b &amp;&amp; i+b &lt;= num)&#123; res[i+b] = res[i]+1; i++; &#125; i = 0; // reset i b &lt;&lt;= 1; // b = 2b &#125; return res; &#125;&#125; Approach 3-动态规划+最低有效位Analysis只要 x&#39; 小于 x，且它们的 pop count 之间存在函数关系，就可以写出状态转移函数。 遵循上一方法的相同原则，我们还可以通过最低有效位来获得状态转移函数。 观察 x 和 x&#39; = x / 2 的关系 123x=(1001011101)_2=(605)_&#123;10&#125;x&apos; = (100101110)_2 = (302)_&#123;10&#125; 可以发现 x&#39; 与 x 只有一位不同，这是因为 x&#39; 可以看做 x 移除最低有效位的结果。 这样，我们就有了下面的状态转移函数 1P(x) = P(x/2) + (x mod 2) 例如 1234567P(0) = 0; //00 边界条件P(1) = P(0) + 1; //001 000P(2) = P(1) + 0; //010 001P(3) = P(1) + 1; //011 001P(4) = P(2) + 0; //100 010 P(5) = P(2) + 1; //101 010P(6) = P(3) + 1; //110 011 Solution Java 12345678910class Solution &#123; public int[] countBits(int num) &#123; int[] res = new int[num+1]; res[0] = 0; //边界条件 for(int i=0;i&lt;=num;i++)&#123; res[i] = res[i/2] + (i%2); &#125; return res; &#125;&#125; 409. Longest Palindrome（最长回文串）Description LeetCode-409. Longest Palindrome （最长回文串） Approach 1-Map计数Analysis使用 Map 数据结构统计每个字符串出现的次数。遍历 Map 字典，回文串长度增加 2*(map[i]/2)。同时，对出现次数对2取模，若为1，表示回文串中有出现单次的字符，设置标志位 hasSingle = true，最后记得对出现次数加1。 时间复杂度： O(n)，n为字符串的长度，至少遍历每个字符一次。 空间复杂度： O(1)，需要开辟额外空间来计数，字母最多为26个。 Solution C++ 12345678910111213141516171819class Solution &#123;public: int longestPalindrome(string s) &#123; map&lt;char,int&gt; dataInfo; int count = 0; bool hasSingel = false; for(int i=0;i&lt;s.length();i++)&#123; dataInfo[s[i]]++; &#125; for(int i=0;i&lt;dataInfo.size();i++)&#123; if(dataInfo[i]%2 !=0)&#123; hasSingel = true; &#125; count += 2*(dataInfo[i]/2); //处理 'CCC'情况 &#125; count = hasSingel? count+1:count; return count; &#125;&#125;; Java 1234567891011121314151617class Solution &#123; public int longestPalindrome(String s) &#123; char[] chas = s.toCharArray(); Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; chas.length; i++) &#123; map.put(chas[i], map.getOrDefault(chas[i], 0) + 1); &#125; int result = 0; for (int cnt : map.values()) &#123; result += cnt / 2 * 2; if (cnt % 2 == 1 &amp;&amp; result % 2 == 0) &#123; result++; &#125; &#125; return result; &#125;&#125; 223. Rectangle Area（矩形面积）Description LeetCode-223. Rectangle Area（矩形面积） Approach 1-面积拆分求解Analysis 根据上图，可以确定计算的面积值为两个矩形面积的和再减去重合部分的面积，即 resultArea = recArea1 + recArea2 - repetitionArea 重合部分定点坐标的确定 Bottom Left Point Coordinate: (max(A,E), max(B,F)) Top Right Point Coordinate: (min(C,G), min(D,H)) 易忽略点 Due to the total bits of “int” is 32, we prefer to use “w2&lt;=w1” to “(int) w2-w1” to judge the return value. The data of ”(int) w2-w1” may overflow the range of integer.(For example, w2&gt;0 and w1&lt;0) Slove C++ 12345678910111213141516171819202122class Solution &#123;public: int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int area_1 = (C - A)*(D - B); int area_2 = (G - E)*(H - F); //Calculate the overlap area int w1 = max(A, E); int h1 = max(B, F); int w2 = min(C, G); int h2 = min(D, H); if ((w2&lt;=w1) || (h2&lt;=h1)) //没有重合部分 &#123; return area_1 + area_2; &#125; else &#123; return area_1 + area_2 - ((h2-h1)*(w2-w1)); &#125; &#125;&#125;; 在计算过程上进行优化，有如下代码实现 12345678class Solution &#123;public: int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int left = max(A,E), right = max(min(C,G), left); int bottom = max(B,F), top = max(min(D,H), bottom); return (C-A)*(D-B) - (right-left)*(top-bottom) + (G-E)*(H-F); &#125;&#125;; JS 12345var computeArea = function(A, B, C, D, E, F, G, H) &#123; var left = Math.max(A,E), right = Math.max(Math.min(C,G), left); var bottom = Math.max(B,F), top = Math.max(Math.min(D,H), bottom); return (C-A)*(D-B) - (right-left)*(top-bottom) + (G-E)*(H-F);&#125;; Java 1234567public class Solution &#123; public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int left = Math.max(A,E), right = Math.max(Math.min(C,G), left); int bottom = Math.max(B,F), top = Math.max(Math.min(D,H), bottom); return (C-A)*(D-B) - (right-left)*(top-bottom) + (G-E)*(H-F); &#125;&#125; 476. Number Complement (数字的补数)Description LeetCode-476. Number Complement (数字的补数) 给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。 注意 1. 给定的整数保证在32位带符号整数的范围内。 2. 你可以假定二进制数不包含前导零位。示例 1 输入: 5 输出: 2 解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。示例 2 输入: 1 输出: 0 解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。Approach 1-寻找最高位为1的位置Analysis分析题目可知，只需对每个位的二进制数值（没有前导零位时）进行翻转即可。 但数值实际存储中，是包含前导零位的。如果直接对 num 进行取反操作，会把符号位取反，并且把最高位为 1 之前的所有位数都取反。 12不含前导零位时，5 = 101，取反操作得到010，即十进制数值2含有前导零位时（次数以8位为例），5 = 0000,0101，取反操作得到1111,1010 因此，对每位翻转（或取反，或和1进行异或）的起始位置是从最高位的1开始的，前面的 0 是不能被翻转的。可以考虑从高位往低位遍历，当遇到第1个1后，记录最高位为1的位置，之后再进行翻转操作（异或实现）。 Solution C++ 12345678910111213141516class Solution &#123;public: int findComplement(int num) &#123; if(num&lt;=0) return num; int highestOneBit = 0; //最高位1的位数 int tmp = num; while(tmp&gt;0)&#123; highestOneBit += 1; tmp &gt;&gt;=1; &#125; for(int i=highestOneBit-1;i&gt;=0;i--)&#123; num = num ^(1&lt;&lt;i); //异或操作 &#125; return num; &#125;&#125;; Approach 2-创建每位都是1的二进制数值Analysis在不含前导零位时，把 num 和同位数的且每位都是1的二进制数进行与操作，即可得到结果。 因此，问题转化为求解一个和 num 位数一样且每位都是1的二进制数值 mask，最后进行异或操作（mask ^ num）即可。 例如，5 = 101，因此 mask = 111，进行异或操作 mask ^ num = 111 ^ 101 = 010。 得到每位都是1的二进制，如 111，可以通过1000 减去 1 得到。 Solution Java 123456789101112class Solution &#123; public int findComplement(int num) &#123; int temp = num; int mask = 1; while(temp&gt;0)&#123; mask &lt;&lt;= 1; temp &gt;&gt;= 1; &#125; mask -= 1; //1000-1 得到111 return mask ^ num; //异或 &#125;&#125; Approach 3-转换为字符串+正则匹配Analysis此处给出JS实现的特解 先将 num 转化为二进制字符串 借助正则表达式查找，将字符串中的 0 替换成1 再将该字符串值转化成整数 int 最后将该值和 num进行异或操作 Solution JS 12345678/** * @param &#123;number&#125; num * @return &#123;number&#125; */var findComplement = function(num) &#123; var str = num.toString(2).replace(/0/g,1); //转换为11..11 return (num) ^ parseInt(str,2);&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解-002]]></title>
    <url>%2F2020%2F02%2F23%2Fleetcode-002%2F</url>
    <content type="text"><![CDATA[记录LeetCode题目笔记，汇总LeetCode解答记录 Overview LeetCode-206. Reverse Linked List（反转链表） - 链表操作 LeetCode-617. Merge Two Binary Trees - 二叉树 LeetCode-104. Maximum Depth of Binary Tree（二叉树的最大深度） - 遍历二叉树 LeetCode-1290. Convert Binary Number in a Linked List to Integer（二进制链表转整数） LeetCode-709. To Lower Case（转换成小写字母） 206. Reverse Linked List（反转链表）Description LeetCode-206.Reverse Linked List（反转链表） Approach 1-迭代Analysis 遍历列表，将当前节点的 next 指针改为指向前一个元素，实现对列表的反转。最后，返回新的头引用。 时间复杂度：O(n) 空间复杂度：O(1) Solution Java 12345678910111213141516171819202122/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode prev = null; ListNode curr = head; while (curr != null) &#123; ListNode nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp; &#125; return prev; &#125;&#125; C++ 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode *curr = head; ListNode *prev = NULL; while(curr != NULL)&#123; ListNode *tmpNext = curr-&gt;next; curr-&gt;next = prev; prev= curr; curr = tmpNext; &#125; return prev; &#125;&#125;; Approach 2-递归Analysis LeetCode-206.反转列表 | 官方题解 从递归角度分析该问题，假设列表的其余部分已经被反转，现考虑该如何反转 对于列表，假设其 $[n_{k-1},n_{m}]$ 部分已完成反转，当前对节点 $n_{k}$ 进行操作，使得 $n_{k+1}$ 的下一个节点指向 $n_{k}$，即 $n_{k}.next.next = n_{k}$。 12n_&#123;1&#125;\rightarrow ... \rightarrow n_&#123;k-1&#125; \rightarrow n_&#123;k&#125; \rightarrow n_&#123;k+1&#125; \leftarrow ... \leftarrow n_&#123;m&#125; \leftarrow null 需要小心的是节点 $n_{1}$ 的 next 指针需要指向 null。若忽略了这一点，链表中可能会产生循环。（使用大小为 2 的链表测试，可能会捕获此错误） 时间复杂度：O(n) 空间复杂度：O(n)：由于使用递归，将会使用隐式栈空间，递归深度可能会达到 n 层 Solution Java 1234567891011121314151617181920/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode reverseTmpList = reverseList(head.next); head.next.next = head; head.next = null; return reverseTmpList; &#125;&#125; C++ 1234567891011121314151617181920/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL)&#123; return head; &#125; ListNode *reverseTmpList = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return reverseTmpList; &#125;&#125;; 617. Merge Two Binary Trees（合并二叉树）Description LeetCode-617.Merge Two Binary Trees（合并二叉树） Approach 1-递归Analysis 使用递归方法求解 时间复杂度：O(m) 。递归方法中，共有 m 个节点需要遍历（m 为给定的两个二叉树节点数目的最小值） 空间复杂度：O(m) 。递归栈的深度，最差情况下最大值可为 m。递归深度平均值为 log(m) Solution Java 12345678910111213141516171819/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if(t1 == null) return t2; if(t2 == null) return t1; t1.val += t2.val; t1.left = mergeTrees(t1.left,t2.left); t1.right = mergeTrees(t1.right,t2.right); return t1; &#125;&#125; 104. Maximum Depth of Binary Tree（二叉树的最大深度）Description LeetCode-104. Maximum Depth of Binary Tree（二叉树的最大深度） Approach 1-递归Analysis 使用递归方法求解 时间复杂度：O(n) ：每个节点均遍历一次，其中 n 为节点数 空间复杂度：O(n)：最糟糕情况下，树是完全不平衡的，例如每个节点只有左子节点，递归将被调用 n 次（树的高度），最差空间复杂度为 O(n)。最好情况下（树是完全平衡的），树的高度为 log(n) 递归栈的深度，最差情况下最大值可为 m。递归深度平均值为 log(n)，此时空间复杂度是 O(log(n))。 Solution1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; else &#123; int left_height = maxDepth(root.left); int right_height = maxDepth(root.right); return java.lang.Math.max(left_height, right_height) + 1; &#125; &#125;&#125; 1290. Convert Binary Number in a Linked List to Integer（二进制链表转整数）Description LeetCode-1290. Convert Binary Number in a Linked List to Integer（二进制链表转整数） Approach 1-模拟二进制转十进制+位操作Analysis 由于链表中从高位到低位存放了数字的二进制表示，因此可以使用二进制转十进制的方法，在遍历一遍链表的同时，得到数字的十进制值。 时间复杂度：O(n)，其中 n 是链表中的节点个数 空间复杂度：O(1) 需要注意的是，在求解过程中（如下） 1234567int sum = 0;while(head != null)&#123; //sum = 2*sum + head.val; sum = sum&lt;&lt;1 | head.val; head = head.next;&#125;return sum; 使用 sum = 2*sum + head.val 计算，乘法操作耗时是大于位操作的。因此，该步骤可优化为 12//sum = 2*sum + head.val;sum = sum&lt;&lt;1 | head.val; LeetCode平台，C++语言，使用乘法操作 sum = 2*sum + head.val，耗时4ms，内存消耗8.4M；使用位操作 sum = sum&lt;&lt;1 | head.val;，耗时0ms，内存消耗8.3M Solution Java 12345678910111213141516171819/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int getDecimalValue(ListNode head) &#123; int sum = 0; while(head != null)&#123; //sum = 2*sum + head.val; sum = sum&lt;&lt;1 | head.val; head = head.next; &#125; return sum; &#125;&#125; C++ 12345678910111213141516171819/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int getDecimalValue(ListNode* head) &#123; int sum = 0; while(head)&#123; sum = sum&lt;&lt;1 | head-&gt;val; head = head-&gt;next; &#125; return sum; &#125;&#125;; 709. To Lower Case（转换成小写字母）Description LeetCode-709. To Lower Case（转换成小写字母） Approach 1-ASCII编码转换Analysis 使用 ASCII 编码进行大小写字母转换。大写字母 A~Z 的 ASCII值为 65~90;小写字母 a~z 的 ASCII值为 97~122。小写字母 a 和大写字母 A 的 ASCII 码差值为 32。 时间复杂度：O(n)，其中 n 是字符串长度 空间复杂度：O(1) 更进一步，观察大小写字母 ASCII 码的二进制 12A----65-----1000001a----97-----1100001 因此，在大小转换时，可使用位运算，进行或操作 1char c = (char)(str.charAt(i) | (char)(32)); Solution Java 12345678910class Solution &#123; public String toLowerCase(String str) &#123; StringBuilder res = new StringBuilder(); for(int i=0;i&lt;str.length();i++)&#123; char c = (char)(str.charAt(i) | (char)(32)); res.append(c); &#125; return res.toString(); &#125;&#125; 上述方法，耗时0ms，内存34.2MB。如果使用Java内置的 toLowerCase() 方法，耗时0ms，内存34.1MB。 12345class Solution &#123; public String toLowerCase(String str) &#123; return str.toLowerCase(); &#125;&#125; C++ 1234567891011class Solution &#123;public: string toLowerCase(string str) &#123; for(int i=0;i&lt;str.length();i++)&#123; if(str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z')&#123; str[i] += 32; &#125; &#125; return str; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划经典题目整理]]></title>
    <url>%2F2020%2F02%2F22%2Falgorithm-dp-1%2F</url>
    <content type="text"><![CDATA[记录和汇总动态规划经典题目 买苹果Description 动态规划-买苹果 | 牛客网 小易去附近的商店买苹果，奸诈的商贩使用了捆绑交易，只提供 6 个每袋和 8 个每袋的包装(包装不可拆分)。 可是小易现在只想购买恰好 n 个苹果，小易想购买尽量少的袋数方便携带。如果不能购买恰好 n 个苹果，小易将不会购买。 输入描述: 输入一个整数n，表示小易想购买 n(1 ≤ n ≤ 100) 个苹果 输出描述: 输出一个整数表示最少需要购买的袋数，如果不能买恰好 n 个苹果则输出 -1 测试用例 1234//input20//output3 Approach 1-动态规划（通解）Analysis 采用动态规划方法求解。 创建一个 vector 容器 steps，steps[i] 表示购买 i 个苹果所需的最小袋数。 初始化为 steps 容器为 INT_MAX。 从购买1个苹果开始遍历，若 steps[i] 为 INT_MAX，表示无法购买该个数的苹果，直接开始下次循环。 若 steps[i] 不为 INT_MAX，表示该个数的苹果可以购买，进行动态规划求解。 动态规划的转移方程为 12steps[i+j] = min(steps[i]+1,steps[i+j]) //j为6或8steps[0] = 0 动态规划的过程如下图所示 Solution C++ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;int main()&#123; int amounts; cin&gt;&gt;amounts; //小于6情况处理 if(amounts &lt; 6)&#123; cout&lt;&lt;-1&lt;&lt;endl; &#125; vector&lt;int&gt; steps(amounts+1,INT_MAX); steps[6] = 1; steps[8] = 1; for(int i=6;i&lt;=amounts;i++)&#123; if(steps[i] == INT_MAX)&#123; continue; &#125; else&#123; if(i+6 &lt;= amounts)&#123; steps[i+6] = min(steps[i]+1,steps[i+6]); &#125; if(i+8 &lt;= amounts)&#123; steps[i+8] = min(steps[i]+1,steps[i+8]); &#125; &#125; &#125; steps[amounts] = (steps[amounts] == INT_MAX)? -1:steps[amounts]; cout&lt;&lt;steps[amounts]&lt;&lt;endl; return 0;&#125; Approach 2-贪婪算法Analysis 采用贪婪算法求解。 优先选取每袋含有 8 个苹果的包装。若还有余数，则再用 6 个装的包装去购买。 如果不行的话，则将 8 个装的个数减去 1 个，进行回溯，再用 6 包装的去购买。 如果还不行的话，再次回溯，直到购买 8 包装的个数为 0。 贪婪算法并不一定能得到最优解，但是一个可行的，较好的解。 例如，给定硬币 coins=[1,2,10,25]，金额总数 amounts=30，不限制每种币值的硬币数量，要求用所给硬币凑出所需金额，并且硬币数量最少。若采用贪婪算法求解，需要 6 枚（25+5*1）硬币。 若采用动态规划求解，所需 3 枚（10+10+10）硬币。 下面对使用贪婪算法能否得到最优解进行分析。 首先，6 和 8 都是偶数。因此，能凑出的个数也一定是偶数。程序中若苹果总数是奇数，可以直接返回 -1。 再次，偶数个苹果数对 8 取模，其结果只可能为 0,2,4,6。 若余数为 6 或者 0，则可以直接用 6 包装情况处理，不需要回溯购买 8 包装的情况。 若余数为 4，只需回溯 1 次即可，因为8+4=12, 12%6=0。 若余数为 2，只需回溯 2 次即可，因为8+8+2=18, 18%6=0。 综上，本题情况使用贪婪算法一定能得到最优解。 Solution C++ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;int maxPackages(int num) &#123; int res = 0; int mul, remains; if(num%2 != 0)&#123; return -1; //非偶数直接返回 &#125; if (num % 8 == 0) &#123; res += num / 8; return res; &#125; else&#123; mul = num / 8; //倍数 remains = num % 8; res += mul; num = num % 8; while (mul &gt;= 0) &#123; //回溯8包装 if (num % 6 == 0) &#123; res += num / 6; return res; &#125; else &#123; mul--; //回溯 8包装购买袋数-1 res--; num = num + 8; &#125; &#125; &#125; return -1;&#125;int main() &#123; int num; while (cin &gt;&gt; num) &#123; cout &lt;&lt; maxPackages(num) &lt;&lt; endl; &#125; return 0;&#125; Approach 3-数字分析求解Analysis 对数字特征进行分析。 首先，6 和 8 都是偶数。因此，能凑出的个数也一定是偶数。程序中若苹果总数是奇数，可以直接返回-1。 再次，偶数个苹果数对 8 取模，其结果只可能为 0,2,4,6。 若余数为 6 或者 0，则可以直接用 6 包装情况处理，不需要回溯购买 8 包装的情况。 若余数为 4，只需回溯 1 次即可，因为 8+4=12, 12%6=0。 若余数为 2，只需回溯 2 次即可，因为 8+8+2=18, 18%6=0。 综上，可以采用如下思路进行处理。（由于数字 6 和 8 的特征，本方法只适用于本题，不具有通用性，动态规划为本题通用解法） 情况1：若 num 不是偶数，则直接返回 -1 情况2：若 num%8=0，则返回 num/8 情况3：若 num%8 !=0，则只需回溯 1 次或者 2 次 8 包装购买个数，就可以求解。 回溯 1 次，其结果为 n/8-1+2= n/8+1 回溯 2 次，其结果为 n/8-2+3 = n/8+1 因此，可以情况3下，可以返回 n/8+1 Solution C++ 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main() &#123; int num; while (cin &gt;&gt; num) &#123; if(num%2 != 0)&#123; cout&lt;&lt;-1&lt;&lt;endl; &#125; else&#123; if(num%8 == 0)&#123; cout&lt;&lt;num/8&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;1+num/8&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125; 跳石板题目描述 跳石板 | 牛客网 小易来到了一条石板路前，每块石板上从1挨着编号为：1、2、3……. 这条石板路要根据特殊的规则才能前进：对于小易当前所在的编号为K的石板，小易单次只能往前跳K的一个约数(不含1和K)步，即跳到K+X(X为K的一个非1和本身的约数)的位置。 小易当前处在编号为N的石板，他想跳到编号恰好为M的石板去，小易想知道最少需要跳跃几次可以到达。 例如 12N = 4，M = 24：4-&gt;6-&gt;8-&gt;12-&gt;18-&gt;24 于是小易最少需要跳跃5次，就可以从4号石板跳到24号石板。 输入描述 1输入为一行，有两个整数N，M，以空格隔开。 (4 ≤ N ≤ 100000) (N ≤ M ≤ 100000) 输出描述 1输出小易最少需要跳跃的步数,如果不能到达输出-1 测试用例 12345//输出4 24//输出5 Approach 1-动态规划Analysis采用动态规划思想求解。创建一个 vector 容器 steps，steps[i] 表示到达 i 号石板所需的最小步数。 初始化为 steps 容器为 INT_MAX。 从序号 N 的石板开始逐个遍历，若 steps[i]为 INT_MAX，表示该点不可到达，直接开始下次循环。 若 steps[i] 不为 INT_MAX，表示该点可以到达。 动态规划的转移方程为 12345steps[i] = INT_MAX //初始化所有值为INT_MAX//i为石板编号，j=1,2...M-1// 若j为i的约数，则 steps[i+j] = steps[i]+1steps[i+j] = min(steps[i]+1,steps[i+j]) steps[N] = 0 Solution下面给出代码实现 C++ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int N,M; while(cin&gt;&gt;N&gt;&gt;M)&#123; vector&lt;int&gt; steps(M+1,INT_MAX); steps[N] = 0; for(int i=N;i&lt;=M;i++)&#123; if(steps[i] == INT_MAX)&#123; continue; &#125; for(int j=2;(j*j)&lt;=i;j++)&#123; if(i%j == 0)&#123; if(i+j &lt;= M)&#123; steps[i+j] = min(steps[i]+1,steps[i+j]); &#125; //如果j是约数，那么(i/j)也是约数 if(i+(i/j) &lt;= M)&#123; steps[i+(i/j)] = min(steps[i]+1,steps[i+(i/j)]); &#125; &#125; &#125; &#125; if(steps[M] == INT_MAX)&#123; steps[M] = -1; &#125; cout&lt;&lt;steps[M]&lt;&lt;endl; &#125; return 0;&#125; 此处给出一个常规的优化项说明，上述代码在判断 for 循环时，限制循环终止条件为 (j*j)&lt;=i，对于大于 sqrt(i) 的约数，在同一个for循环中进行判断，即 1234567891011for(int j=2;(j*j)&lt;=i;j++)&#123; if(i%j == 0)&#123; if(i+j &lt;= M)&#123; ... &#125; //如果j是约数，那么(i/j)也是约数 if(i+(i/j) &lt;= M)&#123; ... &#125; &#125;&#125; 上述可以明显减少for循环次数，针对N=4，M=24的情况，上述代码会执行10次循环。如果使用下述代码，将会执行15次代码（在牛客网系统上，会被当做超时处理） 1234567for(int j=2;j&lt;i;j++)&#123; if(i%j == 0)&#123; if(i+j &lt;= M)&#123; ... &#125; &#125;&#125; Approach 2-贪婪算法Analysis(本题目，使用贪婪算法并不能AC，此处给出的贪婪算法，仅作为一个示例给出，用于分析贪婪算法的使用场景) 贪婪算法并不一定能得到最优解，但是一个可行的，较好的解。 该问题若采用贪婪算法求解，并不会得到最优解，只会得到一个可行的，较好的解。例如，下述程序中采用了贪婪算法求解。每次都选取最大的约数前进一步。若后续发生不可到达目标点，则进行回溯，取第2大的约数作为步进值。下述程序通过率为80%，并不能AC。例如，对于N=676, M=12948情况，贪婪算法求解为13步，而动态规划算法求解为10步。 贪婪算法并不一定能得到最优解，但是一个可行的，较好的解。例如，给定硬币coins=[1,2,10,25]，金额总数amounts=30，不限制每种币值的硬币数量，要求用所给硬币凑出所需金额，并且硬币数量最少。若采用贪婪算法求解，需要6枚（25+5*1）硬币。 若采用动态规划求解，所需3枚（10+10+10）硬币。 — 贪婪算法 Solution123456789101112131415161718192021222324252627282930313233343536// 程序通过率为80%，并不能AC//对于N=676, M=12948情况，贪婪算法求解为13步，而动态规划算法求解为10步。// 贪婪算法并不一定能得到最优解，但是一个可行的，较好的解。#include &lt;iostream&gt;using namespace std;int stepSearch(int N, int M) &#123; if (N &gt; M) &#123; return -1; &#125; if (N == M) &#123; return 0; &#125; int res = 0; for (int i = 2; i&lt;N; i++) &#123; if (i*(N / i) == N) &#123; res++; if (stepSearch(N + N/i, M) != -1) &#123; res += stepSearch(N + N/i, M); return res; &#125; else &#123; res--; &#125; &#125; &#125; return -1;&#125;int main() &#123; int N, M; while (cin &gt;&gt; N &gt;&gt; M) &#123; cout &lt;&lt; stepSearch(N, M) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>DP</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解-001]]></title>
    <url>%2F2020%2F02%2F22%2Fleetcode-001%2F</url>
    <content type="text"><![CDATA[记录LeetCode题目笔记，汇总LeetCode解答记录 Overview LeetCode-141. Linked List Cycle（环形链表） - 环形链表 LeetCode-142. Linked List Cycle II（环形链表 II） - 环形链表 LeetCode-258. Add Digits（各位相加） - 数字推导（数字根） LeetCode-461. Hamming Distance（汉明距离） - 位运算 LeetCode-463. Island Perimeter（岛屿的周长） - 常规计算 141. Linked List Cycle（环形链表）Description LeetCode - 141. Linked List Cycle（环形链表） Approach 1-Hash TableAnalysis 使用哈希表解决，时间复杂度为 O(n)，空间复杂度为 O(n)。 遍历链表，若遇到 Null，则 表明链表无环。若遍历的节点在哈希表中已存在，则表明链表有环。 Solution JavaScript 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;boolean&#125; */var hasCycle = function(head) &#123; let nodesSeen = new Set(); if(head === null || head.next === null)&#123; return false; &#125; while(head !== null)&#123; if(nodesSeen.has(head))&#123; return true; &#125; else&#123; nodesSeen.add(head); &#125; head = head.next; &#125; return false;&#125;; Java 1234567891011121314151617181920/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; */public boolean hasCycle(ListNode head) &#123; Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;(); while (head != null) &#123; if (nodesSeen.contains(head)) &#123; return true; &#125; else &#123; nodesSeen.add(head); &#125; head = head.next; &#125; return false;&#125; Approach 2-Two PointersAnalysis 使用快慢指针解决，时间复杂度为 O(n)，空间复杂度为 O(1)。 Use two pointers, walker and runner. Walker moves step by step. Runner moves two steps at time. If the Linked List has a cycle walker and runner will meet at some point. Ref LeetCode Solution LeetCode 141/142 - Linked List Cycle | CNBlogs Solution C++ 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head == NULL)&#123; return false; &#125; ListNode *walker = head; //moves one step each time ListNode *runner = head; //moves two step each time while(runner-&gt;next != NULL &amp;&amp; runner-&gt;next-&gt;next != NULL)&#123; walker = walker-&gt;next; runner = runner-&gt;next-&gt;next; if(walker == runner)&#123; return true; &#125; &#125; return false; &#125;&#125;; JavaScript 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;boolean&#125; */var hasCycle = function(head) &#123; if(head === null) &#123; return false; &#125; var walker = new ListNode(); var runner = new ListNode(); walker = head; runner = head; while(runner.next!==null &amp;&amp; runner.next.next!==null) &#123; walker = walker.next; runner = runner.next.next; if(walker === runner) return true; &#125; return false;&#125;; Java 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if (head == null || head.next == null) &#123; return false; &#125; ListNode slow = head; ListNode fast = head.next; while (slow != fast) &#123; if (fast == null || fast.next == null) &#123; return false; &#125; slow = slow.next; fast = fast.next.next; &#125; return true; &#125;&#125; Python 123456789101112131415161718192021# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if head == None or head.next == None: return False slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False 142. Linked List Cycle II （环形链表II）Description LeetCode - 142. Linked List Cycle II（环形链表II） Approach 1-Two PointersAnalysisLeetCode-141. Linked List Cycle 中，完成了链表是否有环的判断。在此基础上，本题实现对环起点的判断和环长度的计算。 下面结合 LeetCode 141/142 - Linked List Cycle | CNBlogs 参考链接，对环起点的判断和环长度的计算进行分析。 设链表起点距离环的起点距离为a，圈长为n，当 walker 和 runner 相遇时，相遇点距离环起点距离为b，此时 runner 已绕环走了k圈，则 walker 走的距离为 a+b，步数为 a+b runner 速度为 walker 的两倍，runner 走的距离为 2*(a+b)，步数为 a+b runner 走的距离为 a+b+k*n=2*(a+b)，从而 a+b=k*n，a=k*n-b 因此有，当 walker 走 a 步，runner 走 (k*n-b) 步。当 k=1 时，则为 (n-b) 步 环的起点令 walker 返回链表初始头结点，runner 仍在相遇点。此时，令 walker 和 runner 每次都走一步距离。当 walker 和 runner 相遇时，二者所在位置即环的起点。 证明过程如下。 walker 走 a 步，到达环的起点；runner 初始位置为 2(a+b)，走了 a 步之后，即 kn-b 步之后，所在位置为 2(a+b)+kn-b=2a+b+kn= a+(a+b)+kn=a+2kn。因此，runner 位置是环的起点。 12345// runner走的位置2(a+b) + a= 3a + 2b //消去b b = k*n - a= 3a + 2*(k*n - a)= a + 2kn 环的长度在上述判断环的起点的基础上，求解环的长度。 当 walker 和 runner 相遇时，二者所在位置即环的起点。此后，再让 walker 每次运动一步。 walker 走 n 步之后，walker 和 runner 再次相遇。walker 所走的步数即是环的长度。 Solution 注意，在 while() 中需要使用 break 及时跳出循环，否则提交时会出现超时错误 Time Limit Exceeded C++ 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(head == NULL)&#123; return NULL; &#125; bool hasCycle = false; ListNode *walker = head; //moves one step each time ListNode *runner = head; //moves two step each time while(runner-&gt;next != NULL &amp;&amp; runner-&gt;next-&gt;next != NULL)&#123; walker = walker-&gt;next; runner = runner-&gt;next-&gt;next; if(walker == runner)&#123; hasCycle = true; break; //跳出循环 &#125; &#125; if(hasCycle == true)&#123; walker = head; while(walker != runner)&#123; walker = walker-&gt;next; runner = runner-&gt;next; &#125; return walker; &#125; return NULL; &#125;&#125;; JavaScript 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var detectCycle = function(head) &#123; if(head === null || head.next === null)&#123; return null; &#125; // Tip - new ListNode() 创建可省略，节省代码运行时间 // let walker = new ListNode(); // one steps // let runner = new ListNode(); // two steps let walker = head; let runner = head; let hasCycle = false; while(runner.next !== null &amp;&amp; runner.next.next !== null)&#123; runner = runner.next.next; walker = walker.next; if(runner === walker)&#123; hasCycle = true; break; //jump loop &#125; &#125; if(hasCycle)&#123; walker = head; while(walker !== runner)&#123; runner = runner.next; walker = walker.next; &#125; return walker; &#125; return null;&#125;; Java 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; if(head == null || head.next == null)&#123; return null; &#125; ListNode walker = head; ListNode runner = head; boolean hasCycle = false; while(runner.next != null &amp;&amp; runner.next.next != null)&#123; walker = walker.next; runner = runner.next.next; if(walker == runner)&#123; hasCycle = true; break; //jump loop &#125; &#125; if(hasCycle)&#123; walker = head; while(walker != runner)&#123; walker = walker.next; runner = runner.next; &#125; return walker; &#125; return null; &#125; &#125; Python 1234567891011121314151617181920212223242526272829# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def detectCycle(self, head): """ :type head: ListNode :rtype: ListNode """ if head == None or head.next == None: return None runner = walker = head hasCycle = False while runner and runner.next: runner = runner.next.next walker = walker.next if runner == walker: hasCycle = True break if hasCycle: walker = head while walker != runner: walker = walker.next runner = runner.next return walker return None 258. Add Digits（各位相加）Description LeetCode-258. Add Digits（各位相加） Approach 1-Digit Root 公式Analysis Add Digits | LeetCode Discussion Digit Root | Wikipedia 将一正整数的各个位数相加(即横向相加)后，若加完后的值大于等于10的话，则继续将各位数进行横向相加直到其值小于十为止所得到的数，即为数根 (Digit Root) 本题目为求解一个非负整数的数根。参考 Digit Root | Wikipedia 可以了解数根的公式求解方法。 从上图总结规律，对于一个 b 进制的数字 (此处针对十进制数，b=10)，其 数字根 （digit root） 可以表达为 12345dr(n) = 0 if n == 0 dr(n) = (b-1) if n != 0 and n % (b-1) == 0 // 9的倍数且不为零，数根为9dr(n) = n mod (b-1) if n % (b-1) != 0 // 不是9的倍数且不为零，数根为对9取模 或者 1dr(n) = 1 + (n - 1) % 9 Solution C++ 12345678class Solution &#123;public: int addDigits(int num) &#123; return 1 + (num - 1) % 9; &#125;&#125;; JavaScript 1234567/** * @param &#123;number&#125; num * @return &#123;number&#125; */var addDigits = function(num) &#123; return 1 + (num - 1) % 9;&#125;; Java 12345678910111213class Solution &#123; public int addDigits(int num) &#123; if (num == 0)&#123; return 0; &#125; if (num % 9 == 0)&#123; return 9; &#125; else &#123; return num % 9; &#125; &#125;&#125; Python 123456789class Solution: def addDigits(self, num: int) -&gt; int: """ :type num:int :rtype :int """ if num == 0: return 0 elif num%9 == 0: return 9 else: return num%9 461. Hamming Distance（汉明距离）Description LeetCode-461. Hamming Distance（汉明距离） Approach 1-异或位运算对输入参数进行异或位运算得到一个二进制数值，再计算其中的数字 1 的个数即可。 在代码实现中，可以结合语言内置的API或方法，简化求解过程。 Analysis JavaScript 12345678910111213/** * @param &#123;number&#125; x * @param &#123;number&#125; y * @return &#123;number&#125; */var hammingDistance = function(x, y) &#123; let xor = x^y; let total = 0; for(let i=0;i&lt;32;i++)&#123; // Number型 占32位 total += (xor&gt;&gt;i) &amp;1; &#125; return total;&#125;; 由于 Number 型占 32 位，因此，需要异或的结果进行32次移位，循环判断其中的数字 1 的个数。 下面考虑简化上述求解过程。 number.toString(radix) 方法可以将一个数字以 radix 进制格式转换为字符串。可以将异或结果转换为 2 进制字符串。 对上述 2 进制字符串，使用正则表达式，只保留其中 1，将 0 替换为空。 最后，计算所得字符串的长度，即所求结果。 12345678/** * @param &#123;number&#125; x * @param &#123;number&#125; y * @return &#123;number&#125; */var hammingDistance = function(x, y) &#123; return (x ^ y).toString(2).replace(/0/g, '').length;&#125;; Java Java中，Integer.bitCount() 函数可以返回输入参数对应二进制格式数值中数字 1 的个数。 12345public class Solution &#123; public int hammingDistance(int x, int y) &#123; return Integer.bitCount(x^y); //XOR &#125;&#125; C++ C++ 中, int __builtin_popcount 函数可以返回输入参数对应二进制格式数值中数字 1 的个数。 123456class Solution &#123;public: int hammingDistance(int x, int y) &#123; return __builtin_popcount(x^y); &#125;&#125;; 463. Island Perimeter（岛屿的周长）Description LeetCode - 463. Island Perimeter（岛屿的周长） Approach 1Analysis 遍历矩阵，找出 岛屿 islands 个数。若不考虑岛屿的周围，则对应的周长为 4 * islands 对于岛屿，考虑其是否有左侧和顶部的邻居岛屿 neighbours。为了简化求解，对于所有岛屿，只考虑其左侧和顶部的邻居情况。 综上，最终所求的周长为 4 * islands - 2 * neighbours Solution Java 1234567891011121314151617public class Solution &#123; public int islandPerimeter(int[][] grid) &#123; int islands = 0, neighbours = 0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[i].length; j++) &#123; if (grid[i][j] == 1) &#123; islands++; // count islands if (i !=0 &amp;&amp; grid[i - 1][j] == 1) neighbours++; // count top neighbours if (j !=0 &amp;&amp; grid[i][j - 1] == 1) neighbours++; // count left neighbours &#125; &#125; &#125; return islands * 4 - neighbours * 2; &#125;&#125; C++ 12345678910111213141516171819class Solution &#123;public: int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int count = 0, repeat = 0; for (int i = 0; i&lt;grid.size(); i++) &#123; for (int j = 0; j&lt;grid[i].size(); j++) &#123; if (grid[i][j] == 1) &#123; count++; if (i!= 0 &amp;&amp; grid[i-1][j] == 1) repeat++; if (j!= 0 &amp;&amp; grid[i][j - 1] == 1) repeat++; &#125; &#125; &#125; return 4 * count - repeat * 2; &#125;&#125;; JavaScript 12345678910111213141516171819202122/** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var islandPerimeter = function(grid) &#123; var count=0; var repeat=0; for(var i=0;i&lt;grid.length;i++)&#123; for(var j=0;j&lt;grid[i].length;j++)&#123; if(grid[i][j] === 1)&#123; count++; if((i!==0) &amp;&amp; (grid[i-1][j]===1))&#123; repeat++; &#125; if((j!==0) &amp;&amp; (grid[i][j-1]===1))&#123; repeat++; &#125; &#125; &#125; &#125; return 4*count-2*repeat;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 进阶使用]]></title>
    <url>%2F2020%2F02%2F01%2Fgit-usage-improve%2F</url>
    <content type="text"><![CDATA[总结日常开发中的 Git 进阶使用 记录多 SSH 配置，git reflog 解决 detached-head 代码丢失问题 总结团队协作下，如何保持 git 提交信息简洁 Changelog 2018/07/09，撰写 2019/03/10，添加多SSH配置 2019/04/26，添加 git cherry-pick 2019/10/07，添加如何删除git所有历史提交信息 2019/10/14，添加 git merge --no-ff 2019/12/14，添加 git reflog 使用 2020/02/01，添加 删除所有历史提交记录 2020/02/01，添加 团队协作下，如何保持 git 提交信息简洁 Ref GitUp 如何高效使用github git reflog 解决提交代码丢失 detached-headreflog 是 Git 操作的一道安全保障，它能够记录几乎所有本地仓库的改变。包括所有分支 commit 提交，已经删除（其实并未被实际删除）commit 都会被记录。总结而言，只要 HEAD 发生变化，就可以通过 reflog 查看到。 detached-head 代码丢失找回 git提交到HEAD detached导致代码丢失 StackOverflow - gitx How do I get my ‘Detached HEAD’ commits back into master 背景日常开发中，切换分支误操作，造成本地代码修改丢失。 此时，可以借助 git reflog 找回丢失的代码修改。 丢失产生原因和步骤首先在 master 分支上开发，此时线上出现 bug 且回到旧版本的 tag。这时 master 分支上有一部分代码修改但未提交。 在 master 分支上执行 git status，有未提交的代码，如下图所示 在 master 分支上执行 git tag查看标签信息，如下图所示 此时有未提交的代码，然后执行 git checkout v1.0 这个时候，提示当前分支为 detached HEAD 然后再执行 git add ./git commit 和 git checkout master，切换回 master 分支。这个时候发现 detached HEAD 分支不见了，master 分支上未提交的代码也不见了。 代码找回执行 git reflog 查看提交记录 查找对应提交的 commitId 为 247e11b，然后执行下述命令行，找回丢失的代码 1234git checkout 247e11b //检出对应的提交git checkout -b diff //新建一个新的diff分支git checkout master //切换到master分支git merge diff //将新建的diff分支合并到master分支 删除所有历史提交记录 How to delete all commit history in github | Stackoverflow 此处介绍如何删除所有历史提交记录，形成一个全新的仓库。 1 - Checkout 1git checkout --orphan new_branch 2 - Add all the files 123git add -A//等效于 git add --all 或 git add . git add 中使用参数 -A 或 --all 表示追踪所有操作，包含新增、修改和删除 Git 2.0版开始，-A 参数为默认参数，即 git add . 等效于 git add -A 或 git add --all 3 - Commit the changes 1git commit -am "commit message" 4 - Delete the branch 1git branch -D master //同时删除本地和远程分支 5 - Rename the current branch to master 1git branch -m master 6 - force update your repository 1git push -f origin master 下面对上述步骤进行说明 git checkout –orphan如果你的某个分支上积累了无数次的无意义的提交，git log 信息满天飞，那么可以使用 git checkout --orphan &lt;new_branch_name&gt; 基于当前分支创建一个新的“孤儿(orphan)”的分支，没有任何提交历史，但包含当前分支所有内容 执行上述命令后，工作区（Workspace）中所有文件均被认为在该操作中新增(git statue 查看状态，所有文件状态均为 new file，如下图所示)，此时执行 git add . 会把所有文件添加到缓存区（Index） 严格意义上说，执行 git checkout --orphan &lt;new_branch_name&gt; 后，创建的并不是一个分支，因为此时 HEAD 指向的引用中没有 commit 值。只有在进行一次提交后，它才算得上真正的分支。 orphan 译为“孤儿”，该参数表示创建一个孤立的分支，没有任何提交历史，且与当前分支不存在任何关系（查看提交信息，可发现其为一个孤立的点，如下图所示） 孤儿（orphan）无父辈信息，同理，创建的分支也不包含任何历史提交信息 git commit -am git commit -m 与 git commit -am 的区别 git branch -m重命名 git push -f origin mastergit项目协作——保证git信息简洁同一分支 git pull 使用 rebase默认情况下，git pull 使用的是 merge 行为。多人协作开发时，会产生不必要的 merge 提交记录，造成提交链混乱不堪。 推荐在同一个分支更新代码时，使用 git pull --rebase。 12345# 为某个分支单独设置，这里是设置 dev 分支git config branch.dev.rebase true# 全局设置，所有的分支 git pull 均使用 --rebasegit config --global pull.rebase truegit config --global branch.autoSetupRebase always 分支合并使用 merge –no-ffUsage Fast-Forward：当前分支合并到另一分支时，如果没有冲突要解决，就会直接移动文件指针，并且不会产生合并提交记录。该过程中，存在git 文件指针快速移动， 因此该过程称为 Fast-Forward。 --no-ff(no fast foward)：每一次的合并，都会创建一个新的 commit 记录。使用 --no-ff，可以保持原有分支提交链的完整性，并且当该分支被删除时，提交信息依旧存在。 结合上图分析，在 dev（绿色） 分支上检出 feature-1 分支（蓝色），且 dev 分支不进行任何提交 直接 merge，默认采用 Fast-Forward，两个分支的提交链会合并为一条直线，不利于后期代码审查和维护 使用 git merge --no-ff feature-1 合并代码，会产生一个新的提交，且两个分支的提交链不会重叠，利于后期代码审查和维护 merge 默认设置git merge 默认使用 fast-forward，可以通过如下方式，修改为默认使用 --no-ff。 12git config --global merge.commit nogit config --global merge.ff no 此外，SourceTree 在设置中也可以设置 --no-ff。 IDE中使用GitVSCode中使用Git VSCode 中使用Git实践 推荐安装 Git Lens 和 Git History 插件 克隆代码 Ctrl + Shift + P 打开命令面板，输入 Git，选择 Git Clone 进行克隆代码 查看修改（VSCode会使用不同颜色进行标识） 红色箭头 - 标识删除行 蓝色竖线 - 该处有修改 绿色箭头 - 该处为新增 提交代码 Ctrl + Shift + G 打开代码管理器进行操作 git clone 设置缓存区当工程较大时，使用 git clone 拉取代码，可能会出现 early EOF 的报错或者拉取代码失败。 这是因为 git clone 本质上是建立一个 HTTP 连接，工程较大时会超过默认设置的缓存大小。 使用 git config --list 查看 http.postbuffer 的大小，确认是否小于下载的工程大小。 使用 git config --global http.postbuffer 524288000 //500x1024x1024 设置为500M 可以对缓存区大小进行设置。 git clean git clean -n - 查看哪些文件将被 git clean 清除，只是查看，并不会真正执行清除操作 git clean -f - 删除未跟踪的文件 untracked files git clean -fd - 连同未跟踪的目录也一起删除 git clean -fdx - 删除未跟踪的文件和文件目录，并移除被忽略的文件。其中，-x 表示移除被忽略的文件并且 .gitignore 文件中指定的文件和文件夹也会清除或者清除更改 git tag git tag： 显示所有标签 git tag -l &#39;v1.0.*&#39;： 用通配符查看符合筛选条件的标签 git show xxx： 查看标签信息（提交者，邮箱等） git tag xxx： 创建轻量标签 git tag -a xxx： 创建含有附注的标签 git tag -a xxx -m &#39;xxxx&#39;： 创建含有附注的标签，并附加提交信息（默认标签打到当前Head提交状态） git tag -a xxx -m &#39;xxxx&#39; \&lt;commitID&gt;： 创建补丁标签，即对之前的提交添加标签 git tag -d xxx： 删除本地标签 git push origin --delete tag &lt;tagname&gt;： 删除远程标签 需要注意的是，Git 使用的标签有 2 种类型：轻量级的（lightweight）和含附注的（annotated）。 —— git tag | Doc 轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。 含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。 一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。 cherry-pick Cherry-Pick | 掘金 使用场景cherry 译为樱桃，pick 译挑选。git cherry-pick 即选择某一个分支中的一个或几个提交，合并到其他分支中（选择的提交即所需的樱桃），主要使用场景为 情况1： 把弄错分支的提交移动到正确的分支上 情况2： 将其他分支的提交添加到当前分支 Demo假设工程有个稳定版分支 v2.0，还有个开发版分支 v3.0。开发分支还未彻底完成，不能直接把两个分支合并，这样会导致稳定版本混乱，但是又想增加一个 v3.0 中的功能到 v2.0 中，这里就可以使用 cherry-pick 了。 12345678910// 先在v3.0中查看要合并的commit的commit idgit log// 假设是 commit f79b0b1ffe445cab6e531260743fa4e08fb4048b// 切到v2.0中git checkout v2.0// 合并commitgit cherry-pick f79b0b1ffe445cab6e531260743fa4e08fb4048b git cherry-pick -x f79b0b1ffe445cab6e531260743fa4e08fb4048b //表示保留原提交的作者信息进行提交 语法 git cherry_pick commitID：将其他分支的 commitID 提交合并到当前分支 git cherry_pick commitID：将其他分支的 commitID 提交合并到当前分支，-x 表示保留原提交的作者信息进行提交 git cherry_pick &lt;start-commit-id&gt;…&lt;end-commit-id&gt;: 该功能在Git 1.7.2 版本后才支持，将一个连续区间范围的提交，合并到到当前分支。提交范围区间左开右闭，即(start, end] git cherry_pick &lt;start-commit-id&gt;^ … &lt;end-commit-id&gt;: 同上，使用 ^ 表示包含 start-commit-id，即[start, end] JetBranins 系列IDE，内置了git cherry-pick 快捷键（樱桃图标） git命令行代理设置设置代理12git config --global http.proxy 'socks5://127.0.0.1:1086'git config --global https.proxy 'socks5://127.0.0.1:1086' 取消代理12git config --global --unset http.proxygit config --global --unset https.proxy GitUp Work quickly, safely, and without headaches.The Git interface you’ve been missingall your life has finally arrived. GitUp Tutorial GitG gitg是一个git图形化界面。 安装 1brew install gitg //安装 使用 1gitg // 在目录终端下输入gitg即可 Git 代码回滚 谈谈 Git 代码回滚 场景描述某项目，并行开发着n个需求。提测时，各需求的代码被合并到测试分支。不久之后，要求把部分需求代码从测试分支抽离出去。使用下图场景进行描述。并行开发3个需求，分别是feature1，feature2，feature3。测试分支为master。 feature2与feature3对同一文件进行修改，故意制造一个冲突。 提测时，各分支代码被合并到测试分支（master）。首先，featuer1分支被合并到测试分支。 之后，featuer2分支也被合并到测试分支。 最后，合并feature3至测试分支。合并时，产生了与feature2代码的冲突。 解决冲突之后，继续将feature3合并至测试分支。 在feature3提测后，在测试分支上继续修复几个bug。 注意，此时feature2虽已提测但并未进入测试，此时的bug修复均是针对 feature1与feature3。 几天之后，收到通知，feature2的测试无法正常进行，需将代码从测试分支上抽出。 代码回滚操作Step 1 切换分支首先，切换到featuer2分支。以防万一，创建feature2-copy分支，对该分支进行备份。 1234567git checkout feature2 //切换到feature2分支git checkout -b feature2-copy //创建并切换到feature2-copy//第2行代码等同于git branch feature2-copy //创建feature2-copy分支git checkout feature2-copy //切换到feature2-copy分支 Step 2 确定要回滚的提交记录使用git log查看feature2-copy分支的提交记录（输入q退出git log环境）。 1git log 如图所示，需要回滚最新的3个提交。实际情况中，针对某需求的提交绝不止3个。若是将提交逐一revert，工作量是非常大的。需要考虑将n个commit合并为一个commit，最后一同revert。 Step 3 git rebase 合并提交使用git rebase -i来合并commit，传入需要拼接回滚至的提交的hashcode。（此处，将所有回滚的提交合并到需要回滚的commit集合中第一个提交） 12//hashcode为需要回滚的commit集合中第一个提交git rebase -i e08ddaf558b9ad84422db5e4b620dcab97623fde 将最近2次提交的command从pick改为s。 在Vim中， 输入i，进入INSERT模式。 输入ESC，进入命令行模式。 输入:wq，保存并退出VIM编辑器。 修改后，保存并退出，进入如下对话框。 此时，对最初一次的提交的commit message进行修改。 修改后保存并退出，使用git log 再次查看 feature2-copy 分支的信息。 如上图所示，3次提交被成功合并。 Step 4 git revert 撤销提交1git revert e544464c3de69adef5ca7556001abebaf40b218b 保存并退出，再次查看feature2-copy分支的提交记录。 Step 5 git cherry-pick12git checkout master //切换到测试分支git cherry-pick b309f7944d2422d8fe647dca61bda518b192628f 切换到测试分支，并执行 git cherry-pick 命令。至此，成功的将feature2分支从测试分支上抽离。 Git代码管理与团队协作 视频教程 | Segmentfault 代码最终提交效果如上图所示。 主分支为master，创建一个develop分支用于开发。 开发者leo和jack创建自己的分支leo和jack进行开发。开发完成后，将其合并到develop分支上。 项目进展到需要发布时，从develop分支创建release分支，用于测试。测试通过后，将release分支合并到develop分支和master分支上。 Demo目录和初始化12345//目录结构-- c4---|--- origin //模拟远程仓库 git init --bare 创建---|--- leo //开发者1 设置user.name = 'leo'---|--- jack //开发者2 设置user.name = 'jack' git init --bare 用于创建一个“裸仓库”——只含有 .git 目录，不含源文件。详情参考 Ref。 1234567891011mkdir c4cd c4mkdir origin cd origin git init --bare //创建一个裸仓库cd ..//克隆远程仓库至两个开发者目录——leo, jackgit clone origin leogit clone origin jack 为了模拟团队协作，对两个开发者目录，分别设置不同的 user.name 信息。 git config --local，使用 --local 参数，只对本地参数进行配置。 12345cd leogit config --local user.name 'leo'cd jackgit config --local user.name 'jack' 开发流程master 分支初始化12345678cd leo echo a = 1 &gt; leo1.py // 将a=1写入leo1.py文件cat leo1.py //显示文件的内容git add . git commit -m "c4 项目初始化"git tag 0.0.1 //添加标签 方便管理 创建develop分支123456789git checkout -b developecho b = 2 &gt; leo1.pygit add .git commit -m "建立开发分支并提交"git push origin develop //推送到远程分支gitg // 使用gitg图形化工具查看提交信息 leo进行开发12345678910git checkout -b leoecho c=3 &gt; leo2.pygit add .git commit -m "创建leo分支并开发"//合并当前开发到dev分支git checkout developgit merge --no-ff leo //合并分支 并保留leo分支信息gitg //查看提交历史树 gui git merge --no-ff leo，合并分支，并保留leo分支的信息。关于参数--no-ff的详情，参考 Ref。 最后，将开发分支推送到远程。 123git push origin developgitg jack进行开发首先，从远程拉取最新代码。 1git pull origin 之后，jack进行日常开发，流程同leo开发，此处不再赘述。 release分支测试项目进展到需发布时，从develop分支创建release分支，用于测试。测试通过后，将release分支合并到develop分支和master分支上。 远程多分支代码拉取此处记录如何拉取远程所有分支，并建立本地分支追踪远程分支。 Step 1： clone 远程代码 Step 2： 在sourcetree中可以看出，远程分支有origin/master，origin/dev和origin/webtest。此时本地分支为dev，并建立了追踪关系。 Step 3： 在对应的远程分支（origin/master）上点击，检出分支，设定本地分支名，并追踪远程分支即可。 Step 4： 最终效果如下图，检出本地分支并追踪远程。 Tip git branch -r： 查看远程分支 git branch -a： 查看所有分支 Ref: Blog 多SSH配置 取消全局账户和邮箱设置 12git config --unset --global user.namegit config --unset --global user.email 新建SSH key： 123cd ~/.sshssh-keygen -t rsa -C "liubaoshuai1@jd.com" Enter file in which to save the key (/User/lbs/.ssh/id_rsa): id_rsa_jd # 输入文件名 新密钥添加到 SSH Agent 默认只读取 id_rsa，为了让 SSH 识别新的私钥，需将其添加到 SSH Agent 中 1ssh-add ~/.ssh/id_rsa_jd 若出现 Could not open a connection to your authentication agent 错误，执行以下命令 12ssh-agent bashssh-add ~/.ssh/id_rsa_jd 修改 config 文件 1vim config # 若没有，可创建 touch config 1234567891011121314# default user (lbs1203940926@163.com)Host github.com HostName github.com User lbs1203940926@163.com PreferredAuthentications publickey IdentityFile /Users/lbs/.ssh/id_rsa# jd-gitlab(liubaoshuai1@jd.com))Host git.jd.com HostName git.jd.comm User liubaoshuai1@jd.com PreferredAuthentications publickey IdentityFile /Users/lbs/.ssh/id_rs_jd 拉取JD代码 1234567# 测试暂不支持SourceTree中远程拉取，需要终端命令行拉取# 且暂只支持https协议git clone http://git.jd.com/jdreact/jdreact-jsbundle-jdreactonehourarrive# UserName: liubaoshuai# PassWord: ERP's password]]></content>
      <categories>
        <category>Develop Tools</category>
      </categories>
      <tags>
        <tag>Develop Tools</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis基础知识梳理]]></title>
    <url>%2F2020%2F01%2F31%2Fredis-basic%2F</url>
    <content type="text"><![CDATA[对 Redis 基础知识进行梳理，包括Redis的5种数据类型，事务，过期时间，消息通知，优先级队列，管道，数据持久化，复制，哨兵，事务等 更新日志 2020/01/30，撰写 学习资料汇总 Redis官网 Redis中文官网 Redis菜鸟教程 Redis源码 —— 使用C语言开发，源码只有3万多行，降低了用户通过修改Redis源码来提升性能的门槛 Redis 初识 Redis = Remote Dictionary Server，远程字典服务器 Redis 是一个 高性能的 key-value 存储系统，通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和有序集合(sorted sets)等类型。 Redis 与其他 key - value 缓存产品有以下3个特点 Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储 Redis支持数据的备份，即master-slave模式的数据备份 Redis 性能极高，读取速度是110000次/s，写入的速度是81000次/s。Redis数据库中的所有数据都存储在内存中，内存读写速度远快于磁盘。 Redis功能丰富，除了用于数据库开发，还可以用于缓存，队列系统等。 Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 Redis环境配置安装 Redis Mac上，建议使用Homebrew安装Redis 12345678910brew install redis //会默认安装当前最新的稳定版本/// 此处安装路径为 usr/local/Cellar/redis/5.0.7//==&gt; Caveats// To have launchd start redis now and restart at login:// brew services start redis//Or, if you don't want/need a background service you can just run:// redis-server /usr/local/etc/redis.conf//==&gt; Summary//🍺 /usr/local/Cellar/redis/5.0.7: 13 files, 3.1MB 如果需要后台运行Redis服务，使用命令 brew services start redis 如果不需要后台运行Redis服务，使用命令 redis-server /usr/local/etc/redis.conf 启动/停止Redis执行 brew services start redi 命令，第一次启动 Redis 后，在 /usr/local/bin 目录下，会生成如下文件夹 文件名 说明 redis-server redis 服务器 redis-cli redis 命令行客户端 redis-benchmark redis 性能测试工具 redis-check-aof AOF 文件修复工具 redis-check-dump RDB 文件检查工具 redis-sentinel Sentinel 服务器 启动Redis 123redis-server //默认端口号 6379redis-server --port 6380 //指定端口号 停止Redis 考虑到 Redis 有可能正在将内存中数据同步到硬盘中，强行终止Redis进程可能会导致数据丢失。因此，正确停止Redis的方式应该是向Redis发送 SHUTDOWN 命令，方法为 1redis-cli SHUTDOWN 当 Redis 收到 SHUTDOWN 命令后，会先断开所有客户端连接，然后根据配置执行数据持久化，最后完成退出。 Redis 可以妥善处理 SIGTERM 信号，所以使用 kill Redis 进程的 PID，也可以正常结束 Redis，效果和发送 SHUTDOWN 命令一样。 redis-cliRedis 命令用于在 Redis 服务上执行操作。要在 Redis 服务上执行命令需要一个 Redis 客户端。 redis-cli 是Redis自带的基于命令行的Redis客户端，下面介绍如果通过 redis-cli 向 Redis 发送命令。 通过 redis-cli 向 Redis 发送命令有2种方式 方式1：将命令作为 redis-cli 的参数执行。例如 redis-cli SHUTDOWN 方式2：执行 redis-cli（不附带任何参数），进入交互模式后，可以自由输入命令 12345678910// 方式1：将命令作为 redis-cli 的参数执行redis-cli SHUTDOWN//redis默认服务器地址127.0.0.1，默认端口号6379 //也可以使用-h指定服务器地址，-p指定端口号redis-cli -h 127.0.0.1 -p 6379 //使用PING命令测试客户端和Redis的连接是否正常redis-cli PING //返回PONG 表示连接正常 12345//方式2: 执行 redis-cli（不附带任何参数），进入交互模式后，可以自由输入命令lbsMacBook-Pro:~ lbs$ redis-cli127.0.0.1:6379&gt; PINGPONG127.0.0.1:6379&gt; 多数据库Redis 是一个字典结构的存储服务器，一个 Redis 实例提供了多个用来存储的字典，可以把其中的每个字典都理解成一个独立的数据库。 每个数据库对外都是一个从0开始的递增数字命名，Redis默认支持16个数据库 Redis不支持自定义数据库名称，每个数据库都以编号命名 需要注意的是，一个Redis实例的多个数据库之间并不是完全隔离的，比如 FLUSHALL 命令可以清空一个 Redis 实例中所有数据库中的数据。综上所述，这些数据库更像是一种命名空间，而不适宜存储不同应用程序的数据。比如，可以使用0号数据库存储应用A的生产环境数据，使用1号数据库存储应用A的测试环境数据，而不应该使用1号数据库存储应用B的数据。 不同的应用，应该使用不同的Redis实例存储数据。 由于Redis非常轻量，一个空的Redis实例占用的内存只有1MB，所以不用担心多个Redis实例会额外占用很多内存。 Redis 入门命令行基础 获得符合规则的键名列表 1KEYS pattern pattern 支持 glob 风格通配符格式，具体如下 符号 含义 ? 匹配一个字符 * 匹配任意个（包括0个）字符 [] 匹配括号间的任一字符，可以使用 - 表示一个范围，如 [1-9] \x 用于转义字符 例如，查询当前的所有键名列表 1234&gt; set bar 1OK&gt; KEYS *1) "bar" 判断一个键是否存在 1234EXISTS key//返回(integer) 1，表示存在//返回(integer) 0，表示不存在 删除键 1234DEL key [key ...]//返回(integer) 1，表示删除成功//返回(integer) 0，表示删除不成功 获得键值的数据类型 123TYPE key//返回 string list 等 Redis 5 种数据类型Redis 支持5种数据类型 string（字符串） hash（哈希或散列） list（列表） set（集合） zset(sorted set，有序集合) 字符串类型 赋值和取值 123SET key valueGET key //当键不存在时会返回空结果 递增数字 1INCR key 当要操作的键不存在时，默认键值为0，所以第一次递增后结果为1，如下所示 1234&gt; INCR num(integer) 1&gt; INCR num(integer) 2 增加指定的整数 1INCRBY key increment 减少指定的整数 123DECR keyDECRBY key increment 增加指定浮点数 1INCRBYFLOAT key increment 向尾部追加值 1APPEND key value APPEND 命令中，若键不存在，则将该键的值设为 value，相当于执行了 SET key value。 获取字符串长度 1STRLEN key 对于汉字，Redis使用UTF-8编码的中文，如下示例中，“你”和“好”两个字的UTF-8编码的长度都是3，所以返回的字符串长度为6。 1234&gt; SET key1 你好OK&gt; STRLEN key1(integer) 6 同时获得/设置多个键值 123MSET key1 value1 key2 value2 key3 value3MGET key1 key2 key3 位操作 1234567GETBIT key offset //获取一个字符串类型键指定位置的二进制位的值（0或1） SETBIT key offset value //设置指定位置的二进制位的值BITCOUNT key [start] [end] //获得字符串类型键中值是1的二进制位个数BITOP operation destkey key [key ...] //对多个字符串类型键进行位运算，结果存储在destkey 一个字节由8个二进制位组成。Redis 提供了 4 个命令可以直接对二进制位操作。 下面进行示例分析。 1SET foo bar “bar”的3个字母对应的ASCII码分别是98，97，114，转换为对应的二进制数值，foo 键中的二进制位结构为01100010,01100001,01110010。 (1) 使用 GETBIT key offset 获取一个字符串类型键指定位置的二进制位的值（0或1） 12redis&gt; GETBIT foo 6(integer) 1 如果获取的二进制位的索引超出了键值的二进制位的实际长度，则默认返回 0 (2) BITOP operation destkey key [key ...] 可以对多个字符串类型键进行位运算，结果存储在 destkey 12345678127.0.0.1:6379&gt; SET foo1 barOK127.0.0.1:6379&gt; SET foo2 aarOK127.0.0.1:6379&gt; BITOP OR res foo1 foo2 //或运算(integer) 3127.0.0.1:6379&gt; GET res"car" 哈希（散列）类型哈希（或散列）hash 类型的键值也是一种字典结构，其存储了字段（field）和字段值的映射，但字段值只能是字符串，不支持其他数据类型。 赋值和取值 1234567HSET key field value //不区分插入和更新操作，即更新数据时不用事先判断是否存在 HGET key fieldHMSET key field value [field value ...]HMGET key field [field ...]HGETALL key 判断字段是否存在 1HEXISTS key field 仅仅在字段不存在是赋值 1HSETNX key field value HSETNX 和 HSET 命令类似，区别在于如果字段已经存在，HSETNX 命令将不执行任何操作。 HSETNX 中的 NX 表示 if Not eXists。 增加数字 1HINCRBY key filed increment 删除字段 1HDEL key field [field ...] 只获取字段名称或字段值 123HKEYS keyHVALS key 获得字段数量 1HLEN key 列表类型列表（list）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获取列表的某一个片段。 列表类型内部使用的是双向链表实现的，所以想列表两端添加元素的时间复杂度是 O(1)，获取越接近两端的元素速度就越快，但是通过索引访问元素会比较慢。因此，针对双向链表的特点，列表类型特别适合如下场景 如社交网站的新鲜事，我们只关心最新内容，即使新鲜事达到几千万条，获取列表尾部的100条最新数据也是很快的 如日志记录场景，双向链表保证了插入新日志的速度不会受到已有日志数量的影响 借助列表类型，Redis还可以作为队列使用 向列表两端增加元素 12LPUSH key value [value ...] //向列表左边插入元素RPUSH key value [value ...] 从列表两端弹出元素 12LPOP key RPOP key 获取列表中元素个数 1LLEN key // 当键不存在则返回0 获得列表片段 1LRANGE key start stop //返回区间[start,stop]的列表片段（区间闭合），不改变原列表 删除列表中指定的值 12LREM key count value //删除列表中前count个值为value的元素，返回值是实际删除的元素个数 当 count 大于0时，会从列表左边开始删除前count 个；当小于0时，会从列表右边边开始；当 count 等于0时，会删除列表中所有值为 value 的元素。 获得/设置指定索引的元素值 123LINDEX key indexLSET key index value 若 index 小于0，表示从列表右边开始计算索引，最右边的元素的索引值是 -1。 只保留列表指定片段 1LTRIM key start stop //只保留区间[start,stop]的列表片段（区间闭合），改变了原列表 向列表中插入元素 12LINSERT key BEFORE|AFTER pivot value //从左到右查找列表的pivot元素，在该元素前或后，插入value元素 将元素从一个列表转到另一个列表 12RPOPLPUSH source destination//RPOPLPUSH表示先执行RPOP，再执行LPUSH 集合类型相比于列表，集合（set）中的元素是全局唯一的，并且是无序的。 集合（set）类型在Redis内部是使用值为空的散列表(hash table)实现的，所以向集合中插入或删除元素，判断元素是否存在，这些操作的时间复杂度都是 O(1)。 更方便的是，采用集合类型，多个集合类型之间还可以进行交集，并集和差集运算。 增加/删除元素 12SADD key member [menber ...] //如果键不存在，则自动创建，返回值为成功加入的元素的数量SREM key member [menber ...] 获得集合找那个所有的元素 1SMEMBERS key 判断元素是否在集合中 12// 时间复杂度位O(1) 速度较快SISMEMBER key member 集合之间的运算 123SDIFF key [key ...] //差集SINTER key [key ...] //交集SUNION key [key ...] //并集 获取集合中元素个数 1SCARD key 进行集合运算并将结果存储 123SDIFFSTORE destination key [key ...]SINTERSTORE destination key [key ...]SUNIONSTORE destination key [key ...] 随机获得集合中的元素 1SRANDMEMBER key [count] 从集合中弹出一个元素 1SPOP key 有序集合类型有序集合(sorted list)类型，是在集合类型的基础上，为每个元素关联一个分数（score，可以理解为索引值），使得元素有序。 Redis中，采用哈希表和跳跃表（Skip list）实现有序集合类型。所以即使读取位于中间部分的数据，速度也是很快的（时间复杂度是``O(logN)`）。 增加元素 12//添加一个member元素和该元素的分数scoreZADD key score member [score member] 获得元素的分数 1ZSCORE key member 获得排名在某个范围的元素列表 123456//按照元素分数从小到大的顺序，返回索引在区间[start,stop]的所有元素//如果有参数WITHSCORES，表示返回的元素列表包含分数信息ZRANGE key start stop [WITHSCORES]//类似ZRANGE，只不过是按照分数从大到小的顺序ZREVRANGE key start stop [WITHSCORES] 获得指定分数范围的元素 123456//按照元素分数从小到大的顺序，返回索引在区间[start,stop]的所有元素//如果有参数WITHSCORES，表示返回的元素列表包含分数信息ZRANGE key start stop [WITHSCORES]//类似ZRANGE，只不过是按照分数从大到小的顺序ZREVRANGE key start stop [WITHSCORES] 获得指定分数范围的元素 123//按照元素分数从小到大，返回分数在区间[min,max]之间的元素//LIMIT offset count 表示在获得元素列表的基础上，向后偏移（跳过）offset个元素，并且只获取之后的前count个元素ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 增加某个元素的分数 1ZINCRBY key increment member 获得集合中元素的数量 1ZCARD key 获得指定分数范围内的元素个数 1ZCOUNT key min max 按照排名范围删除元素 12//按照元素分数从小到大顺序，删除指定排名范围内的元素，并返回删除的元素数量ZREMRANGEBYRANK key start stop 按照分数范围删除元素 12//返回删除的元素数量ZREMRANGEBYSCORE key min max 获得元素的排名 12ZRANK key member //按照分数从小到大顺序ZRANK key member //按照分数从大到小顺序 Redis进阶事务MULTI EXEC事务(transaction)是一组命令的集合，事务同命令一样，都是Redis的最小执行单位。一个事务中的命令要么都执行，要么都不执行。事务的应用非常普遍，如银行转账等。 Redis的事务还可以保证一个事务内的命令一次执行而不被其他命令插入。 事务的原理是先将属于一个事务的命令发送给Redis，然后再让Redis一次执行这些命令，例如 123456789redis&gt; MULTIOKredis&gt; SADD "user:1:following" 2QUEEDredis&gt; SADD "user:2:following" 1QUEEDredis&gt; EXEC1) (integer) 12) (integer) 1 上面的代码演示了事务的使用方式。首先使用 MULIL 命令告诉Redis：“下面我发给你的命令属于同一个事务，你先不要执行，而是把它们暂时存起来”。 随后发送两个 SADD 命令执行事务操作，Redis返回 QUEED 表示这2条命令已经进入等待执行的事务队列中了。 最后，发送 EXEC 命令告诉Redis将等待执行的事务队列中的所有命令按照发送顺序执行。 事务中的命令是在 EXEC 之后才执行的，因此，一个事务中，只有当所有命令都依次执行完成后，才能得到每个结果的返回值。 WATCH一个事务中，只有当所有命令都依次执行完成后才能得到每个结果的返回值。 可是有些情况下，需要先获得一条命令的返回值，根据返回值再执行下一条命令。针对该情况，可以使用 WATCH 命令。 WATCH 命令可以监控一个或多个键，一旦其中有一个键被修改或删除，之后的事务就不会执行。监控一直到 EXEC 命令。（事务中的命令是在 EXEC 之后才执行的，所以在 MULTI 命令后可以修改 WATCH 监控的键值） 1234567891011121314redis&gt; SET key 1OKredis&gt; WATCH keyOKredis&gt; SET key 2OKredis&gt; MULTIOKredis&gt; SET key 3QUEEDredis&gt; EXECnilredis&gt; GET key"2" 上例中，执行 WATCH 命令后，事务修改了 key 值，所以最后事务代码并没有执行，EXEC 命令返回结果为 nil。 执行 EXEC 命令后悔取消对所有键的监控。 过期时间Redis 中可以使用 EXPTRE 命令设置一个键的过期时间，到时间后 Redis 会自动删除它。 设置过期时间 123EXPIRE key seconds //seconds 单位为秒PEXPIRE key milliseconds //milliseconds 单位为毫秒 查询键还有多少时间会被删除 123456TTL key //返回时间单位为秒PTTL key //返回时间单位为毫秒// 键不存在时，命令返回-2// 键未设置过期时间时，命令返回-1 取消键的过期时间设置 1PERSIST key 除了 PERSIST 命令外，使用 SET 或 GETSET 命令为键赋值，也会同时清除键的过期时间。 实现访问频率限制考虑如下场景——为了减轻服务器的压力，限制每个用户（IP）每分钟最多只能访问10次，就可以使用过期时间 EXPIRE 实现 创建一个 rate.limiting:userIP 的键 设置 EXPIRE key seconds，过期时间为60s。一分钟后，该键会被自动删除 用户每次访问服务器，使用 INCR 递增该键值 当访问次数达到10后，提示用户稍后访问 上述流程的伪代码如下 1234567891011$isKeyExists = EXISTS rate.limiting:$IPif isKeyExists is 1 $time = INCR rate.limiting:$IP if $time &gt; 10 print 访问频率超过了限制，请稍后再试 exitelse MULTI //使用事务，避免EXPIRE因为某种原因未执行，导致该键值一直存在 INCR rate.limiting:$IP EXPIRE $keyName, 60 EXEC 上述代码还有一个问题，比如用户在第1分钟的最后一秒访问了9次，又在下一分钟的第一秒访问了10次。这种访问是可以通过上述访问限制的，但实际上用户在2秒内访问了19次服务器。 为了处理上述场景，可以对代码进行优化 使用一个列表存储用户最近10次访问服务器的时间 一旦键中的元素大于10个，就判断时间最早的元素距现在的时间是否小于1分钟。 如果是，则表示用户最近一分钟的访问次数超过了10次，进行限流提醒。 如果不是，就将现在的时间加入到列表中，同时把最早的元素删除。 12345678910$listLength = LLEN rate.limiting:$IPif listLength &lt; 10 LPUSH rate.limiting:$IP,now()else $time = LINDEX rate.limiting:$IP, -1 if now() - $time &gt; 60 print 访问频率超过了限制，请稍后再试 else LPUSH rate.limiting:$IP,now() LTRIM rate.limiting:$IP,0,9 实现缓存为了提高服务器负载能力，常常需要将一些访问频率较高但是CPU或则IO资源消耗较大的操作的结果缓存起来，并希望让这些缓存过一段时间后自动过期。 实际开发中很难为缓存键设定合理的过期时间，为此可以限制Redis可以使用的最大内存，并让Redis按照一定的规则淘汰不需要的缓存键。这种方式在只将Redis用作缓存系统时非常实用。 Redis配置文件的 maxmemory 属性限定了Redis可以使用的最大内存。当超出这个限制时，Redis会依据 maxmemory-policy 参数指定的策略来删除不要的键值直到Redis占用的内存大小小于指定内存。 maxmemory-policy 支持LRU(Least Recently Used) 算法规则，即“最近最少使用原则”，其认为最近最少使用的键在未来一段时间内也不会被用到，当内存不足时这些键是可以被删除的。 排序SORT 命令可以对列表类型，集合类型和有序集合类型键进行排序，并且可以完成和关系数据库中的连接查询类似的任务。 1SORT key BY 参考键 GET ... STORE destkey BY 参考键中，如果提供了 BY 参数，SORT 命令将不再依据元素自身的值进行排序，而是对每个元素使用元素的值替换参考键中的第一个 &quot;*&quot; 并获取其值，然后依据该值对元素进行排序。 例如，下述语句将读取如 post:2，post:6，post:12，post:26 几个散列键中的 time 字段的值并以此决定排序结果。 1SORT tag:ruby:posts BY post:*-&gt;time DESC GET 参数不影响排序，它的作用是使 SORT 命令的返回结果不再是元素自身的值，而是 GET 参数中指定的键值。 STORE 参数用于将排序结果存储到指定的键中 性能优化SORT 命令的时间复杂度是 O(n+mlog(m))，其中 n 表示要排序的列表（或集合或有序集合）中的元素个数，m表示要返回的元素个数。当 n 较大的时候，排序命令的性能相对较低，并且 Redis 在排序前会建立一个长度为 n 的容器来存储待排序的元素，虽然是一个临时的过程，但是如果同时进行较多的大数据量的排序操作则会严重影响性能。 所以开发中使用 SORT 命令需要注意 尽可能减少待排序键中元素的数量（使 n 尽可能小） 使用 LIMIT 参数只获取需要的数据（使 m 尽可能小） 如果需要排序的数据量较大，尽可能使用 STORE 参数将结果缓存 消息通知任务队列任务队列，即“传递任务的队列”。和任务队列进行交互的实体有两类，一类是生产者（producer），另一类是消费者（consumer）。生产者会将需要处理的任务放入任务队列中，而消费者会不断地从任务队列中读入任务信息并执行。 使用任务队列的好处 松耦合：生产者和消费者不需要知道彼此的实现细节，只需约定好的任务的描述格式即可。 易于扩展：消费者可以扩展到多个，而且可以分布在不同的服务器中，可以轻易地降低单台服务器的负载 使用Redis实现任务队列使用Redis的列表结构和 RPOP，LPUSH 命令，可以实现简单的任务队列，伪代码如下所示 123456789# 无限循环读取任务队列中的内容loop $task = RPOP queue if $task # 如果任务队列中有任务则执行任务 execute($task) else # 如果没有则等待1秒，以免过于频繁地请求数据 wait 1 second 上述伪代码有个不足之处，当任务队列中没有任何任务时，消费者每秒都会调用一次 RPOP 命令查询是否有新任务。 如果可以实现一旦有新任务加入任务队列就通知消费者就好了。其实借助 BRPOP 命令就可以实现这样的需求。 如上伪代码可以优化为 12345loop # 如果任务队列中没有新任务，BRPOP命令会一直阻塞，不会执行execute() $task = BRPOP queue, 0 # 返回值是一个数组，数组第2个元素是我们需要的任务 execute($task[1]) BRPOP 和 RPOP 命令类似，唯一的区别就是当列表中没有元素时，BRPOP 命令会一直阻塞连接，直到有新元素加入。 1BRPOP key [key ...] timeout BRPOP 命令接收2个参数，第1个参数是键名，第2个参数是超时时间，单位是秒。当超过了此时间仍然没有获得新元素的话，就会返回 nil。如果传入时间参数为0（如下伪代码示例），则表示不限制等待时间，即如果没有新元素加入队列就会永远阻塞下去。 获得一个元素后，BRPOP 命令会返回一个数组，共2个值，分别是键名和元素值。第2个参数，元素值，就是待处理的任务。 优先级队列在实际开发中，针对多种不同的任务，经常会需要根据任务的优先级，去执行优先级较高的任务，即需要实现一个优先级队列。 BRPOP 和 BLPOP 命令可以同时接收多个键，可以实现优先级队列。 1BRPOP key [key ...] timeout 例如，BLPOP queue:1 queue:2 0，表示同时检测多个键——queue:1 和 queue:2 如果所有键都没元素则阻塞 如果有一个键有元素则会从该键中弹出元素 如果多个键都有元素，则按照从左到右顺序读取第一个键中的一个元素 1234567891011121314redis&gt; LPUSH queue:2 task11) (integer) 1redis&gt; LPUSH queue:3 task21) (integer) 1//...redis&gt;BRPOP queue:1 queue:2 queue:3 01) "queue:2"2) "task1"redis&gt;BLPOP queue:1 queue:2 queue:3 01) "queue:3"2) "task2" 使用 BRPOP 创建优先级队列时，RPOP 表示队列左进右出，因此有如下结构。即 BRPOP queue:1 queue:2 queue:3 0 命令中，越靠左的键优先级越高（queue:1 的优先级最高，因此会按照从左到右顺序读取第一个键中的一个元素。 1(L-左进)--- | queue:3| queue:2| queue:1| --&gt; (R-右出) 使用 BLPOP 创建优先级队列时，LPOP 表示队列右进左出，因此有如下结构。即 BLPOP queue:1 queue:2 queue:3 0 命令中，越靠右的键优先级越高（queue:3 的优先级最高），因此会按照从右到左顺序读取第一个键中的一个元素。 1(L-左出) &lt;--- | queue:1| queue:2| queue:3| --- (R-右进) “发布/订阅”模式“发布/订阅”模式包含两种角色，分别是发布者和订阅者。订阅者可以订阅一个或多个频道（channel），发布者可以向指定的频道发送消息，所有订阅该频道的订阅者都会受到改消息。 发布消息 1PUBLISH channel message //命令返回值表示接收到这条消息的订阅者的数量 发布出去的消息不会被持久化，也就是说当有客户订阅该频道 channel后只能收到后续发布的消息，之前发送的消息就收不到了。 订阅消息 1SUBSCRIBE channel [channel ...] 执行 SUBSCRIBE 命令后客户端会进入订阅状态，此状态下的客户端不能使用 SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE 和 PUNSUBSCRIBE 这4个属于 “发布/订阅”模式的命令之外的命令，否则会报错。 进入订阅状态后的客户端，可能收到3种类型的回复，每种类型的回复都包括3个值。第一个值是消息类型，根据消息类型的不同，第二，第三个值的含义也不同。消息类型的取值可能有以下3个 subscribe。表示订阅消息成功的反馈。第2个值是订阅成功的频道名称，第3个值是当前客户端订阅的频道数量 message。表示接收到的消息。第2个参数表示频道名称，第3个参数是消息内容 unscribe。表示成功取消订阅某个频道。第2个参数表示频道名称，第3个参数是当前客户端订阅的频道数量，当该值为0时，客户端会退出订阅状态。 下面看一个实例。 首先Redis的一个实例RedisA在频道 channel1.1 发布一个消息 123//RedisAredisA&gt; PUBLISH channel1.1 hi(integer) 0 //表示当前没有客户端订阅该消息 Redis的另外一个实例RedisB 订阅频道 channel1.1 123456//RedisBredisB&gt; SUBSCRIBE channel1.1Reading messages... (press Ctrl-C to quit)1) "subscribe" //订阅消息成功2) "channel1.1"3) (integer) 1 实例RedisA继续在频道 channel1.1 发布一个消息 123//RedisAredisA&gt; PUBLISH channel1.1 hello(integer) 1 //表示当前没有客户端订阅该消息 此时，实例RedisB 会收到如下消息 1231) "message"2) "channel1.1"3) "hello" 按照规则订阅可以使用 PSUBSCRIBE 订阅指定的规则，规则支持 glob 风格通配符格式。 符号 含义 ? 匹配一个字符 * 匹配任意个（包括0个）字符 [] 匹配括号间的任一字符，可以使用 - 表示一个范围，如 [1-9] \x 用于转义字符 例如 PSUBSCRIBE channel1.?*命令中，规则 channel1.?* 可以匹配 channel1.1 和 channel1.10，但不会匹配 channel1.1。 管道 客户端和Redis使用TCP协议连接。 不论是客户端向Redis发送命令，还是Redis向客户端返回命令结果，都需要经过网络传输。这两个部分的总耗时成为往返时延。 大致来说，到本地回环地址（loop back address）的往返时间，在数量级上相当于Redis处理一条简单命令 (如 LPUSH list 1 2 3) 的时间。 Redis的底层通信协议对管道（pipelining）提供了支持。通过管道可以一次性发送多条命令并在执行完后一次性将结果返回。 当一组命令中每条命令都不依赖于之前命令的执行结果时就可以将这一组命令一起通过管道发出。管道通过减少客户端和Redis的通信次数，来实现降低往返时延累计值的目的。 节省空间Redis是一个基于内存的数据库，所有数据都存储在内存中。因此如何节省内存，控制成本，至关重要。节省内存空间，可以从以下方面考虑 精简键名和键值 内部编码优化 Redis为每种数据类型都提供了2种内部编码方式，用于节省内存空间。 以散列类型为例，散列类型是通过散列表实现的，这样可以实现时间复杂度 O(1) 的查找，赋值操作。然而当元素较少时，O(1)的操作并不会比 O(n) 有明显的性能提高。所以Redis会根据实际情况自动调整，采用一种更为紧凑但性能稍差（查找元素的复杂度为O(n)）的编码方式。 内部编码方式的选择，对于开发者来说是透明的。 可以使用 OBJECT ENCODING key 命令查看某个键的内部编码方式。 1234redis&gt; SET foo barOKredis&gt; OBJECT ENCODING foo"raw" Redis 脚本Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本（和之后版本）通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。 使用脚本的好处包括 减少网络开销：使用脚本可以将多个命令的多次请求，通过一次请求完成，减少网络往返时延 原子操作：Redis将整个脚本作为一个整体执行，中间不会被其他命令插入。即编写脚本过程中无需担心会出现竞态条件，也无需使用事务。事务可以完成的所有功能都可以使用脚本实现。 复用：客户端发送的脚本会永久存储在Redis中，其他客户端也可以复用这一脚本。 Redis 持久化Redis 支持2种方式的持久化 RDB 方式：根据指定的规则“定时”将内存中的数据存储在硬盘上 AOF 方式：每次执行命令后将命令本身记录下来 通过 RDB 方式实现持久化，一旦 Redis 异常退出，就会丢失最后一次快照以后更改的所有数据。如果数据相对重要，希望损失降到最小，则可以使用 AOF 方式进行持久化。 Redis 允许同时开启 RDB 和 AOF 方式，既保证了数据安全又使得进行备份等操作十分容易。此时重新启动 Redis 后，Redis 会使用 AOF 文件来恢复数据，因为 AOF 方式的持久化可能丢失的数据更少。 RDB方式RDB 方式的持久化是通过快照（snapshoting）完成的，当符合一定条件时 Redis 会自动将内存中的所有数据生成一份副本并存储在硬盘上，这个过程即“快照”。 快照触发条件Redis 会在以下几种情况下对数据进行快照 根据配置规则进行自动快照：每当时间窗口 M 内被更改的键的个数大于 N 时，即符合自动快照条件 用户执行 SAVE 或 BGSAVE 命令 执行 SAVE 命令时，Redis同步地执行快照操作。快照执行过程中会阻塞所有来自客户端的请求。所以应该尽量避免在生产环境中执行该指令 BGSAVE 命令可以在后台异步地执行快照操作，同时可以响应客户端的请求 执行 FLUSHALL 命令 FLUSHALL 命令会清楚数据库中的所有操作 只要自动快照条件不为空（即使不满足该条件），执行 FLUSHALL 命令后，也会触发快照操作 当没有定义自动快照条件时，执行 FLUSHALL 命令不会触发快照操作 执行复制（replication）时：设置了主从模式时，Redis会在复制初始化时进行自动快照 快照原理Redis 默认会将快照文件存储在 Redis 当前进程的工作目录种的 dump.rdb 文件中。快照的过程如下 Redis 使用 fork 函数复制一份当前进程（父进程）的副本（子进程） 父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件 当子进程写入完成所有数据后会用该临时文件替换旧的 RDB 文件，至此一次快照操作完成。 AOF方式AOF(append only file) 方式可以将 Redis 执行的每一条命写命令追加到硬盘文件中，这一过程显然会降低 Redis 性能。但大部分情况下这个影响是可以接收的，另外使用较快的硬盘可以提高 AOF 的性能。 开启AOF 默认情况下没有开启AOF，执行如下命令可以开启AOF。默认情况下，AOF文件的保存位置和RDB文件的位置相同，默认的文件名是 appendonly.aof。 1appendonly yes AOF的实现 AOF 文件的内容正是Redis客户端向Redis发送的原始通信协议的内容。 同步硬盘数据 由于操作系统的缓存机制，AOF文件数据并没有直接真正地写入硬盘，而是进入了系统的硬盘缓存。在默认情况下系统每 30 秒会执行一次同步操作，以便将硬盘缓存中的内容真正地写入硬盘。在这30秒内，如果系统异常退出则会导致硬盘缓存中的数据丢失。 一般来讲，启用AOF持久化的应用都无法容忍这样的损失。这就需要 Redis 在写入AOF 文件后主动要求系统将硬盘缓存内容同步到硬盘中。在 Redis 中，可以通过 appendfsync 参数设置同步的时机 123# appendfsync alwaysappendfsync everysec //默认# appendfsync no //不主动进行同步操作，即交由操作系统处理（每30秒同步一次） 集群同时拥有多个 Redis 服务器后，就会面临如果管理集群的问题，包括如何增加节点，故障恢复等操作。 复制 replication为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上。为此，Redis提供了复制 replication 功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库中。 配置在复制的概念中，数据库分为2种 主数据库（master）：可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库 从数据库 （slave）：一般是只读的（也可以配置为可写入），并接受主数据库同步过来的数据 Redis中，只需要在从数据库配置文件中加入如下配置，即可完成复制操作，主数据库不需要任何配置。 1salveof 主数据库地址 主数据库端口 示例 启动一个Redis实例作为主数据库，默认端口号是6379 1$redis-server //默认端口号是6379 启动另一个Redis实例作为从数据库，监听端口号 6380 1$redis-server --port 6380 --slaveof 127.0.0.1 6379 此时主数据库中任何数据变化，都会自动同步到从数据库中。 打开 redis-cli 实例A并连接到主数据库。再打开 redis-cli 实例B并连接到从数据库 12345$redis-cli -p 6379127.0.0.1:6379&gt;$redis-cli -p 6380127.0.0.1:6380&gt; 使用 INFO replication 命令在实例A和实例B中查看复制相关的信息 123456127.0.0.1:6379&gt; INFO replication# Replicationrole:masterconnected_slaves:1slave0:ip=127.0.0.1,port=6380,state=online,offset=336,lag=1//... 可以看到，实例A的角色是主数据库，其已连接的从数据库的个数是1。 12345127.0.0.1:6380&gt; INFO replication# Replicationrole:slavemaster_host:127.0.0.1master_port:6379 可以看到，实例B的角色是从数据库。 在主数据库中添加键值，可以在从数据库中读取 123# 主数据库写入127.0.0.1:6379&gt; SET foo barOK 123# 从数据库读取127.0.0.1:6380&gt; GET foo"bar" 图结构从数据库不仅可以接受主数据库的同步数据，自己也可以同时作为主数据库存在，形成类似图的结构，如下图所示。 主数据A的数据会同步到B和C，而B中的数据会同步到D和E中。向B中写入的数据不会同步到A或C中。 1234567graph TBA[主数据库A]--&gt;B[从数据库B]A[主数据库A]--&gt;C[从数据库C]B[从数据库B]--&gt;D[从数据库D]B[从数据库B]--&gt;E[从数据库E] 哨兵面临的问题为了提高性能，可以通过复制功能建立若干个从数据库，并在从数据库中启用持久化，同时在主数据中禁用持久化。这样可以保证主数据库的性能。 当从数据库崩溃重启后，主数据库会自动将数据同步过来，所以无需担心数据丢失 当主数据库崩溃后，情况就比较复杂了。手动通过从数据库恢复主数据库数据时，需要严格执行如下2步 在从数据库中使用 SLAVE NO ONE 命令将从数据库提升为主数据库继续服务 启动之前崩溃的主数据库，然后使用 SLAVEOF 命令将其设置成新的主数据库的从数据库，即可将数据同步回来 可见，手动维护主从数据库崩溃后的数据恢复是相当麻烦的。Redis提供了一种自动化方案——哨兵，避免了手工维护的麻烦和容易出错的问题。 哨兵的功能Redis 2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。 哨兵的作用就是监控 Redis 系统的运行状况，它的功能包括2个 监控主数据库和从数据库是否正常工作 主数据库出现故障时自动将从数据库转换为主数据库 哨兵是一个独立的进程，使用哨兵的一个典型架构如下图所示。虚线表示主从复制关系，实线表示哨兵的监控路径。 在一个一主多从的Redis系统中，可以使用多个哨兵进行监控任务以保证系统是足够稳健的，如下图所示。此时不仅哨兵会同时监控主从数据库，哨兵之间也会互相监控。 使用哨兵 创建哨兵配置文件，如 sentinel.conf 123# sentinel monitor master-name ip redis-port quorumsentinel monitor mymaster 127.0.0.1 6379 1 其中，mymaster 是要监控的主数据库的名称，可以自定义一个。后面的参数是数据库的IP地址和端口号。 最后的参数 1 表示最低通过票数（quorum），即执行故障恢复操作前至少需要几个哨兵节点同意。一般情况下，取 quorum 的值为 N/2 + 1，其中 N 表示哨兵数目，即只有超过一半的哨兵同意后才会进行故障恢复。 启动哨兵进程，并将上述配置文件的路径传递给哨兵 1$redis-sentinel /path/to/sentinel.conf 需要注意的是，配置哨兵监控一个系统时，只需要配置其监控主数据库即可，哨兵会自动发现所有复制该主数据库的从数据库。 集群Redis 3.0版本提供了集群（Cluster）特性。集群的特点在于拥有和单机实例同样的性能，同时在网络分区后能够提供一定的可访问性以及对主数据库故障恢复的支持。]]></content>
      <categories>
        <category>Back-End</category>
      </categories>
      <tags>
        <tag>Back-End</tag>
        <tag>DataBase</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Notes-000-Overview]]></title>
    <url>%2F2020%2F01%2F12%2Fleetcode-000-overview%2F</url>
    <content type="text"><![CDATA[记录LeetCode题目笔记，汇总LeetCode解答记录 Changelog 2019/02/13，撰写 2019/06/16，添加 LeetCode Notes-1 2020/01/05，添加 LeetCode Notes-2 2020/02/22，添加 LeetCode Notes-3 学习资料汇总 leetcode leetcode-cn 牛客网 AlgorithmShare @ JD LeetCodeAnimation Leetcode Solution | github 题解记录模板123456789101112131415## XXX（xxx）### Description* [LeetCode-XX. XXX（xxx）]()### Approach 1-XX#### Analysis#### Solution* Java* C++* Python* JS 分类汇总链表 LeetCode-141. Linked List Cycle（环形链表） - 环形链表 LeetCode-142. Linked List Cycle II（环形链表 II） - 环形链表 快慢指针 LeetCode- 141. Linked List Cycle - 环形链表 LeetCode- 142. Linked List Cycle II - 环形链表 数组 LeetCode-463. Island Perimeter（岛屿的周长） - 常规计算 PopCount（汉明距离） LeetCode-191. Number of 1 Bits （位1的个数） LeetCode-338. Counting Bits（比特位计数） 回文串 LeetCode-409. Longest Palindrome （最长回文串） 动态规划 LeetCode-338. Counting Bits（比特位计数） 文档目录Notes-1 LeetCode-141. Linked List Cycle（环形链表） - 环形链表 LeetCode-142. Linked List Cycle II（环形链表 II） - 环形链表 LeetCode-258. Add Digits（各位相加） - 数字推导（数字根） LeetCode-461. Hamming Distance（汉明距离） - 位运算 LeetCode-463. Island Perimeter（岛屿的周长） - 常规计算 Notes-2 LeetCode-206. Reverse Linked List（反转链表） - 链表操作 LeetCode-617. Merge Two Binary Trees - 二叉树 LeetCode-104. Maximum Depth of Binary Tree（二叉树的最大深度） - 遍历二叉树 LeetCode-1290. Convert Binary Number in a Linked List to Integer（二进制链表转整数） LeetCode-709. To Lower Case（转换成小写字母） Notes-3 LeetCode-191. Number of 1 Bits （位1的个数） LeetCode-338. Counting Bits（比特位计数） LeetCode-409. Longest Palindrome （最长回文串） LeetCode-223. Rectangle Area（矩形面积） LeetCode-476. Number Complement（数字的补数）]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native 实现下拉自动切换分类]]></title>
    <url>%2F2019%2F06%2F08%2Frn-tab-auto-change%2F</url>
    <content type="text"><![CDATA[记录 React Native 中如何实现下拉自动切换分类 针对 IOS 和 Android 平台差异，给出不同的切换分类触发条件 需求描述如图所示，整体为 FlatList，顶部分类栏吸顶，底部为 feed 流。要实现下拉商品列表到底后，继续下拉，自动切换到一下个分类的效果。 实现原理代码层面，可以在 FlatList 的 onScrollEndDrag 中添加自动 Tab 切换函数，借助 FlatList 实例的内容区高度 contentLength，滑动偏移量 offset 和可视区高度 visibleLength 三者关系，实现下拉自动切换Tab功能。 代码实现IOS 平台实现1234567891011121314151617181920212223242526272829//页面布局相关 &lt;FlatList data = &#123;[&#123;banner:[]&#125;,&#123;tab:[]&#125;,&#123;goodList:[]&#125;]&#125; renderItem=&#123;this.renderItem&#125; stickyHeaderIndices=&#123;(Platform.OS !== 'web')?[1]:null&#125; ListFooterComponent=&#123;this._renderFooter&#125; onScroll=&#123;this._onScroll&#125; //滑动监听 ref=&#123;this._setScrollRef&#125; keyExtractor = &#123;(item, index) =&gt; &#123; `hScrollView-$&#123;index&#125;` &#125;&#125; refreshing=&#123;this.state.isRefreshing&#125; onRefresh=&#123;this._onRefresh.bind(this)&#125; //下拉刷新 getItemLayout=&#123;(data, index) =&gt; ( &#123;length: 305, offset: 305 * index, index&#125; )&#125; onScrollEndDrag = &#123;()=&gt;&#123; //滑动到底监听函数 if(Platform.OS != 'web')&#123; this._onScrollEndDragFun(); &#125; &#125;&#125;/&gt;/** * 获取flatList 实例 * @param ref * @private */_setScrollRef = (ref) =&gt; &#123; this._secondGoodFlatListRef = ref;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import isEmpty from "lodash/isEmpty";import &#123;Platform&#125; from "react-native";import &#123;JDDevice&#125; from "@jdreact/jdreact-core-lib";/** * 底部列表页滑动事件 实现上拉切换品类功能 * @param e * @private */_onScrollEndDragFun = (e) =&gt; &#123; let scrollMetrics = (this._secondGoodFlatListRef &amp;&amp; this._secondGoodFlatListRef._listRef &amp;&amp; this._secondGoodFlatListRef._listRef._scrollMetrics) || null; let &#123;contentLength = 0, offset = 0, visibleLength = 0&#125; = scrollMetrics; // console.log('===scrollMetrics',scrollMetrics); // //判断是否最后一Tab 如果是就不却换下个目录 // console.log('===this.props',this.props); // console.log('===this.state',this.state); if (contentLength &amp;&amp; offset &amp;&amp; visibleLength) &#123; let &#123;selectedIndex = 0&#125; = this.state; //当前选中的三级分类index let &#123;tabListData = []&#125; = this.props; if (!isEmpty(tabListData) &amp;&amp; (selectedIndex + 1) &lt; tabListData.length) &#123; //排除最后一个分类 let item = tabListData[selectedIndex + 1]; if (Platform.OS === 'ios') &#123; //IOS 系统存在弹性上拉 if (offset + visibleLength &gt; contentLength + JDDevice.getRpx(100)) &#123; this._secondGoodFlatListRef.scrollToIndex(&#123; animated: false, index: 0, viewOffset: 1, viewPosition: 0 &#125;); this.ItemCategory._clickCategoryTab2 &amp;&amp; this.ItemCategory._clickCategoryTab2(item, selectedIndex + 1); &#125; &#125; else &#123; //android 无弹性滑动，滑动到底时，offset + visibleLength = contentLength。IOS有弹性滑动，需要改变判断条件 lbs 2019-03-10 if (offset + visibleLength &gt; contentLength - JDDevice.getRpx(10)) &#123; this._secondGoodFlatListRef.scrollToIndex(&#123; animated: false, index: 0, viewOffset: 1, viewPosition: 0 &#125;); this.ItemCategory._clickCategoryTab2 &amp;&amp; this.ItemCategory._clickCategoryTab2(item, selectedIndex + 1); &#125; &#125; &#125; &#125;&#125;; 其中，contentLength 为内容区高度，offset 为滑动偏移量，visibleLength 为可视区高度。 关于三种高度定义，可参考 React Native中ListView和ScrollView实现上拉加载 12345678let scrollMetrics = (this._secondGoodFlatListRef &amp;&amp; this._secondGoodFlatListRef._listRef &amp;&amp; this._secondGoodFlatListRef._listRef._scrollMetrics) || null;let &#123; contentLength = 0, // 内容区高度 offset = 0, // 滑动偏移量 visibleLength = 0 // 可视区高度&#125; = scrollMetrics; Android 平台实现对于 Android 平台，当 offset + visibleLength = contentLength 时，表示滑动到底部。为了以前进行切换，对条件进行修正，当滑动到距离底部 10px 时，触发切换 Tab 函数，如下代码所示 1234567891011//android 无弹性滑动，滑动到底时，offset + visibleLength = contentLength。IOS有弹性滑动，需要改变判断条件 lbs 2019-03-10if (offset + visibleLength &gt; contentLength - JDDevice.getRpx(10)) &#123; this._secondGoodFlatListRef.scrollToIndex(&#123; animated: false, index: 0, viewOffset: 1, viewPosition: 0 &#125;); //切换Tab this.ItemCategory._clickCategoryTab2 &amp;&amp; this.ItemCategory._clickCategoryTab2(item, selectedIndex + 1);&#125; 对于 IOS 平台，因为 IOS 系统存在弹性上拉，如下图所示。因此对滑动到底条件修正为 offset + visibleLength &gt; contentLength + JDDevice.getRpx(100)。 其中，JDDevice.getRpx(100) 表示弹性上拉的高度，即下图中红色框的高度。 1234567891011if (Platform.OS === 'ios') &#123; if (offset + visibleLength &gt; contentLength + JDDevice.getRpx(100)) &#123; this._secondGoodFlatListRef.scrollToIndex(&#123; animated: false, index: 0, viewOffset: 1, viewPosition: 0 &#125;); this.ItemCategory._clickCategoryTab2 &amp;&amp; this.ItemCategory._clickCategoryTab2(item, selectedIndex + 1); &#125;&#125;]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS模块化——CommonJS AMD CMD ES6 Module]]></title>
    <url>%2F2019%2F03%2F28%2Fjs-module-introduce%2F</url>
    <content type="text"><![CDATA[对 JS 常见的模块化方案进行介绍和比较——CommonJS AMD CMD ES6 Module 对 ES6 Module 和 CommonJS 的差异进行对比，介绍循环依赖和动态 import() 更新日志 2018/05/08，撰写 2019/03/27，内容整理 2019/04/01，动态 import() 和博文发表 参考资料 AMD, CMD, CommonJS和UMD | Segmentfault JS模块化加载之CommonJS、AMD、CMD、ES6 ES6 module的加载和实现 | 阮一峰 前端模块化开发方案小对比 模块化开发优点 模块化开发中，通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数，并且可以按需加载。 依赖自动加载，按需加载。 提高代码复用率，方便进行代码的管理，使得代码管理更加清晰、规范。 减少了命名冲突，消除全局变量。 目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统 常见模块化规范 CommonJs (Node.js) AMD (RequireJS) CMD (SeaJS) CommonJS(Node.js)CommonJS是服务器模块的规范，Node.js采用了这个规范。 根据 CommonJS 规范，一个单独的文件就是一个模块，每一个模块都是一个单独的作用域，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。 CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 CommonJS 中，加载模块使用 require 方法。该方法读取一个文件并执行，最后返回文件内部的 exports 对象。 Node.js 主要用于服务器编程，加载的模块文件一般都已经存在本地硬盘，加载起来较快，不用考虑异步加载的方式，所以 CommonJS 的同步加载模块规范是比较适用的。 但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD，CMD 等解决方案。 1234567891011121314var x = 5;var addX = function(value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX;// 也可以改写为如下module.exports = &#123; x: x, addX: addX,&#125;; 123let math = require('./math.js');console.log('math.x',math.x);console.log('math.addX', math.addX(4)); AMD (RequireJS) 异步模块定义 AMD = Asynchronous Module Definition，即 异步模块定义。 AMD 规范加载模块是异步的，并允许函数回调，不必等到所有模块都加载完成，后续操作可以正常执行。 AMD 中，使用 require 获取依赖模块，使用 exports 导出 API。 123456789101112131415161718192021//规范 APIdefine(id?, dependencies?, factory);define.amd = &#123;&#125;;// 定义无依赖的模块define(&#123; add: function(x,y)&#123; return x + y; &#125;&#125;);// 定义有依赖的模块define(["alpha"], function(alpha)&#123; return &#123; verb: function()&#123; return alpha.verb() + 1; &#125; &#125;&#125;); 异步加载和回调 require([module], callback) 中 callback 为模块加载完成后的回调函数 1234//加载 math模块，完成之后执行回调函数require(['math'], function(math) &#123; math.add(2, 3);&#125;); RequireJSRequireJS 是一个前端模块化管理的工具库，遵循 AMD 规范，RequireJS 是对 AMD 规范的阐述。 RequireJS 基本思想为，通过一个函数来将所有所需的或者所依赖的模块装载进来，然后返回一个新的函数（模块）。后续所有的关于新模块的业务代码都在这个函数内部操作。 RequireJS 要求每个模块均放在独立的文件之中，并使用 define 定义模块，使用 require 方法调用模块。 按照是否有依赖其他模块情况，可以分为 独立模块 和 非独立模块。 独立模块，不依赖其他模块，直接定义 123456789101112define(&#123; method1: function()&#123;&#125;, method2: function()&#123;&#125;&#125;);//等价于define(function() &#123; return &#123; method1: function()&#123;&#125;, method2: function()&#123;&#125; &#125;&#125;); 非独立模块，依赖其他模块 12345678910define([ 'module1', 'module2' ], function(m1, m2) &#123; ...&#125;);//等价于define(function(require) &#123; var m1 = require('module1'); var m2 = require('module2'); ...&#125;); require 方法调用模块 1234require(['foo', 'bar'], function(foo, bar) &#123; foo.func(); bar.func();&#125;); CMD (SeaJS)CMD = Common Module Definition，即 通用模块定义。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 CMD规范和AMD类似，都主要运行于浏览器端，写法上看起来也很类似。主要是区别在于 模块初始化时机 AMD中只要模块作为依赖时，就会加载并初始化 CMD中，模块作为依赖且被引用时才会初始化，否则只会加载。 CMD 推崇依赖就近，AMD 推崇依赖前置。 AMD 的 API 默认是一个当多个用，CMD 严格的区分推崇职责单一。例如，AMD 里 require 分全局的和局部的。CMD里面没有全局的 require，提供 seajs.use() 来实现模块系统的加载启动。CMD 里每个 API 都简单纯粹。 12345678910111213141516171819202122//AMDdefine(['./a','./b'], function (a, b) &#123; //依赖一开始就写好 a.test(); b.test();&#125;); //CMDdefine(function (requie, exports, module) &#123; //依赖可以就近书写 var a = require('./a'); a.test(); ... //软依赖 if (status) &#123; var b = requie('./b'); b.test(); &#125;&#125;); Sea.js Sea.js Github Page SeaJS与RequireJS最大的区别 使用Sea.js，在书写文件时，需要遵守CMD（Common Module Definition）模块定义规范。一个文件就是一个模块。 用法 通过 exports 暴露接口。这意味着不需要命名空间了，更不需要全局变量。这是一种彻底的命名冲突解决方案。 通过 require 引入依赖。这可以让依赖内置，开发者只需关心当前模块的依赖，其他事情 Sea.js 都会自动处理好。对模块开发者来说，这是一种很好的 关注度分离，能让程序员更多地享受编码的乐趣。 通过 define 定义模块，更多详情参考SeasJS | 极客学院。 示例例如，对于下述util.js代码 1234567891011var org = &#123;&#125;;org.CoolSite = &#123;&#125;;org.CoolSite.Utils = &#123;&#125;;org.CoolSite.Utils.each = function (arr) &#123; // 实现代码&#125;;org.CoolSite.Utils.log = function (str) &#123; // 实现代码&#125;; 可以采用SeaJS重写为 12345678910define(function(require, exports) &#123; exports.each = function (arr) &#123; // 实现代码 &#125;; exports.log = function (str) &#123; // 实现代码 &#125;;&#125;); 通过 exports 就可以向外提供接口。通过 require(&#39;./util.js&#39;) 就可以拿到 util.js 中通过 exports 暴露的接口。这里的 require 可以认为是 Sea.js 给 JavaScript 语言增加的一个语法关键字，通过 require 可以获取其他模块提供的接口。 123456define(function(require, exports) &#123; var util = require('./util.js'); exports.init = function() &#123; // 实现代码 &#125;;&#125;); SeaJS与RequireJS区别二者区别主要表现在模块初始化时机 AMD（RequireJS）中只要模块作为依赖时，就会加载并初始化。即尽早地执行（依赖）模块。相当于所有的require都被提前了，而且模块执行的顺序也不一定100%就是require书写顺序。 CMD（SeaJS）中，模块作为依赖且被引用时才会初始化，否则只会加载。即只会在模块真正需要使用的时候才初始化。模块加载的顺序是严格按照require书写的顺序。 从规范上来说，AMD 更加简单且严谨，适用性更广，而在RequireJS强力的推动下，在国外几乎成了事实上的异步模块标准，各大类库也相继支持AMD规范。 但从SeaJS与CMD来说，也做了很多不错东西：1、相对自然的依赖声明风格 2、小而美的内部实现 3、贴心的外围功能设计 4、更好的中文社区支持。 UMD UMD = Universal Module Definition，即通用模块定义。UMD 是AMD 和 CommonJS的糅合。 AMD 模块以浏览器第一的原则发展，异步加载模块。CommonJS 模块以服务器第一原则发展，选择同步加载。它的模块无需包装(unwrapped modules)。这迫使人们又想出另一个更通用的模式 UMD（Universal Module Definition)，实现跨平台的解决方案。 UMD 先判断是否支持 Node.js 的模块（exports）是否存在，存在则使用 Node.js 模块模式。再判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块。 1234567891011121314(function (window, factory) &#123; if (typeof exports === 'object') &#123; module.exports = factory(); &#125; else if (typeof define === 'function' &amp;&amp; define.amd) &#123; define(factory); &#125; else &#123; window.eventUtil = factory(); &#125;&#125;)(this, function () &#123; //module ...&#125;); ES6 模块ES6模块和CommonJS区别 ES6 模块输出的是值的引用，输出接口动态绑定，而 CommonJS 输出的是值的拷贝。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 CommonJS 输出值的拷贝CommonJS 模块输出的是值的拷贝（类比于基本类型和引用类型的赋值操作）。对于基本类型，一旦输出，模块内部的变化影响不到这个值。对于引用类型，效果同引用类型的赋值操作。 12345678910111213141516// lib.jsvar counter = 3;var obj = &#123; name: 'David'&#125;;function changeValue() &#123; counter++; obj.name = 'Peter';&#125;;module.exports = &#123; counter: counter, obj: obj, changeValue: changeValue,&#125;; 123456789101112// main.jsvar mod = require('./lib');console.log(mod.counter); // 3console.log(mod.obj.name); // 'David'mod.changeValue();console.log(mod.counter); // 3console.log(mod.obj.name); // 'Peter'// Orconsole.log(require('./lib').counter); // 3console.log(require('./lib').obj.name); // 'Peter' counter 是基本类型值，模块内部值的变化不影响输出的值变化。 obj 是引用类型值，模块内部值的变化影响输出的值变化。 上述两点区别，类比于基本类型和引用类型的赋值操作。 也可以借助取值函数（getter），将 counter 转为引用类型值，效果如下。 在类的内部，可以使用 get 和 set 关键字，对某个属性设置存执函数和取值函数，拦截该属性的存取行为。 —— class | 阮一峰 1234567891011// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; get counter() &#123; return counter &#125;, incCounter: incCounter,&#125;; 123456// main.jsvar mod = require('./lib');console.log(mod.counter); // 3mod.incCounter();console.log(mod.counter); // 4 ES6 输出值的引用ES6 模块是动态关联模块中的值，输出的是值得引用。原始值变了，import 加载的值也会跟着变。 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析时，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。ES6 模块中，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值。 —— ES6 Module 的加载实现 | 阮一峰 1234567891011// lib.jsexport let counter = 3;export function incCounter() &#123; counter++;&#125;// main.jsimport &#123; counter, incCounter &#125; from './lib';console.log(counter); // 3incCounter();console.log(counter); // 4 CommonJS 运行时加载 ES6静态编译CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 这是因为，CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 ES6 模块是编译时输出接口，因此有如下2个特点 import 命令会被 JS 引擎静态分析，优先于模块内的其他内容执行 export 命令会有变量声明提升的效果 import 优先执行在文件中的任何位置引入 import 模块都会被提前到文件顶部 1234567891011// a.jsconsole.log('a.js')import &#123; foo &#125; from './b';// b.jsexport let foo = 1;console.log('b.js 先执行');// 执行结果:// b.js 先执行// a.js 虽然 a 模块中 import 引入晚于 console.log(&#39;a&#39;)，但是它被 JS 引擎通过静态分析，提到模块执行的最前面，优于模块中的其他部分的执行。 export 命令变量提升效果由于 import 和 export 是静态执行，所以 import 和 export 具有变量提升效果。即 import 和 export 命令在模块中的位置并不影响程序的输出。 12345678910111213141516171819// a.jsimport &#123; foo &#125; from './b';console.log('a.js');export const bar = 1;export const bar2 = () =&gt; &#123; console.log('bar2');&#125;export function bar3() &#123; console.log('bar3');&#125;// b.jsexport let foo = 1;import * as a from './a';console.log(a);// 执行结果:// &#123; bar: undefined, bar2: undefined, bar3: [Function: bar3] &#125;// a.js a 模块引用了 b 模块，b 模块也引用了 a 模块，export 声明的变量也是优于模块其它内容的执行的。但具体对变量赋值需要等到执行到相应代码的时候。 ES6模块和CommonJS相同点模块不会重复执行重复引入某个相同的模块时，模块只会执行一次。 循环依赖CommonJS 模块循环依赖CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被“循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。 Demo 1123456//a.jsexports.done = false;var b = require('./b.js');console.log('在 a.js 之中，b.done = %j', b.done);exports.done = true;console.log('a.js 执行完毕'); 上面代码之中，a.js 脚本先输出一个 done 变量，然后加载另一个脚本文件 b.js。注意，此时 a.js 代码就停在这里，等待 b.js 执行完毕，再往下执行。 再看 b.js 的代码。 123456//b.jsexports.done = false;var a = require('./a.js');console.log('在 b.js 之中，a.done = %j', a.done);exports.done = true;console.log('b.js 执行完毕'); 上面代码之中，b.js 执行到第二行，就会去加载 a.js，这时，就发生了“循环加载”。系统会 a.js 模块对应对象的 exports 属性取值，可是因为 a.js 还没有执行完，从 exports 属性只能取回已经执行的部分，而不是最后的值。 a.js 已经执行的部分，只有一行。 1exports.done = false; 因此，对于 b.js来说，它从 a.js 只输入一个变量 done，值为 false。 然后，b.js 接着往下执行，等到全部执行完毕，再把执行权交还给 a.js。于是，a.js 接着往下执行，直到执行完毕。我们写一个脚本 main.js，验证这个过程。 123var a = require('./a.js');var b = require('./b.js');console.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done); 执行 main.js，运行结果如下。 1234567$ node main.js在 b.js 之中，a.done = falseb.js 执行完毕在 a.js 之中，b.done = truea.js 执行完毕在 main.js 之中, a.done=true, b.done=true 上面的代码证明了2点 在 b.js 之中，a.js 没有执行完毕，只执行了第一行 main.js 执行到第二行时，不会再次执行 b.js，而是输出缓存的 b.js 的执行结果，即它的第四行。 1exports.done = true; 总之，CommonJS 输入的是被输出值的拷贝，不是引用。 另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。 12345678910var a = require('a'); // 安全的写法 导入整体，保证module已经执行完成var foo = require('a').foo; // 危险的写法exports.good = function (arg) &#123; return a.foo('good', arg); // 使用的是 a.foo 的最新值&#125;;exports.bad = function (arg) &#123; return foo('bad', arg); // 使用的是一个部分加载时的值&#125;; 上面代码中，如果发生循环加载，require(&#39;a&#39;).foo 的值很可能后面会被改写，改用 require(&#39;a&#39;) 会更保险一点。 Demo 2123456789101112131415161718192021222324// a.jsconsole.log('a starting');exports.done = false;const b = require('./b');console.log('in a, b.done =', b.done);exports.done = true;console.log('a done');// b.jsconsole.log('b starting');exports.done = false;const a = require('./a');console.log('in b, a.done =', a.done);exports.done = true;console.log('b done');// node a.js// 执行结果：// a starting// b starting// in b, a.done = false// b done// in a, b.done = true// a done 从上面的执行过程中，可以看到，在 CommonJS 规范中，当遇到 require() 语句时，会执行 require 模块中的代码，并缓存执行的结果，当下次再次加载时不会重复执行，而是直接取缓存的结果。正因为此，出现循环依赖时才不会出现无限循环调用的情况。 ES6 模块循环依赖跟 CommonJS 模块一样，ES6 不会再去执行重复加载的模块，又由于 ES6 动态输出绑定的特性，能保证 ES6 在任何时候都能获取其它模块当前的最新值。 动态 import()ES6 模块在编译时就会静态分析，优先于模块内的其他内容执行，所以导致了我们无法写出像下面这样的代码 12345678if(some condition) &#123; import a from './a';&#125;else &#123; import b from './b';&#125;// or import a from (str + 'b'); 因为编译时静态分析，导致了我们无法在条件语句或者拼接字符串模块，因为这些都是需要在运行时才能确定的结果在 ES6 模块是不被允许的，所以 动态引入import() 应运而生。 import() 允许你在运行时动态地引入 ES6 模块，想到这，你可能也想起了 require.ensure 这个语法，但是它们的用途却截然不同的。 require.ensure 的出现是 webpack 的产物，它是因为浏览器需要一种异步的机制可以用来异步加载模块，从而减少初始的加载文件的体积，所以如果在服务端的话， require.ensure 就无用武之地了，因为服务端不存在异步加载模块的情况，模块同步进行加载就可以满足使用场景了。 CommonJS 模块可以在运行时确认模块加载。 而 import() 则不同，它主要是为了解决 ES6 模块无法在运行时确定模块的引用关系，所以需要引入 import()。 先来看下它的用法 动态的 import() 提供一个基于 Promise 的 API 动态的 import() 可以在脚本的任何地方使用 import() 接受字符串文字，可以根据需要构造说明符 12345678910111213141516171819// a.jsconst str = './b';const flag = true;if(flag) &#123; import('./b').then((&#123;foo&#125;) =&gt; &#123; console.log(foo); &#125;)&#125;import(str).then((&#123;foo&#125;) =&gt; &#123; console.log(foo);&#125;)// b.jsexport const foo = 'foo';// babel-node a.js// 执行结果// foo// foo 当然，如果在浏览器端的 import() 的用途就会变得更广泛，比如 按需异步加载模块，那么就和 require.ensure 功能类似了。 因为是基于 Promise 的，所以如果你想要同时加载多个模块的话，可以是 Promise.all 进行并行异步加载。 123456789Promise.all([ import('./a.js'), import('./b.js'), import('./c.js'),]).then(([a, &#123;default: b&#125;, &#123;c&#125;]) =&gt; &#123; console.log('a.js is loaded dynamically'); console.log('b.js is loaded dynamically'); console.log('c.js is loaded dynamically');&#125;); 还有 Promise.race 方法，它检查哪个 Promise 被首先 resolved 或 reject。我们可以使用 import() 来检查哪个 CDN 速度更快： 1234567891011121314151617181920const CDNs = [ &#123; name: 'jQuery.com', url: 'https://code.jquery.com/jquery-3.1.1.min.js' &#125;, &#123; name: 'googleapis.com', url: 'https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js' &#125;];console.log(`------`);console.log(`jQuery is: $&#123;window.jQuery&#125;`);Promise.race([ import(CDNs[0].url).then(()=&gt;console.log(CDNs[0].name, 'loaded')), import(CDNs[1].url).then(()=&gt;console.log(CDNs[1].name, 'loaded'))]).then(()=&gt; &#123; console.log(`jQuery version: $&#123;window.jQuery.fn.jquery&#125;`);&#125;); 当然，如果你觉得这样写还不够优雅，也可以结合 async/await 语法糖来使用。 12345678910async function main() &#123; const myModule = await import('./myModule.js'); const &#123;export1, export2&#125; = await import('./myModule.js'); const [module1, module2, module3] = await Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'), ]);&#125; 动态 import() 为我们提供了以异步方式使用 ES 模块的额外功能。 根据我们的需求动态或有条件地加载它们，这使我们能够更快，更好地创建更多优势应用程序。 webpack中加载3种模块 | 语法Webpack允许使用不同的模块类型，但是底层必须使用同一种实现。所有的模块可以直接在盒外运行。 ES6 模块 1import MyModule from './MyModule.js'; CommonJS(Require) 1var MyModule = require('./MyModule.js'); AMD 12define(['./MyModule.js'], function (MyModule) &#123;&#125;);]]></content>
      <categories>
        <category>Front-End Develop</category>
      </categories>
      <tags>
        <tag>Front-End Developer</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HomePageImage]]></title>
    <url>%2F2018%2F09%2F12%2Fhome-page-img%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo Blog 搭建与配置]]></title>
    <url>%2F2016%2F03%2F10%2Fblog-configure%2F</url>
    <content type="text"><![CDATA[记录 Hexo Blog 的搭建与配置 对 Next 主题进行定制，添加搜索，统计，置顶，加密阅读，自定义CSS等 Changelog 2018/08/23，撰写 2018/09/04，整理 2018/09/25，添加 Font Awesome使用 2019/03/18，添加文章加密阅读 本博客全部配置信息可在 BlogSpace | lbs0912-github 查看 RefHexo 基础使用 使用GitHub和Hexo搭建免费静态Blog 使用Hexo基于GitHub-Pages搭建个人博客（三） Blog 进阶管理 Next Theme 官方配置手册 如何更好地对hexo博客管理 Hexo 博客进阶配置 Hexo搭建的GitHub博客之优化大全 Next Theme 相册配置 搭建Hexo 相册 优质博客参考 Sunmengyuan Blog 羡辙 Blog BYvoid HexoInstall Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds. — Hexo 参考 Hexo官网了解Hexo更多信息。 1234567npm install hexo-cli -gmkdir Blog &amp;&amp; cd Bloghexo init blogcd blognpm installhexo server Hexo生成的目录结构如下 .deploy : 需要部署的文件 node_modules public: 生成的静态网页文件 scaffolds: 模板 source: 博客正文和其他源文件，404，favicon，CNAME _drafts: 草稿 _posts: 文章 themes: 主题 _config.yml: 全局配置文件 package.json 命令行123456789101112131415161718hexo new page archive# 创建分类目录并初始化index.md 等同于 hexo nhexo server # run hexo server 等同于 hexo shexo generate # Generate static files 等同于 hexo ghexo deploy # Deploy to remote sites 等同于 hexo dhexo clean # 清空缓存文件hexo -v # 查看hexo版本hexo help # 查看hexo帮助hexo d -g # 生成部署 组合命令hexo s -g # 生成预览 组合命令hexo s --debug # 本地预览，并开启调试模式 在后续博文发布时，依次执行如下命令 hexo clean: 清空缓存文件 hexo g: 编译产生静态文件 hexo s: 本地预览，可选 hexo d: 部署到服务端 Hexo to GitHub创建GitHub仓库 创建一个仓库，并命名为 YourAccountName.github.io（此处以lbs0912.github.io为例） 设置仓库属性，选择 GitHub Page 的主题，访问 https://lbs0912.github.io/进行预览 同步内容至 GitHub在Hexo安装目录下打开 _config.yml 文件，进行如下修改 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/lbs0912/lbs0912.github.io.git branch: master 该配置文件遵循 Yaml 语法，type: 和 git 中间需有一空格。 对静态网页的标题，子标题，介绍，时区等内容进行如下设置。 12345678910111213141516171819202122# Sitetitle: Liu Baoshuai's Blogsubtitle: Do one thing at a time and do well. description: Record and become better myself.author: Liu Baoshuailanguage: zh-Hanstimezone: Asia/Shanghai# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://lbs0912.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults://...highlight: enable: true line_number: true auto_detect: true tab_replace: 配置文件修改完成后，输入如下命令，将更新后的内容同步至GitHub。 12345npm install hexo-deployer-git --save #deploy to git hexo clean hexo generate # or hexo ghexo deploy # or hexo d 打开 https://lbs0912.github.io/ 可以访问博客界面。 域名和DNS域名申请域名用于博客访问。此处申请域名 liubaoshuai.com。 已申请的域名包括 liubaoshuai.com liubaoshuai.tech 设置CNAME在Hexo的安装目录下的 source 目录下，创建 CNAME 文件，并存入申请的域名 liubaoshuai.com。 DNS推荐使用 DNSPod 进行DNS解析。 此处，由于域名 http://liubaoshuai.com/ 在阿里云购买，故使用阿里云的 DNS 云解析。DNS 界面进行如下设置。 记录类型 主机记录 记录值 CNAME www lbs0912.github.io A @ 192.30.252.154 A @ 192.30.252.153 DNS Update | github 其中A记录为GitHub Page提供的IP地址，可以访问 GitHub Page 查询最新 IP 地址。 最后，执行如下命令，并访问 liubaoshuai.com 查看修改效果。 123hexo clean hexo g # or hexo generatehexo d # or hexo deploy 至此，便可通过访问 liubaoshuai.com 来访问自己的博客。 访问 lbs0912.github.io，会被重定向到 liubaoshuai.com 网址。 Blog 配置 Next Theme 官方配置手册 Plugin安装Hexo插件来增强Hexo效果和美化页面。 123456789101112npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-deployer-git --save #deploy to gitnpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked --savenpm install hexo-renderer-stylus --savenpm install hexo-generator-feed --save # RSSnpm install hexo-generator-sitemap --save #sitemap 添加Meta信息Hexo 默认的文件头只有title、date、tags 属性，生成的 html 缺少 Meta信息，不利于搜索引擎收录。建议自行在文件头中添加 keywords 和 description 属性。categories 属性可自行选择是否添加。 12345678---title: ##文章标题date: ##时间，格式为 YYYY-MM-DD HH:mm:sscategories: ##分类tags: ##标签，多标签格式为 [tag1,tag2,...]keywords: ##文章关键词，多关键词格式为 keyword1,keywords2,...description: ##文章描述--- 文件头模板如上所示，一个文件头实例如下所示。 12345678---title: 这是一篇测试文章date: 2015-03-21 15:13:48categories: Hexotags: [Hexo,测试]keywords: Hexo,文章,测试description: 这是一篇测试文章，用于测试Hexo文章文件头。--- 需要注意的是，多个标签也可采用如下写法 123tags: - Testing Tag - Another Tag 分页功能在 Hexo 安装目录下打开 _config.yml，添加如下配置， 为博客添加分页功能。 12345678910111213# Pluginsindex_generator: path: '' per_page: 8 ##首页默认8篇文章标题，如果值为0不分页 order_by: -datearchive_generator: per_page: 8 ##归档页面默认8篇文章标题，如果值为0不分页 yearly: true ##生成年视图 monthly: true ##生成月视图tag_generator: per_page: 8 ##标签页面默认8篇文章，如果值为0不分页category_generator: per_page: 8 ##分类页面默认8篇文章，如果值为0不分页 Hexo 主题配置访问如下链接，查看 Hexo 主题列表 Hexo Themes List Hexo Themes List on GitHub Next Theme 参考 Next Theme | github 完成基本配置。 Next Theme Configure 参考 Next主题美化进阶 | Segmentfault 进行定制。 Install 12$ cd hexo$ git clone https://github.com/theme-next/hexo-theme-next themes/next 将下载好的 Huno 主题放置在 blog/themes 目录下。修改 Hexo 配置文件_config.xml 1theme: next Update 12$ cd themes/next$ git pull 设置界面个人头像和网页收藏夹图标 1234567# Site favicon#favicon: /favicon.pngfavicon: https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/Blog-20190315/blog-logo-1.jpg# Site logo#logo: /avatar.pnglogo: https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/Blog-20190315/blog-logo-1.jpg 作品设计参考网站 Dribbble Behance Huno Theme参考 Huno Theme | github 完成基本配置。 集成第三方服务 Next Theme 官方配置手册 百度统计 用户名：15821929853 密码：Ab758123aB 百度统计-脚本 ID：17082ee15df20dad9762c5512f336eb2 登陆 百度统计 网站，可以查阅网站访问量 阅读次数统计 LeanCloud leancloud LeanCloud 配置 使用 Github 第三方账登录 leancloud APP ID：gksxcfwJlMV3zkhz1pQc7pl2-gzGzoHsz APP Key：kjOanp812G7TIGMSQpPCVIhj 搜索功能 搜索服务配置 NexT 主题支持集成 Swiftype，微搜索，Local Search 和 Algolia 搜索功能。Swiftype 和 Algolia 均收费，可以采用 Hexo 提供的 Local Search 搜索服务，其原理是通过 hexo-generator-searchdb 插件在本地生成一个 search.xml 文件，搜索的时候从这个文件中根据关键字检索出相应的链接。 博文分享功能 hexo next主题为博客添加分享功能 百度分享 123baidushare: type: button # 需要设置 type: button baidushare: true likely 分享 12345678910111213likely: enable: true look: light # available values: normal, light, small, big networks: twitter: Tweet facebook: Share linkedin: Link #gplus: Plus #vkontakte: Share #odnoklassniki: Class #telegram: Send whatsapp: Send #pinterest: Pin Disqus 评论 使用谷歌账户登录Disqus shortName：liubaoshuaiBlog 之后，在撰写文章时，顶部信息添加 comments 字段可控制是否展示评论 1234567891011---title: Demodate: 2017-03-10 14:35:26categories: Demotags: [LeetCode,Programing,Algorithm]keywords: LeetCodetoc: truepassword: 123456top: 5comments: true--- 404页面 推荐使用 腾讯公益404，当然也可以自定义 404 页面，例如本博客采用的 404 页面。 在 blog/source 目录下创建 404.html，引入腾讯公益404脚本。(该效果需要部署到服务器才能预览，本地服务无法预览) Fork me on GitHub在 Fork me on GitHub Theme 上获取源代码（有多种样式可选），并将 &lt;a&gt; 标签的 href 属性的链接修改为自己的 GitHub-lbs0912 地址。 以 Huno 主题为例，将上述代码添加到 ./themes/huno/layout/_layout.ejs 文件的&lt;body&gt; 标签内即可。 修改源代码中img标签的样式为position:fixed，可以将Fork me on GitHub固定于浏览器界面顶部。 背景音乐播放设置参考 Hexo中播放网易云音乐的实践 完成该部分设置。 以 Huno 主题为例，将网易云音乐播放外链放置在 ./themes/next/layout/_macro/sidebar.swig 文件中。 123&lt;% if (!is_home()) &#123; %&gt; &lt;iframe frameborder="no" border="0" marginwidth="0" style="margin-top: 40px;" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&amp;id=394653&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt;&lt;% &#125; %&gt; 为 Blog 添加 README本博客中，使用了 Github 服务器作为托管，博客内容被存储到 Github 中。 一般情况下，需要给 Github 中每一个项目添加 README.md 文件进行说明。 但是，在 Blog 项目中，在 blog\source 目录下创建的 README.md 文件，会被 hexo 解析掉，并不会被部署到 Github 服务器上。 方式1 在博客 Source 目录下创建 README.md 文件 修改博客配置文件的 skip_render 字段如下 1skip_render: README.md 方式2正确的解决方法如下。 把 README.md 文件的后缀名改成 .MDOWN 仍将该文件置于 blog/source 文件夹 这样可以保证 hexo 不会解析该文件，同时 Github 也会将其作为.MD 文件解析 背景效果优化此处介绍博客背景动态效果图的添加，以及鼠标点击界面出现心形图案的相关设置。 下载 love.js 和 particle.js 文件，将其存放至\themes\huno\source\js\src目录下。 在 \themes\huno\layout\layout.ejs 文件末尾，引入上述 2 个 js 文件。 1234&lt;!-- 背景动画 --&gt;&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt;&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 博文置顶 修改 ./node_modules/hexo-generator-index/lib/generator.js 文件的 1var posts = locals.posts.sort(config.index_generator.order_by); 为 1234567891011121314var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); 设置文章置顶：在文件的头部添加 top 值，top 值越大，文章越靠前。若两篇文章的 top 值一样，则按照默认的日期排序。 12345678---title: Webpack Notes - 1date: 2017-01-19 11:15:48categories: Front-endtags: [Webpack,Front-end]keywords: webpack,front-end top: 5--- 博文收起添加在 .MD 文件中添加如下标识。 1&lt;!--more--&gt; 该标识前的会在博客首页展示（可以在该标识前添加简要说明） 该标识后的博文会被收起折叠。 文章加密阅读 Ref - next主题 - 文章加密阅读 打开 themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig 文件，添加如下代码 1234567891011121314&lt;script&gt; (function () &#123; if ('&#123;&#123; page.password &#125;&#125;') &#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;') &#123; alert('密码错误！'); if (history.length === 1) &#123; location.replace("http://xxxxxxx.xxx"); // 这里替换成你的首页 &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt; 之后，在撰写文章时，顶部信息添加 password 字段即可 1234567891011---title: Demodate: 2017-03-10 14:35:26categories: Demotags: [LeetCode,Programing,Algorithm]keywords: LeetCodetoc: truepassword: 123456top: 5comments: true--- 定制CSS 在 .\themes\next\source\css\_custom\custom.styl 文件中，添加自定义CSS样式。 定制CSS样式后，可以使用如下效果。 1234567891011121314151617181920212223242526272829&lt;span id="inline-blue"&gt;Demo&lt;/span&gt;， &lt;span id="inline-purple"&gt;Demo&lt;/span&gt;&lt;span id="inline-green"&gt;Demo&lt;/span&gt;&lt;span id="inline-yellow"&gt;Demo&lt;/span&gt;&lt;p id="div-border-left-red"&gt;Demo&lt;/p&gt;&lt;p id="div-border-left-yellow"&gt;Demo&lt;/p&gt;&lt;p id="div-border-left-green"&gt;Demo&lt;/p&gt;&lt;p id="div-border-left-blue"&gt;Demo&lt;/p&gt;&lt;p id="div-border-left-purple"&gt;Demo&lt;/p&gt;&lt;p id="div-border-right-red"&gt;Demo&lt;/p&gt;&lt;p id="div-border-right-yellow"&gt;Demo&lt;/p&gt;&lt;p id="div-border-right-green"&gt;Demo&lt;/p&gt;&lt;p id="div-border-right-blue"&gt;Demo&lt;/p&gt;&lt;p id="div-border-right-purple"&gt;Demo&lt;/p&gt;&lt;p id="div-border-top-red"&gt;Demo&lt;/p&gt;&lt;p id="div-border-top-yellow"&gt;Demo&lt;/p&gt;&lt;p id="div-border-top-green"&gt;Demo&lt;/p&gt;&lt;p id="div-border-top-blue"&gt;Demo&lt;/p&gt;&lt;p id="div-border-top-purple"&gt;Demo&lt;/p&gt;&lt;span id="yu-1"&gt;动画&lt;/span&gt;&lt;a id="download" href="https://git-scm.com/download/win"&gt;&lt;i class="fa fa-download"&gt;&lt;/i&gt;&lt;span&gt; Download Now&lt;/span&gt;&lt;/a&gt;&lt;blockquote class="blockquote-center"&gt;引用居中效果&lt;/blockquote&gt; 链接文本样式修改将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。打开themes\next\source\css\_custom\custom.styl 文件 ，添加如下 css 样式 123456789// Custom styles..post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 文字增加背景色块 参考 Hexo博客设置进阶 完成该部分的设置。 使用 inline-blue, inline-purple, inline-yellow,inline-green 可以对文字背景色块进行修改。 12&lt;span id="inline-blue"&gt;站点配置文件&lt;/span&gt;， &lt;span id="inline-purple"&gt;主题配置文件&lt;/span&gt; 图形边框效果参考 Hexo博客设置进阶 完成该部分的设置。 引用边框变色参考Hexo博客设置进阶 引用居中效果1&lt;blockquote class="blockquote-center"&gt;引用居中效果&lt;/blockquote&gt; Font Awesome 使用 Font Awesome 使用 Font Awesome 图标时，只需要使用 CSS 前缀 fa，再加上图标名称即可。 123456789101112131415161718&lt;i class="fa fa-pencil"&gt;&lt;/i&gt; fa-pencil&lt;i class="fa fa-pencil-square-o"&gt;&lt;/i&gt; fa-pencil-square-o&lt;i class="fa fa-camera-retro"&gt;&lt;/i&gt; fa-camera-retro&lt;i class="fa fa-share-square-o"&gt;&lt;/i&gt; fa-share-square-o&lt;i class="fa fa-tag"&gt;&lt;/i&gt; fa-tag&lt;i class="fa fa-video-camera"&gt;&lt;/i&gt; fa-video-camera&lt;i class="fa fa-ban"&gt;&lt;/i&gt; fa-ban&lt;i class="fa fa-code"&gt;&lt;/i&gt; fa-code&lt;i class="fa fa-cloud"&gt;&lt;/i&gt; fa-cloud&lt;i class="fa fa-pie-chart"&gt;&lt;/i&gt; fa-pie-chart&lt;i class="fa fa-thumbs-o-up"&gt;&lt;/i&gt; fa-thumbs-o-up&lt;i class="fa fa-chain"&gt;&lt;/i&gt; fa-chain&lt;i class="fa fa-link"&gt;&lt;/i&gt; fa-link&lt;i class="fa fa-edit"&gt;&lt;/i&gt; fa-edit&lt;i class="fa fa-share-alt"&gt;&lt;/i&gt; fa-share-alt&lt;i class="fa fa-jsfiddle"&gt;&lt;/i&gt; fa-jsfiddle&lt;i class="fa fa-git"&gt;&lt;/i&gt; fa-git&lt;i class="fa fa-codepen"&gt;&lt;/i&gt; fa-codepen 主页图片展示 新建博文，设置 type: &quot;picture&quot;，使用 {\% gp x-x \%} ... {\% endgp \%} 标签引用要展示的图片地址。 12345678910111213141516---title: HomePageImagetype: "picture"top: 999999999999999date: 2018-09-12 16:50:21categories: HomePageImagetags: HomePageImage---&#123;% gp 5-3 %&#125;![my-riding-bike](http://ojxk3q6gs.bkt.clouddn.com/my-riding-bike.jpg)![football](http://ojxk3q6gs.bkt.clouddn.com/football.jpg)![sjtu-title-3](http://ol3kbaay9.bkt.clouddn.com/sjtu-title-3.jpg)![front-end-logo-1](http://ol3kbaay9.bkt.clouddn.com/front-end-logo-1.jpg)![java-c-vs123](http://ol3kbaay9.bkt.clouddn.com/java-c-vs123.jpg)&#123;% endgp %&#125; 图片展示效果 {\% gp 5-3 \%} 用于设置图片展示效果，参考 theme/next/scripts/tags/group-pictures.js 注释示意图。 修复图片展示 博客主页目前可以正常显示上步骤中设置的图片模式效果，但是点击进入后，图片显示效果会丢失，所以需修改themes\next\source\css\_common\components\tags\group-pictures.styl 文件中的以下样式 123456.page-post-detail .post-body .group-picture-column &#123; // float: none; margin-top: 10px; // width: auto !important; img &#123; margin: 0 auto; &#125;&#125; 博文底部标签样式 将博文底部的表情样式，从改为 # 改为 Font Awesome 图标的标签样式。 修改模板 /themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将其中的 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;。 首页-简历和相册分类创建 Create 12hexo new page resume hexo new page album Configure 1234menu: home: / || home resume: /resume/ || child album: /album || picture-o 在简历和相册对应的 index.md 文件头部添加 comments: false 可以关闭评论列表。 简历配置除了用 markdown 书写个人简历外，也可以用 HTML 书写个人简历。此时，需要在文件头部添加不进行渲染指令。 12345678---layout: falsetitle: 个人简历---&lt;!doctype html&gt;&lt;html lang="zh"&gt;&lt;head&gt;&lt;!-- resume code here--&gt; 相册配置参考资料 Next Theme 相册配置 搭建Hexo 相册 Tip 在 album 目录下添加 assets/empty.jpg，作为图片展示的占位图。 本相册配置中是将图片存放在 github的，其访问链接是 https://raw.githubusercontent.com 开头的，并不是图片的存储地址。因此，album/ins.js 中图片链接地址为 123var minSrc = 'https://raw.githubusercontent.com/lbs0912/HexoBlog/master/source/album/photos_configure/min_photos/' + data.link[i];var src = 'https://raw.githubusercontent.com/lbs0912/HexoBlog/master/source/album/photos_configure/photos/' + data.link[i]; 最后 记录，成为更好的自己。 本博客全部配置信息可在 BlogSpace | lbs0912-github 查看。]]></content>
      <categories>
        <category>Front-End Develop</category>
      </categories>
      <tags>
        <tag>Front-End Developer</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
