<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React Native 实现下拉自动切换分类]]></title>
    <url>%2F2019%2F06%2F08%2Frn-tab-auto-change%2F</url>
    <content type="text"><![CDATA[记录 React Native 中如何实现下拉自动切换分类 针对 IOS 和 Android 平台差异，给出不同的切换分类触发条件 需求描述如图所示，整体为 FlatList，顶部分类栏吸顶，底部为 feed 流。要实现下拉商品列表到底后，继续下拉，自动切换到一下个分类的效果。 实现原理代码层面，可以在 FlatList 的 onScrollEndDrag 中添加自动 Tab 切换函数，借助 FlatList 实例的内容区高度 contentLength，滑动偏移量 offset 和可视区高度 visibleLength 三者关系，实现下拉自动切换Tab功能。 代码实现IOS 平台实现1234567891011121314151617181920212223242526272829//页面布局相关 &lt;FlatList data = &#123;[&#123;banner:[]&#125;,&#123;tab:[]&#125;,&#123;goodList:[]&#125;]&#125; renderItem=&#123;this.renderItem&#125; stickyHeaderIndices=&#123;(Platform.OS !== 'web')?[1]:null&#125; ListFooterComponent=&#123;this._renderFooter&#125; onScroll=&#123;this._onScroll&#125; //滑动监听 ref=&#123;this._setScrollRef&#125; keyExtractor = &#123;(item, index) =&gt; &#123; `hScrollView-$&#123;index&#125;` &#125;&#125; refreshing=&#123;this.state.isRefreshing&#125; onRefresh=&#123;this._onRefresh.bind(this)&#125; //下拉刷新 getItemLayout=&#123;(data, index) =&gt; ( &#123;length: 305, offset: 305 * index, index&#125; )&#125; onScrollEndDrag = &#123;()=&gt;&#123; //滑动到底监听函数 if(Platform.OS != 'web')&#123; this._onScrollEndDragFun(); &#125; &#125;&#125;/&gt;/** * 获取flatList 实例 * @param ref * @private */_setScrollRef = (ref) =&gt; &#123; this._secondGoodFlatListRef = ref;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import isEmpty from "lodash/isEmpty";import &#123;Platform&#125; from "react-native";import &#123;JDDevice&#125; from "@jdreact/jdreact-core-lib";/** * 底部列表页滑动事件 实现上拉切换品类功能 * @param e * @private */_onScrollEndDragFun = (e) =&gt; &#123; let scrollMetrics = (this._secondGoodFlatListRef &amp;&amp; this._secondGoodFlatListRef._listRef &amp;&amp; this._secondGoodFlatListRef._listRef._scrollMetrics) || null; let &#123;contentLength = 0, offset = 0, visibleLength = 0&#125; = scrollMetrics; // console.log('===scrollMetrics',scrollMetrics); // //判断是否最后一Tab 如果是就不却换下个目录 // console.log('===this.props',this.props); // console.log('===this.state',this.state); if (contentLength &amp;&amp; offset &amp;&amp; visibleLength) &#123; let &#123;selectedIndex = 0&#125; = this.state; //当前选中的三级分类index let &#123;tabListData = []&#125; = this.props; if (!isEmpty(tabListData) &amp;&amp; (selectedIndex + 1) &lt; tabListData.length) &#123; //排除最后一个分类 let item = tabListData[selectedIndex + 1]; if (Platform.OS === 'ios') &#123; //IOS 系统存在弹性上拉 if (offset + visibleLength &gt; contentLength + JDDevice.getRpx(100)) &#123; this._secondGoodFlatListRef.scrollToIndex(&#123; animated: false, index: 0, viewOffset: 1, viewPosition: 0 &#125;); this.ItemCategory._clickCategoryTab2 &amp;&amp; this.ItemCategory._clickCategoryTab2(item, selectedIndex + 1); &#125; &#125; else &#123; //android 无弹性滑动，滑动到底时，offset + visibleLength = contentLength。IOS有弹性滑动，需要改变判断条件 lbs 2019-03-10 if (offset + visibleLength &gt; contentLength - JDDevice.getRpx(10)) &#123; this._secondGoodFlatListRef.scrollToIndex(&#123; animated: false, index: 0, viewOffset: 1, viewPosition: 0 &#125;); this.ItemCategory._clickCategoryTab2 &amp;&amp; this.ItemCategory._clickCategoryTab2(item, selectedIndex + 1); &#125; &#125; &#125; &#125;&#125;; 其中，contentLength 为内容区高度，offset 为滑动偏移量，visibleLength 为可视区高度。 关于三种高度定义，可参考 React Native中ListView和ScrollView实现上拉加载 12345678let scrollMetrics = (this._secondGoodFlatListRef &amp;&amp; this._secondGoodFlatListRef._listRef &amp;&amp; this._secondGoodFlatListRef._listRef._scrollMetrics) || null;let &#123; contentLength = 0, // 内容区高度 offset = 0, // 滑动偏移量 visibleLength = 0 // 可视区高度&#125; = scrollMetrics; Android 平台实现对于 Android 平台，当 offset + visibleLength = contentLength 时，表示滑动到底部。为了以前进行切换，对条件进行修正，当滑动到距离底部 10px 时，触发切换 Tab 函数，如下代码所示 1234567891011//android 无弹性滑动，滑动到底时，offset + visibleLength = contentLength。IOS有弹性滑动，需要改变判断条件 lbs 2019-03-10if (offset + visibleLength &gt; contentLength - JDDevice.getRpx(10)) &#123; this._secondGoodFlatListRef.scrollToIndex(&#123; animated: false, index: 0, viewOffset: 1, viewPosition: 0 &#125;); //切换Tab this.ItemCategory._clickCategoryTab2 &amp;&amp; this.ItemCategory._clickCategoryTab2(item, selectedIndex + 1);&#125; 对于 IOS 平台，因为 IOS 系统存在弹性上拉，如下图所示。因此对滑动到底条件修正为 offset + visibleLength &gt; contentLength + JDDevice.getRpx(100)。 其中，JDDevice.getRpx(100) 表示弹性上拉的高度，即下图中红色框的高度。 1234567891011if (Platform.OS === 'ios') &#123; if (offset + visibleLength &gt; contentLength + JDDevice.getRpx(100)) &#123; this._secondGoodFlatListRef.scrollToIndex(&#123; animated: false, index: 0, viewOffset: 1, viewPosition: 0 &#125;); this.ItemCategory._clickCategoryTab2 &amp;&amp; this.ItemCategory._clickCategoryTab2(item, selectedIndex + 1); &#125;&#125;]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS模块化——CommonJS AMD CMD ES6 Module]]></title>
    <url>%2F2019%2F03%2F28%2Fjs-module-introduce%2F</url>
    <content type="text"><![CDATA[对 JS 常见的模块化方案进行介绍和比较——CommonJS AMD CMD ES6 Module 对 ES6 Module 和 CommonJS 的差异进行对比，介绍循环依赖和动态 import() 更新日志 2018/05/08，撰写 2019/03/27，内容整理 2019/04/01，动态 import() 和博文发表 参考资料 AMD, CMD, CommonJS和UMD | Segmentfault JS模块化加载之CommonJS、AMD、CMD、ES6 ES6 module的加载和实现 | 阮一峰 前端模块化开发方案小对比 模块化开发优点 模块化开发中，通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数，并且可以按需加载。 依赖自动加载，按需加载。 提高代码复用率，方便进行代码的管理，使得代码管理更加清晰、规范。 减少了命名冲突，消除全局变量。 目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统 常见模块化规范 CommonJs (Node.js) AMD (RequireJS) CMD (SeaJS) CommonJS(Node.js)CommonJS是服务器模块的规范，Node.js采用了这个规范。 根据 CommonJS 规范，一个单独的文件就是一个模块，每一个模块都是一个单独的作用域，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。 CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 CommonJS 中，加载模块使用 require 方法。该方法读取一个文件并执行，最后返回文件内部的 exports 对象。 Node.js 主要用于服务器编程，加载的模块文件一般都已经存在本地硬盘，加载起来较快，不用考虑异步加载的方式，所以 CommonJS 的同步加载模块规范是比较适用的。 但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD，CMD 等解决方案。 1234567891011121314var x = 5;var addX = function(value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX;// 也可以改写为如下module.exports = &#123; x: x, addX: addX,&#125;; 123let math = require('./math.js');console.log('math.x',math.x);console.log('math.addX', math.addX(4)); AMD (RequireJS) 异步模块定义 AMD = Asynchronous Module Definition，即 异步模块定义。 AMD 规范加载模块是异步的，并允许函数回调，不必等到所有模块都加载完成，后续操作可以正常执行。 AMD 中，使用 require 获取依赖模块，使用 exports 导出 API。 123456789101112131415161718192021//规范 APIdefine(id?, dependencies?, factory);define.amd = &#123;&#125;;// 定义无依赖的模块define(&#123; add: function(x,y)&#123; return x + y; &#125;&#125;);// 定义有依赖的模块define(["alpha"], function(alpha)&#123; return &#123; verb: function()&#123; return alpha.verb() + 1; &#125; &#125;&#125;); 异步加载和回调 require([module], callback) 中 callback 为模块加载完成后的回调函数 1234//加载 math模块，完成之后执行回调函数require(['math'], function(math) &#123; math.add(2, 3);&#125;); RequireJSRequireJS 是一个前端模块化管理的工具库，遵循 AMD 规范，RequireJS 是对 AMD 规范的阐述。 RequireJS 基本思想为，通过一个函数来将所有所需的或者所依赖的模块装载进来，然后返回一个新的函数（模块）。后续所有的关于新模块的业务代码都在这个函数内部操作。 RequireJS 要求每个模块均放在独立的文件之中，并使用 define 定义模块，使用 require 方法调用模块。 按照是否有依赖其他模块情况，可以分为 独立模块 和 非独立模块。 独立模块，不依赖其他模块，直接定义 123456789101112define(&#123; method1: function()&#123;&#125;, method2: function()&#123;&#125;&#125;);//等价于define(function() &#123; return &#123; method1: function()&#123;&#125;, method2: function()&#123;&#125; &#125;&#125;); 非独立模块，依赖其他模块 12345678910define([ 'module1', 'module2' ], function(m1, m2) &#123; ...&#125;);//等价于define(function(require) &#123; var m1 = require('module1'); var m2 = require('module2'); ...&#125;); require 方法调用模块 1234require(['foo', 'bar'], function(foo, bar) &#123; foo.func(); bar.func();&#125;); CMD (SeaJS)CMD = Common Module Definition，即 通用模块定义。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 CMD规范和AMD类似，都主要运行于浏览器端，写法上看起来也很类似。主要是区别在于 模块初始化时机 AMD中只要模块作为依赖时，就会加载并初始化 CMD中，模块作为依赖且被引用时才会初始化，否则只会加载。 CMD 推崇依赖就近，AMD 推崇依赖前置。 AMD 的 API 默认是一个当多个用，CMD 严格的区分推崇职责单一。例如，AMD 里 require 分全局的和局部的。CMD里面没有全局的 require，提供 seajs.use() 来实现模块系统的加载启动。CMD 里每个 API 都简单纯粹。 12345678910111213141516171819202122//AMDdefine(['./a','./b'], function (a, b) &#123; //依赖一开始就写好 a.test(); b.test();&#125;); //CMDdefine(function (requie, exports, module) &#123; //依赖可以就近书写 var a = require('./a'); a.test(); ... //软依赖 if (status) &#123; var b = requie('./b'); b.test(); &#125;&#125;); Sea.js Sea.js Github Page SeaJS与RequireJS最大的区别 使用Sea.js，在书写文件时，需要遵守CMD（Common Module Definition）模块定义规范。一个文件就是一个模块。 用法 通过 exports 暴露接口。这意味着不需要命名空间了，更不需要全局变量。这是一种彻底的命名冲突解决方案。 通过 require 引入依赖。这可以让依赖内置，开发者只需关心当前模块的依赖，其他事情 Sea.js 都会自动处理好。对模块开发者来说，这是一种很好的 关注度分离，能让程序员更多地享受编码的乐趣。 通过 define 定义模块，更多详情参考SeasJS | 极客学院。 示例例如，对于下述util.js代码 1234567891011var org = &#123;&#125;;org.CoolSite = &#123;&#125;;org.CoolSite.Utils = &#123;&#125;;org.CoolSite.Utils.each = function (arr) &#123; // 实现代码&#125;;org.CoolSite.Utils.log = function (str) &#123; // 实现代码&#125;; 可以采用SeaJS重写为 12345678910define(function(require, exports) &#123; exports.each = function (arr) &#123; // 实现代码 &#125;; exports.log = function (str) &#123; // 实现代码 &#125;;&#125;); 通过 exports 就可以向外提供接口。通过 require(&#39;./util.js&#39;) 就可以拿到 util.js 中通过 exports 暴露的接口。这里的 require 可以认为是 Sea.js 给 JavaScript 语言增加的一个语法关键字，通过 require 可以获取其他模块提供的接口。 123456define(function(require, exports) &#123; var util = require('./util.js'); exports.init = function() &#123; // 实现代码 &#125;;&#125;); SeaJS与RequireJS区别二者区别主要表现在模块初始化时机 AMD（RequireJS）中只要模块作为依赖时，就会加载并初始化。即尽早地执行（依赖）模块。相当于所有的require都被提前了，而且模块执行的顺序也不一定100%就是require书写顺序。 CMD（SeaJS）中，模块作为依赖且被引用时才会初始化，否则只会加载。即只会在模块真正需要使用的时候才初始化。模块加载的顺序是严格按照require书写的顺序。 从规范上来说，AMD 更加简单且严谨，适用性更广，而在RequireJS强力的推动下，在国外几乎成了事实上的异步模块标准，各大类库也相继支持AMD规范。 但从SeaJS与CMD来说，也做了很多不错东西：1、相对自然的依赖声明风格 2、小而美的内部实现 3、贴心的外围功能设计 4、更好的中文社区支持。 UMD UMD = Universal Module Definition，即通用模块定义。UMD 是AMD 和 CommonJS的糅合。 AMD 模块以浏览器第一的原则发展，异步加载模块。CommonJS 模块以服务器第一原则发展，选择同步加载。它的模块无需包装(unwrapped modules)。这迫使人们又想出另一个更通用的模式 UMD（Universal Module Definition)，实现跨平台的解决方案。 UMD 先判断是否支持 Node.js 的模块（exports）是否存在，存在则使用 Node.js 模块模式。再判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块。 1234567891011121314(function (window, factory) &#123; if (typeof exports === 'object') &#123; module.exports = factory(); &#125; else if (typeof define === 'function' &amp;&amp; define.amd) &#123; define(factory); &#125; else &#123; window.eventUtil = factory(); &#125;&#125;)(this, function () &#123; //module ...&#125;); ES6 模块ES6模块和CommonJS区别 ES6 模块输出的是值的引用，输出接口动态绑定，而 CommonJS 输出的是值的拷贝。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 CommonJS 输出值的拷贝CommonJS 模块输出的是值的拷贝（类比于基本类型和引用类型的赋值操作）。对于基本类型，一旦输出，模块内部的变化影响不到这个值。对于引用类型，效果同引用类型的赋值操作。 12345678910111213141516// lib.jsvar counter = 3;var obj = &#123; name: 'David'&#125;;function changeValue() &#123; counter++; obj.name = 'Peter';&#125;;module.exports = &#123; counter: counter, obj: obj, changeValue: changeValue,&#125;; 123456789101112// main.jsvar mod = require('./lib');console.log(mod.counter); // 3console.log(mod.obj.name); // 'David'mod.changeValue();console.log(mod.counter); // 3console.log(mod.obj.name); // 'Peter'// Orconsole.log(require('./lib').counter); // 3console.log(require('./lib').obj.name); // 'Peter' counter 是基本类型值，模块内部值的变化不影响输出的值变化。 obj 是引用类型值，模块内部值的变化影响输出的值变化。 上述两点区别，类比于基本类型和引用类型的赋值操作。 也可以借助取值函数（getter），将 counter 转为引用类型值，效果如下。 在类的内部，可以使用 get 和 set 关键字，对某个属性设置存执函数和取值函数，拦截该属性的存取行为。 —— class | 阮一峰 1234567891011// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; get counter() &#123; return counter &#125;, incCounter: incCounter,&#125;; 123456// main.jsvar mod = require('./lib');console.log(mod.counter); // 3mod.incCounter();console.log(mod.counter); // 4 ES6 输出值的引用ES6 模块是动态关联模块中的值，输出的是值得引用。原始值变了，import 加载的值也会跟着变。 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析时，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。ES6 模块中，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值。 —— ES6 Module 的加载实现 | 阮一峰 1234567891011// lib.jsexport let counter = 3;export function incCounter() &#123; counter++;&#125;// main.jsimport &#123; counter, incCounter &#125; from './lib';console.log(counter); // 3incCounter();console.log(counter); // 4 CommonJS 运行时加载 ES6静态编译CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 这是因为，CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 ES6 模块是编译时输出接口，因此有如下2个特点 import 命令会被 JS 引擎静态分析，优先于模块内的其他内容执行 export 命令会有变量声明提升的效果 import 优先执行在文件中的任何位置引入 import 模块都会被提前到文件顶部 1234567891011// a.jsconsole.log('a.js')import &#123; foo &#125; from './b';// b.jsexport let foo = 1;console.log('b.js 先执行');// 执行结果:// b.js 先执行// a.js 虽然 a 模块中 import 引入晚于 console.log(&#39;a&#39;)，但是它被 JS 引擎通过静态分析，提到模块执行的最前面，优于模块中的其他部分的执行。 export 命令变量提升效果由于 import 和 export 是静态执行，所以 import 和 export 具有变量提升效果。即 import 和 export 命令在模块中的位置并不影响程序的输出。 12345678910111213141516171819// a.jsimport &#123; foo &#125; from './b';console.log('a.js');export const bar = 1;export const bar2 = () =&gt; &#123; console.log('bar2');&#125;export function bar3() &#123; console.log('bar3');&#125;// b.jsexport let foo = 1;import * as a from './a';console.log(a);// 执行结果:// &#123; bar: undefined, bar2: undefined, bar3: [Function: bar3] &#125;// a.js a 模块引用了 b 模块，b 模块也引用了 a 模块，export 声明的变量也是优于模块其它内容的执行的。但具体对变量赋值需要等到执行到相应代码的时候。 ES6模块和CommonJS相同点模块不会重复执行重复引入某个相同的模块时，模块只会执行一次。 循环依赖CommonJS 模块循环依赖CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被“循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。 Demo 1123456//a.jsexports.done = false;var b = require('./b.js');console.log('在 a.js 之中，b.done = %j', b.done);exports.done = true;console.log('a.js 执行完毕'); 上面代码之中，a.js 脚本先输出一个 done 变量，然后加载另一个脚本文件 b.js。注意，此时 a.js 代码就停在这里，等待 b.js 执行完毕，再往下执行。 再看 b.js 的代码。 123456//b.jsexports.done = false;var a = require('./a.js');console.log('在 b.js 之中，a.done = %j', a.done);exports.done = true;console.log('b.js 执行完毕'); 上面代码之中，b.js 执行到第二行，就会去加载 a.js，这时，就发生了“循环加载”。系统会 a.js 模块对应对象的 exports 属性取值，可是因为 a.js 还没有执行完，从 exports 属性只能取回已经执行的部分，而不是最后的值。 a.js 已经执行的部分，只有一行。 1exports.done = false; 因此，对于 b.js来说，它从 a.js 只输入一个变量 done，值为 false。 然后，b.js 接着往下执行，等到全部执行完毕，再把执行权交还给 a.js。于是，a.js 接着往下执行，直到执行完毕。我们写一个脚本 main.js，验证这个过程。 123var a = require('./a.js');var b = require('./b.js');console.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done); 执行 main.js，运行结果如下。 1234567$ node main.js在 b.js 之中，a.done = falseb.js 执行完毕在 a.js 之中，b.done = truea.js 执行完毕在 main.js 之中, a.done=true, b.done=true 上面的代码证明了2点 在 b.js 之中，a.js 没有执行完毕，只执行了第一行 main.js 执行到第二行时，不会再次执行 b.js，而是输出缓存的 b.js 的执行结果，即它的第四行。 1exports.done = true; 总之，CommonJS 输入的是被输出值的拷贝，不是引用。 另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。 12345678910var a = require('a'); // 安全的写法 导入整体，保证module已经执行完成var foo = require('a').foo; // 危险的写法exports.good = function (arg) &#123; return a.foo('good', arg); // 使用的是 a.foo 的最新值&#125;;exports.bad = function (arg) &#123; return foo('bad', arg); // 使用的是一个部分加载时的值&#125;; 上面代码中，如果发生循环加载，require(&#39;a&#39;).foo 的值很可能后面会被改写，改用 require(&#39;a&#39;) 会更保险一点。 Demo 2123456789101112131415161718192021222324// a.jsconsole.log('a starting');exports.done = false;const b = require('./b');console.log('in a, b.done =', b.done);exports.done = true;console.log('a done');// b.jsconsole.log('b starting');exports.done = false;const a = require('./a');console.log('in b, a.done =', a.done);exports.done = true;console.log('b done');// node a.js// 执行结果：// a starting// b starting// in b, a.done = false// b done// in a, b.done = true// a done 从上面的执行过程中，可以看到，在 CommonJS 规范中，当遇到 require() 语句时，会执行 require 模块中的代码，并缓存执行的结果，当下次再次加载时不会重复执行，而是直接取缓存的结果。正因为此，出现循环依赖时才不会出现无限循环调用的情况。 ES6 模块循环依赖跟 CommonJS 模块一样，ES6 不会再去执行重复加载的模块，又由于 ES6 动态输出绑定的特性，能保证 ES6 在任何时候都能获取其它模块当前的最新值。 动态 import()ES6 模块在编译时就会静态分析，优先于模块内的其他内容执行，所以导致了我们无法写出像下面这样的代码 12345678if(some condition) &#123; import a from './a';&#125;else &#123; import b from './b';&#125;// or import a from (str + 'b'); 因为编译时静态分析，导致了我们无法在条件语句或者拼接字符串模块，因为这些都是需要在运行时才能确定的结果在 ES6 模块是不被允许的，所以 动态引入import() 应运而生。 import() 允许你在运行时动态地引入 ES6 模块，想到这，你可能也想起了 require.ensure 这个语法，但是它们的用途却截然不同的。 require.ensure 的出现是 webpack 的产物，它是因为浏览器需要一种异步的机制可以用来异步加载模块，从而减少初始的加载文件的体积，所以如果在服务端的话， require.ensure 就无用武之地了，因为服务端不存在异步加载模块的情况，模块同步进行加载就可以满足使用场景了。 CommonJS 模块可以在运行时确认模块加载。 而 import() 则不同，它主要是为了解决 ES6 模块无法在运行时确定模块的引用关系，所以需要引入 import()。 先来看下它的用法 动态的 import() 提供一个基于 Promise 的 API 动态的 import() 可以在脚本的任何地方使用 import() 接受字符串文字，可以根据需要构造说明符 12345678910111213141516171819// a.jsconst str = './b';const flag = true;if(flag) &#123; import('./b').then((&#123;foo&#125;) =&gt; &#123; console.log(foo); &#125;)&#125;import(str).then((&#123;foo&#125;) =&gt; &#123; console.log(foo);&#125;)// b.jsexport const foo = 'foo';// babel-node a.js// 执行结果// foo// foo 当然，如果在浏览器端的 import() 的用途就会变得更广泛，比如 按需异步加载模块，那么就和 require.ensure 功能类似了。 因为是基于 Promise 的，所以如果你想要同时加载多个模块的话，可以是 Promise.all 进行并行异步加载。 123456789Promise.all([ import('./a.js'), import('./b.js'), import('./c.js'),]).then(([a, &#123;default: b&#125;, &#123;c&#125;]) =&gt; &#123; console.log('a.js is loaded dynamically'); console.log('b.js is loaded dynamically'); console.log('c.js is loaded dynamically');&#125;); 还有 Promise.race 方法，它检查哪个 Promise 被首先 resolved 或 reject。我们可以使用 import() 来检查哪个 CDN 速度更快： 1234567891011121314151617181920const CDNs = [ &#123; name: 'jQuery.com', url: 'https://code.jquery.com/jquery-3.1.1.min.js' &#125;, &#123; name: 'googleapis.com', url: 'https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js' &#125;];console.log(`------`);console.log(`jQuery is: $&#123;window.jQuery&#125;`);Promise.race([ import(CDNs[0].url).then(()=&gt;console.log(CDNs[0].name, 'loaded')), import(CDNs[1].url).then(()=&gt;console.log(CDNs[1].name, 'loaded'))]).then(()=&gt; &#123; console.log(`jQuery version: $&#123;window.jQuery.fn.jquery&#125;`);&#125;); 当然，如果你觉得这样写还不够优雅，也可以结合 async/await 语法糖来使用。 12345678910async function main() &#123; const myModule = await import('./myModule.js'); const &#123;export1, export2&#125; = await import('./myModule.js'); const [module1, module2, module3] = await Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'), ]);&#125; 动态 import() 为我们提供了以异步方式使用 ES 模块的额外功能。 根据我们的需求动态或有条件地加载它们，这使我们能够更快，更好地创建更多优势应用程序。 webpack中加载3种模块 | 语法Webpack允许使用不同的模块类型，但是底层必须使用同一种实现。所有的模块可以直接在盒外运行。 ES6 模块 1import MyModule from './MyModule.js'; CommonJS(Require) 1var MyModule = require('./MyModule.js'); AMD 12define(['./MyModule.js'], function (MyModule) &#123;&#125;);]]></content>
      <categories>
        <category>Front-End Develop</category>
      </categories>
      <tags>
        <tag>Front-End Developer</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HomePageImage]]></title>
    <url>%2F2018%2F09%2F12%2Fhome-page-img%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo Blog 搭建与配置]]></title>
    <url>%2F2016%2F03%2F10%2Fblog-configure%2F</url>
    <content type="text"><![CDATA[记录 Hexo Blog 的搭建与配置 对 Next 主题进行定制，添加搜索，统计，置顶，加密阅读，自定义CSS等 Changelog 2018/08/23，撰写 2018/09/04，整理 2018/09/25，添加 Font Awesome使用 2019/03/18，添加文章加密阅读 本博客全部配置信息可在 BlogSpace | lbs0912-github 查看 RefHexo 基础使用 使用GitHub和Hexo搭建免费静态Blog 使用Hexo基于GitHub-Pages搭建个人博客（三） Blog 进阶管理 Next Theme 官方配置手册 如何更好地对hexo博客管理 Hexo 博客进阶配置 Hexo搭建的GitHub博客之优化大全 Next Theme 相册配置 搭建Hexo 相册 优质博客参考 Sunmengyuan Blog 羡辙 Blog BYvoid HexoInstall Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds. — Hexo 参考 Hexo官网了解Hexo更多信息。 1234567npm install hexo-cli -gmkdir Blog &amp;&amp; cd Bloghexo init blogcd blognpm installhexo server Hexo生成的目录结构如下 .deploy : 需要部署的文件 node_modules public: 生成的静态网页文件 scaffolds: 模板 source: 博客正文和其他源文件，404，favicon，CNAME _drafts: 草稿 _posts: 文章 themes: 主题 _config.yml: 全局配置文件 package.json 命令行123456789101112131415161718hexo new page archive# 创建分类目录并初始化index.md 等同于 hexo nhexo server # run hexo server 等同于 hexo shexo generate # Generate static files 等同于 hexo ghexo deploy # Deploy to remote sites 等同于 hexo dhexo clean # 清空缓存文件hexo -v # 查看hexo版本hexo help # 查看hexo帮助hexo d -g # 生成部署 组合命令hexo s -g # 生成预览 组合命令hexo s --debug # 本地预览，并开启调试模式 在后续博文发布时，依次执行如下命令 hexo clean: 清空缓存文件 hexo g: 编译产生静态文件 hexo s: 本地预览，可选 hexo d: 部署到服务端 Hexo to GitHub创建GitHub仓库 创建一个仓库，并命名为 YourAccountName.github.io（此处以lbs0912.github.io为例） 设置仓库属性，选择 GitHub Page 的主题，访问 https://lbs0912.github.io/进行预览 同步内容至 GitHub在Hexo安装目录下打开 _config.yml 文件，进行如下修改 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/lbs0912/lbs0912.github.io.git branch: master 该配置文件遵循 Yaml 语法，type: 和 git 中间需有一空格。 对静态网页的标题，子标题，介绍，时区等内容进行如下设置。 12345678910111213141516171819202122# Sitetitle: Liu Baoshuai's Blogsubtitle: Do one thing at a time and do well. description: Record and become better myself.author: Liu Baoshuailanguage: zh-Hanstimezone: Asia/Shanghai# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://lbs0912.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults://...highlight: enable: true line_number: true auto_detect: true tab_replace: 配置文件修改完成后，输入如下命令，将更新后的内容同步至GitHub。 12345npm install hexo-deployer-git --save #deploy to git hexo clean hexo generate # or hexo ghexo deploy # or hexo d 打开 https://lbs0912.github.io/ 可以访问博客界面。 域名和DNS域名申请域名用于博客访问。此处申请域名 liubaoshuai.com。 已申请的域名包括 liubaoshuai.com liubaoshuai.tech 设置CNAME在Hexo的安装目录下的 source 目录下，创建 CNAME 文件，并存入申请的域名 liubaoshuai.com。 DNS推荐使用 DNSPod 进行DNS解析。 此处，由于域名 http://liubaoshuai.com/ 在阿里云购买，故使用阿里云的 DNS 云解析。DNS 界面进行如下设置。 记录类型 主机记录 记录值 CNAME www lbs0912.github.io A @ 192.30.252.154 A @ 192.30.252.153 DNS Update | github 其中A记录为GitHub Page提供的IP地址，可以访问 GitHub Page 查询最新 IP 地址。 最后，执行如下命令，并访问 liubaoshuai.com 查看修改效果。 123hexo clean hexo g # or hexo generatehexo d # or hexo deploy 至此，便可通过访问 liubaoshuai.com 来访问自己的博客。 访问 lbs0912.github.io，会被重定向到 liubaoshuai.com 网址。 Blog 配置 Next Theme 官方配置手册 Plugin安装Hexo插件来增强Hexo效果和美化页面。 123456789101112npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-deployer-git --save #deploy to gitnpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked --savenpm install hexo-renderer-stylus --savenpm install hexo-generator-feed --save # RSSnpm install hexo-generator-sitemap --save #sitemap 添加Meta信息Hexo 默认的文件头只有title、date、tags 属性，生成的 html 缺少 Meta信息，不利于搜索引擎收录。建议自行在文件头中添加 keywords 和 description 属性。categories 属性可自行选择是否添加。 12345678---title: ##文章标题date: ##时间，格式为 YYYY-MM-DD HH:mm:sscategories: ##分类tags: ##标签，多标签格式为 [tag1,tag2,...]keywords: ##文章关键词，多关键词格式为 keyword1,keywords2,...description: ##文章描述--- 文件头模板如上所示，一个文件头实例如下所示。 12345678---title: 这是一篇测试文章date: 2015-03-21 15:13:48categories: Hexotags: [Hexo,测试]keywords: Hexo,文章,测试description: 这是一篇测试文章，用于测试Hexo文章文件头。--- 需要注意的是，多个标签也可采用如下写法 123tags: - Testing Tag - Another Tag 分页功能在 Hexo 安装目录下打开 _config.yml，添加如下配置， 为博客添加分页功能。 12345678910111213# Pluginsindex_generator: path: '' per_page: 8 ##首页默认8篇文章标题，如果值为0不分页 order_by: -datearchive_generator: per_page: 8 ##归档页面默认8篇文章标题，如果值为0不分页 yearly: true ##生成年视图 monthly: true ##生成月视图tag_generator: per_page: 8 ##标签页面默认8篇文章，如果值为0不分页category_generator: per_page: 8 ##分类页面默认8篇文章，如果值为0不分页 Hexo 主题配置访问如下链接，查看 Hexo 主题列表 Hexo Themes List Hexo Themes List on GitHub Next Theme 参考 Next Theme | github 完成基本配置。 Next Theme Configure 参考 Next主题美化进阶 | Segmentfault 进行定制。 Install 12$ cd hexo$ git clone https://github.com/theme-next/hexo-theme-next themes/next 将下载好的 Huno 主题放置在 blog/themes 目录下。修改 Hexo 配置文件_config.xml 1theme: next Update 12$ cd themes/next$ git pull 设置界面个人头像和网页收藏夹图标 1234567# Site favicon#favicon: /favicon.pngfavicon: https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/Blog-20190315/blog-logo-1.jpg# Site logo#logo: /avatar.pnglogo: https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/Blog-20190315/blog-logo-1.jpg 作品设计参考网站 Dribbble Behance Huno Theme参考 Huno Theme | github 完成基本配置。 集成第三方服务 Next Theme 官方配置手册 百度统计 用户名：15821929853 密码：Ab758123aB 百度统计-脚本 ID：17082ee15df20dad9762c5512f336eb2 登陆 百度统计 网站，可以查阅网站访问量 阅读次数统计 LeanCloud leancloud LeanCloud 配置 使用 Github 第三方账登录 leancloud APP ID：gksxcfwJlMV3zkhz1pQc7pl2-gzGzoHsz APP Key：kjOanp812G7TIGMSQpPCVIhj 搜索功能 搜索服务配置 NexT 主题支持集成 Swiftype，微搜索，Local Search 和 Algolia 搜索功能。Swiftype 和 Algolia 均收费，可以采用 Hexo 提供的 Local Search 搜索服务，其原理是通过 hexo-generator-searchdb 插件在本地生成一个 search.xml 文件，搜索的时候从这个文件中根据关键字检索出相应的链接。 博文分享功能 hexo next主题为博客添加分享功能 百度分享 123baidushare: type: button # 需要设置 type: button baidushare: true likely 分享 12345678910111213likely: enable: true look: light # available values: normal, light, small, big networks: twitter: Tweet facebook: Share linkedin: Link #gplus: Plus #vkontakte: Share #odnoklassniki: Class #telegram: Send whatsapp: Send #pinterest: Pin Disqus 评论 使用谷歌账户登录Disqus shortName：liubaoshuaiBlog 之后，在撰写文章时，顶部信息添加 comments 字段可控制是否展示评论 1234567891011---title: Demodate: 2017-03-10 14:35:26categories: Demotags: [LeetCode,Programing,Algorithm]keywords: LeetCodetoc: truepassword: 123456top: 5comments: true--- 404页面 推荐使用 腾讯公益404，当然也可以自定义 404 页面，例如本博客采用的 404 页面。 在 blog/source 目录下创建 404.html，引入腾讯公益404脚本。(该效果需要部署到服务器才能预览，本地服务无法预览) Fork me on GitHub在 Fork me on GitHub Theme 上获取源代码（有多种样式可选），并将 &lt;a&gt; 标签的 href 属性的链接修改为自己的 GitHub-lbs0912 地址。 以 Huno 主题为例，将上述代码添加到 ./themes/huno/layout/_layout.ejs 文件的&lt;body&gt; 标签内即可。 修改源代码中img标签的样式为position:fixed，可以将Fork me on GitHub固定于浏览器界面顶部。 背景音乐播放设置参考 Hexo中播放网易云音乐的实践 完成该部分设置。 以 Huno 主题为例，将网易云音乐播放外链放置在 ./themes/next/layout/_macro/sidebar.swig 文件中。 123&lt;% if (!is_home()) &#123; %&gt; &lt;iframe frameborder="no" border="0" marginwidth="0" style="margin-top: 40px;" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&amp;id=394653&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt;&lt;% &#125; %&gt; 为 Blog 添加 README本博客中，使用了 Github 服务器作为托管，博客内容被存储到 Github 中。 一般情况下，需要给 Github 中每一个项目添加 README.md 文件进行说明。 但是，在 Blog 项目中，在 blog\source 目录下创建的 README.md 文件，会被 hexo 解析掉，并不会被部署到 Github 服务器上。 方式1 在博客 Source 目录下创建 README.md 文件 修改博客配置文件的 skip_render 字段如下 1skip_render: README.md 方式2正确的解决方法如下。 把 README.md 文件的后缀名改成 .MDOWN 仍将该文件置于 blog/source 文件夹 这样可以保证 hexo 不会解析该文件，同时 Github 也会将其作为.MD 文件解析 背景效果优化此处介绍博客背景动态效果图的添加，以及鼠标点击界面出现心形图案的相关设置。 下载 love.js 和 particle.js 文件，将其存放至\themes\huno\source\js\src目录下。 在 \themes\huno\layout\layout.ejs 文件末尾，引入上述 2 个 js 文件。 1234&lt;!-- 背景动画 --&gt;&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt;&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 博文置顶 修改 ./node_modules/hexo-generator-index/lib/generator.js 文件的 1var posts = locals.posts.sort(config.index_generator.order_by); 为 1234567891011121314var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); 设置文章置顶：在文件的头部添加 top 值，top 值越大，文章越靠前。若两篇文章的 top 值一样，则按照默认的日期排序。 12345678---title: Webpack Notes - 1date: 2017-01-19 11:15:48categories: Front-endtags: [Webpack,Front-end]keywords: webpack,front-end top: 5--- 博文收起添加在 .MD 文件中添加如下标识。 1&lt;!--more--&gt; 该标识前的会在博客首页展示（可以在该标识前添加简要说明） 该标识后的博文会被收起折叠。 文章加密阅读 Ref - next主题 - 文章加密阅读 打开 themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig 文件，添加如下代码 1234567891011121314&lt;script&gt; (function () &#123; if ('&#123;&#123; page.password &#125;&#125;') &#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;') &#123; alert('密码错误！'); if (history.length === 1) &#123; location.replace("http://xxxxxxx.xxx"); // 这里替换成你的首页 &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt; 之后，在撰写文章时，顶部信息添加 password 字段即可 1234567891011---title: Demodate: 2017-03-10 14:35:26categories: Demotags: [LeetCode,Programing,Algorithm]keywords: LeetCodetoc: truepassword: 123456top: 5comments: true--- 定制CSS 在 .\themes\next\source\css\_custom\custom.styl 文件中，添加自定义CSS样式。 定制CSS样式后，可以使用如下效果。 1234567891011121314151617181920212223242526272829&lt;span id="inline-blue"&gt;Demo&lt;/span&gt;， &lt;span id="inline-purple"&gt;Demo&lt;/span&gt;&lt;span id="inline-green"&gt;Demo&lt;/span&gt;&lt;span id="inline-yellow"&gt;Demo&lt;/span&gt;&lt;p id="div-border-left-red"&gt;Demo&lt;/p&gt;&lt;p id="div-border-left-yellow"&gt;Demo&lt;/p&gt;&lt;p id="div-border-left-green"&gt;Demo&lt;/p&gt;&lt;p id="div-border-left-blue"&gt;Demo&lt;/p&gt;&lt;p id="div-border-left-purple"&gt;Demo&lt;/p&gt;&lt;p id="div-border-right-red"&gt;Demo&lt;/p&gt;&lt;p id="div-border-right-yellow"&gt;Demo&lt;/p&gt;&lt;p id="div-border-right-green"&gt;Demo&lt;/p&gt;&lt;p id="div-border-right-blue"&gt;Demo&lt;/p&gt;&lt;p id="div-border-right-purple"&gt;Demo&lt;/p&gt;&lt;p id="div-border-top-red"&gt;Demo&lt;/p&gt;&lt;p id="div-border-top-yellow"&gt;Demo&lt;/p&gt;&lt;p id="div-border-top-green"&gt;Demo&lt;/p&gt;&lt;p id="div-border-top-blue"&gt;Demo&lt;/p&gt;&lt;p id="div-border-top-purple"&gt;Demo&lt;/p&gt;&lt;span id="yu-1"&gt;动画&lt;/span&gt;&lt;a id="download" href="https://git-scm.com/download/win"&gt;&lt;i class="fa fa-download"&gt;&lt;/i&gt;&lt;span&gt; Download Now&lt;/span&gt;&lt;/a&gt;&lt;blockquote class="blockquote-center"&gt;引用居中效果&lt;/blockquote&gt; 链接文本样式修改将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。打开themes\next\source\css\_custom\custom.styl 文件 ，添加如下 css 样式 123456789// Custom styles..post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 文字增加背景色块 参考 Hexo博客设置进阶 完成该部分的设置。 使用 inline-blue, inline-purple, inline-yellow,inline-green 可以对文字背景色块进行修改。 12&lt;span id="inline-blue"&gt;站点配置文件&lt;/span&gt;， &lt;span id="inline-purple"&gt;主题配置文件&lt;/span&gt; 图形边框效果参考 Hexo博客设置进阶 完成该部分的设置。 引用边框变色参考Hexo博客设置进阶 引用居中效果1&lt;blockquote class="blockquote-center"&gt;引用居中效果&lt;/blockquote&gt; Font Awesome 使用 Font Awesome 使用 Font Awesome 图标时，只需要使用 CSS 前缀 fa，再加上图标名称即可。 123456789101112131415161718&lt;i class="fa fa-pencil"&gt;&lt;/i&gt; fa-pencil&lt;i class="fa fa-pencil-square-o"&gt;&lt;/i&gt; fa-pencil-square-o&lt;i class="fa fa-camera-retro"&gt;&lt;/i&gt; fa-camera-retro&lt;i class="fa fa-share-square-o"&gt;&lt;/i&gt; fa-share-square-o&lt;i class="fa fa-tag"&gt;&lt;/i&gt; fa-tag&lt;i class="fa fa-video-camera"&gt;&lt;/i&gt; fa-video-camera&lt;i class="fa fa-ban"&gt;&lt;/i&gt; fa-ban&lt;i class="fa fa-code"&gt;&lt;/i&gt; fa-code&lt;i class="fa fa-cloud"&gt;&lt;/i&gt; fa-cloud&lt;i class="fa fa-pie-chart"&gt;&lt;/i&gt; fa-pie-chart&lt;i class="fa fa-thumbs-o-up"&gt;&lt;/i&gt; fa-thumbs-o-up&lt;i class="fa fa-chain"&gt;&lt;/i&gt; fa-chain&lt;i class="fa fa-link"&gt;&lt;/i&gt; fa-link&lt;i class="fa fa-edit"&gt;&lt;/i&gt; fa-edit&lt;i class="fa fa-share-alt"&gt;&lt;/i&gt; fa-share-alt&lt;i class="fa fa-jsfiddle"&gt;&lt;/i&gt; fa-jsfiddle&lt;i class="fa fa-git"&gt;&lt;/i&gt; fa-git&lt;i class="fa fa-codepen"&gt;&lt;/i&gt; fa-codepen 主页图片展示 新建博文，设置 type: &quot;picture&quot;，使用 {\% gp x-x \%} ... {\% endgp \%} 标签引用要展示的图片地址。 12345678910111213141516---title: HomePageImagetype: "picture"top: 999999999999999date: 2018-09-12 16:50:21categories: HomePageImagetags: HomePageImage---&#123;% gp 5-3 %&#125;![my-riding-bike](http://ojxk3q6gs.bkt.clouddn.com/my-riding-bike.jpg)![football](http://ojxk3q6gs.bkt.clouddn.com/football.jpg)![sjtu-title-3](http://ol3kbaay9.bkt.clouddn.com/sjtu-title-3.jpg)![front-end-logo-1](http://ol3kbaay9.bkt.clouddn.com/front-end-logo-1.jpg)![java-c-vs123](http://ol3kbaay9.bkt.clouddn.com/java-c-vs123.jpg)&#123;% endgp %&#125; 图片展示效果 {\% gp 5-3 \%} 用于设置图片展示效果，参考 theme/next/scripts/tags/group-pictures.js 注释示意图。 修复图片展示 博客主页目前可以正常显示上步骤中设置的图片模式效果，但是点击进入后，图片显示效果会丢失，所以需修改themes\next\source\css\_common\components\tags\group-pictures.styl 文件中的以下样式 123456.page-post-detail .post-body .group-picture-column &#123; // float: none; margin-top: 10px; // width: auto !important; img &#123; margin: 0 auto; &#125;&#125; 博文底部标签样式 将博文底部的表情样式，从改为 # 改为 Font Awesome 图标的标签样式。 修改模板 /themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将其中的 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;。 首页-简历和相册分类创建 Create 12hexo new page resume hexo new page album Configure 1234menu: home: / || home resume: /resume/ || child album: /album || picture-o 在简历和相册对应的 index.md 文件头部添加 comments: false 可以关闭评论列表。 简历配置除了用 markdown 书写个人简历外，也可以用 HTML 书写个人简历。此时，需要在文件头部添加不进行渲染指令。 12345678---layout: falsetitle: 个人简历---&lt;!doctype html&gt;&lt;html lang="zh"&gt;&lt;head&gt;&lt;!-- resume code here--&gt; 相册配置参考资料 Next Theme 相册配置 搭建Hexo 相册 Tip 在 album 目录下添加 assets/empty.jpg，作为图片展示的占位图。 本相册配置中是将图片存放在 github的，其访问链接是 https://raw.githubusercontent.com 开头的，并不是图片的存储地址。因此，album/ins.js 中图片链接地址为 123var minSrc = 'https://raw.githubusercontent.com/lbs0912/HexoBlog/master/source/album/photos_configure/min_photos/' + data.link[i];var src = 'https://raw.githubusercontent.com/lbs0912/HexoBlog/master/source/album/photos_configure/photos/' + data.link[i]; 最后 记录，成为更好的自己。 本博客全部配置信息可在 BlogSpace | lbs0912-github 查看。]]></content>
      <categories>
        <category>Front-End Develop</category>
      </categories>
      <tags>
        <tag>Front-End Developer</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
