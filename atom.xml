<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liu Baoshuai&#39;s Blog</title>
  
  <subtitle>Do one thing at a time and do well</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lbs0912.github.io/"/>
  <updated>2020-02-02T02:24:30.498Z</updated>
  <id>https://lbs0912.github.io/</id>
  
  <author>
    <name>Liu Baoshuai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git 进阶使用</title>
    <link href="https://lbs0912.github.io/2020/02/01/git-usage-improve/"/>
    <id>https://lbs0912.github.io/2020/02/01/git-usage-improve/</id>
    <published>2020-02-01T02:23:34.000Z</published>
    <updated>2020-02-02T02:24:30.498Z</updated>
    
    <content type="html"><![CDATA[<ul><li>总结日常开发中的 Git 进阶使用</li><li>记录多 <code>SSH</code> 配置，<code>git reflog</code> 解决 <code>detached-head</code> 代码丢失问题</li><li>总结团队协作下，如何保持 git 提交信息简洁</li></ul><a id="more"></a><h2 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h2><ul><li>2018/07/09，撰写</li><li>2019/03/10，添加多SSH配置</li><li>2019/04/26，添加 <code>git cherry-pick</code></li><li>2019/10/07，添加如何删除git所有历史提交信息</li><li>2019/10/14，添加 <code>git merge --no-ff</code></li><li>2019/12/14，添加 <code>git reflog</code> 使用</li><li>2020/02/01，添加 <em>删除所有历史提交记录</em></li><li>2020/02/01，添加 <em>团队协作下，如何保持 git 提交信息简洁</em></li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="http://gitup.co/" target="_blank" rel="noopener">GitUp</a></li><li><a href="https://www.zhihu.com/question/20070065/answer/480261314" target="_blank" rel="noopener">如何高效使用github</a></li></ul><h2 id="git-reflog-解决提交代码丢失-detached-head"><a href="#git-reflog-解决提交代码丢失-detached-head" class="headerlink" title="git reflog 解决提交代码丢失 detached-head"></a>git reflog 解决提交代码丢失 <code>detached-head</code></h2><p><code>reflog</code> 是 Git 操作的一道安全保障，它能够记录几乎所有本地仓库的改变。包括所有分支 commit 提交，已经删除（其实并未被实际删除）commit 都会被记录。总结而言，只要 HEAD 发生变化，就可以通过 <code>reflog</code> 查看到。</p><h3 id="detached-head-代码丢失找回"><a href="#detached-head-代码丢失找回" class="headerlink" title="detached-head 代码丢失找回"></a><code>detached-head</code> 代码丢失找回</h3><ul><li><a href="https://www.jianshu.com/p/f247a27851fb" target="_blank" rel="noopener">git提交到HEAD detached导致代码丢失</a></li><li><a href="https://stackoverflow.com/questions/4845505/gitx-how-do-i-get-my-detached-head-commits-back-into-master" target="_blank" rel="noopener">StackOverflow - gitx How do I get my ‘Detached HEAD’ commits back into master</a></li></ul><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>日常开发中，切换分支误操作，造成本地代码修改丢失。</p><p>此时，可以借助 <code>git reflog</code> 找回丢失的代码修改。</p><h4 id="丢失产生原因和步骤"><a href="#丢失产生原因和步骤" class="headerlink" title="丢失产生原因和步骤"></a>丢失产生原因和步骤</h4><p>首先在 <code>master</code> 分支上开发，此时线上出现 bug 且回到旧版本的 tag。这时 <code>master</code> 分支上有一部分代码修改但未提交。</p><p>在 <code>master</code> 分支上执行 <code>git status</code>，有未提交的代码，如下图所示</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-reflog-1.png" alt=""></p><p>在 <code>master</code> 分支上执行 <code>git tag</code>查看标签信息，如下图所示</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-reflog-2.png" alt=""></p><p>此时有未提交的代码，然后执行 <code>git checkout v1.0</code></p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-reflog-3.png" alt=""></p><p>这个时候，<strong>提示当前分支为 <code>detached HEAD</code></strong></p><p>然后再执行 <code>git add ./git commit</code> 和 <code>git checkout master</code>，切换回 <code>master</code> 分支。<strong>这个时候发现 <code>detached HEAD</code> 分支不见了，<code>master</code> 分支上未提交的代码也不见了。</strong></p><h4 id="代码找回"><a href="#代码找回" class="headerlink" title="代码找回"></a>代码找回</h4><p>执行 <code>git reflog</code> 查看提交记录</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-reflog-4.png" alt=""></p><p>查找对应提交的 <code>commitId</code> 为 <code>247e11b</code>，然后执行下述命令行，找回丢失的代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="number">247</span>e11b    <span class="comment">//检出对应的提交</span></span><br><span class="line">git checkout -<span class="selector-tag">b</span> diff    <span class="comment">//新建一个新的diff分支</span></span><br><span class="line">git checkout master     <span class="comment">//切换到master分支</span></span><br><span class="line">git merge diff          <span class="comment">//将新建的diff分支合并到master分支</span></span><br></pre></td></tr></table></figure><h2 id="删除所有历史提交记录"><a href="#删除所有历史提交记录" class="headerlink" title="删除所有历史提交记录"></a>删除所有历史提交记录</h2><ul><li><a href="https://stackoverflow.com/questions/13716658/how-to-delete-all-commit-history-in-github" target="_blank" rel="noopener">How to delete all commit history in github | Stackoverflow</a></li></ul><p>此处介绍如何删除所有历史提交记录，形成一个全新的仓库。</p><ul><li>1 - Checkout</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="comment">--orphan new_branch</span></span><br></pre></td></tr></table></figure><ul><li>2 - Add all the files</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> -A</span></span><br><span class="line"></span><br><span class="line">//等效于 git <span class="keyword">add</span><span class="bash"> --all 或 git add .</span></span><br></pre></td></tr></table></figure><blockquote><p> <code>git add</code> 中使用参数 <code>-A</code> 或 <code>--all</code> 表示追踪所有操作，包含新增、修改和删除</p><p> Git 2.0版开始，<code>-A</code> 参数为默认参数，即 <code>git add .</code> 等效于 <code>git add -A</code> 或 <code>git add --all</code></p></blockquote><ul><li>3 - Commit the changes</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -am <span class="string">"commit message"</span></span><br></pre></td></tr></table></figure><ul><li>4 - Delete the branch</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D <span class="keyword">master</span>   <span class="title">//同时删除本地和远程分支</span></span><br></pre></td></tr></table></figure><ul><li>5 - Rename the current branch to master</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-m master</span><br></pre></td></tr></table></figure><ul><li>6 - force update your repository</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> -f <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><p>下面对上述步骤进行说明</p><h3 id="git-checkout-–orphan"><a href="#git-checkout-–orphan" class="headerlink" title="git checkout –orphan"></a>git checkout –orphan</h3><p>如果你的某个分支上积累了无数次的无意义的提交，<code>git log</code> 信息满天飞，那么可以使用 <code>git checkout --orphan &lt;new_branch_name&gt;</code> </p><ul><li>基于当前分支创建一个新的“孤儿(<code>orphan</code>)”的分支，没有任何提交历史，但包含当前分支所有内容</li><li>执行上述命令后，工作区（<code>Workspace</code>）中所有文件均被认为在该操作中新增(<code>git statue</code> 查看状态，所有文件状态均为 <code>new file</code>，如下图所示)，此时执行 <code>git add .</code> 会把所有文件添加到缓存区（<code>Index</code>）</li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-checkout-orphan-1.png" alt=""></p><ul><li>严格意义上说，执行 <code>git checkout --orphan &lt;new_branch_name&gt;</code> 后，创建的并不是一个分支，因为此时 <code>HEAD</code> 指向的引用中没有 <code>commit</code> 值。只有在进行一次提交后，它才算得上真正的分支。</li></ul><blockquote><p><code>orphan</code> 译为“孤儿”，该参数表示创建一个孤立的分支，没有任何提交历史，且与当前分支不存在任何关系（查看提交信息，可发现其为一个孤立的点，如下图所示）</p><p>孤儿（<code>orphan</code>）无父辈信息，同理，创建的分支也不包含任何历史提交信息</p></blockquote><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-delete-all-info-1.png" alt=""></p><h3 id="git-commit-am"><a href="#git-commit-am" class="headerlink" title="git commit -am"></a>git commit -am</h3><ul><li><a href="https://segmentfault.com/q/1010000005900988" target="_blank" rel="noopener">git commit -m 与 git commit -am 的区别</a></li></ul><h3 id="git-branch-m"><a href="#git-branch-m" class="headerlink" title="git branch -m"></a>git branch -m</h3><p>重命名</p><h3 id="git-push-f-origin-master"><a href="#git-push-f-origin-master" class="headerlink" title="git push -f origin master"></a>git push -f origin master</h3><h2 id="git项目协作——保证git信息简洁"><a href="#git项目协作——保证git信息简洁" class="headerlink" title="git项目协作——保证git信息简洁"></a>git项目协作——保证git信息简洁</h2><h3 id="同一分支-git-pull-使用-rebase"><a href="#同一分支-git-pull-使用-rebase" class="headerlink" title="同一分支 git pull 使用 rebase"></a>同一分支 git pull 使用 rebase</h3><p>默认情况下，<code>git pull</code> 使用的是 <code>merge</code> 行为。多人协作开发时，会产生不必要的 <code>merge</code> 提交记录，造成提交链混乱不堪。</p><p>推荐在同一个分支更新代码时，使用 <code>git pull --rebase</code>。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为某个分支单独设置，这里是设置 dev 分支</span></span><br><span class="line">git<span class="built_in"> config </span>branch.dev.rebase <span class="literal">true</span></span><br><span class="line"><span class="comment"># 全局设置，所有的分支 git pull 均使用 --rebase</span></span><br><span class="line">git<span class="built_in"> config </span>--global pull.rebase <span class="literal">true</span></span><br><span class="line">git<span class="built_in"> config </span>--global branch.autoSetupRebase always</span><br></pre></td></tr></table></figure><h3 id="分支合并使用-merge-–no-ff"><a href="#分支合并使用-merge-–no-ff" class="headerlink" title="分支合并使用 merge –no-ff"></a>分支合并使用 merge –no-ff</h3><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><ul><li><code>Fast-Forward</code>：当前分支合并到另一分支时，如果没有冲突要解决，就会直接移动文件指针，并且不会产生合并提交记录。该过程中，存在<code>git</code> 文件指针快速移动， 因此该过程称为 <code>Fast-Forward</code>。</li><li><code>--no-ff</code>(<code>no fast foward</code>)：每一次的合并，都会创建一个新的 <code>commit</code> 记录。使用 <code>--no-ff</code>，可以保持原有分支提交链的完整性，并且当该分支被删除时，提交信息依旧存在。</li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-merge--no--ff-1.png" alt="git-merge--no-ff-1"></p><p>结合上图分析，在 <code>dev</code>（绿色） 分支上检出 <code>feature-1</code> 分支（蓝色），且 <code>dev</code> 分支不进行任何提交</p><ul><li>直接 <code>merge</code>，默认采用 <code>Fast-Forward</code>，两个分支的提交链会合并为一条直线，不利于后期代码审查和维护</li><li>使用 <code>git merge --no-ff feature-1</code> 合并代码，会产生一个新的提交，且两个分支的提交链不会重叠，利于后期代码审查和维护</li></ul><h4 id="merge-默认设置"><a href="#merge-默认设置" class="headerlink" title="merge 默认设置"></a>merge 默认设置</h4><p><code>git merge</code> 默认使用 <code>fast-forward</code>，可以通过如下方式，修改为默认使用 <code>--no-ff</code>。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global merge.commit <span class="literal">no</span></span><br><span class="line">git<span class="built_in"> config </span>--global merge.ff <span class="literal">no</span></span><br></pre></td></tr></table></figure><p>此外，SourceTree 在设置中也可以设置 <code>--no-ff</code>。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-merge--no-ff-2.png" alt="git-merge--no-ff-2"></p><h2 id="IDE中使用Git"><a href="#IDE中使用Git" class="headerlink" title="IDE中使用Git"></a>IDE中使用Git</h2><h3 id="VSCode中使用Git"><a href="#VSCode中使用Git" class="headerlink" title="VSCode中使用Git"></a>VSCode中使用Git</h3><ul><li><a href="https://juejin.im/post/5b00474951882542ba08087a" target="_blank" rel="noopener">VSCode 中使用Git实践</a></li><li>推荐安装 <code>Git Lens</code> 和 <code>Git History</code> 插件</li><li>克隆代码<ul><li><code>Ctrl + Shift + P</code> 打开命令面板，输入 <code>Git</code>，选择 <code>Git Clone</code> 进行克隆代码</li></ul></li><li>查看修改（VSCode会使用不同颜色进行标识）<ul><li>红色箭头 - 标识删除行</li><li>蓝色竖线 - 该处有修改</li><li>绿色箭头 - 该处为新增</li></ul></li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-vscode-usage-1.png?q-sign-algorithm=sha1&q-ak=AKIDnYCjAUImfNuHSSn8nHaihXEkvukPOAGM&q-sign-time=1570451528;1570453328&q-key-time=1570451528;1570453328&q-header-list=&q-url-param-list=&q-signature=b0ec61fae96fb0c37059f2afedbac8e2ad1b2753" alt=""></p><ul><li>提交代码<ul><li><code>Ctrl + Shift + G</code> 打开代码管理器进行操作</li></ul></li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-vscode-usage-2.png?q-sign-algorithm=sha1&q-ak=AKIDnYCjAUImfNuHSSn8nHaihXEkvukPOAGM&q-sign-time=1570453094;1570454894&q-key-time=1570453094;1570454894&q-header-list=&q-url-param-list=&q-signature=63ea253d235cba5fc2d3d5c525e5242d11bba407" alt=""></p><h2 id="git-clone-设置缓存区"><a href="#git-clone-设置缓存区" class="headerlink" title="git clone 设置缓存区"></a>git clone 设置缓存区</h2><p>当工程较大时，使用 <code>git clone</code> 拉取代码，可能会出现 <code>early EOF</code> 的报错或者拉取代码失败。</p><p>这是因为 <code>git clone</code> 本质上是建立一个 HTTP 连接，工程较大时会超过默认设置的缓存大小。</p><p>使用 <code>git config --list</code> 查看 <code>http.postbuffer</code> 的大小，确认是否小于下载的工程大小。</p><p>使用 <code>git config --global http.postbuffer 524288000 //500x1024x1024 设置为500M</code> 可以对缓存区大小进行设置。 </p><h2 id="git-clean"><a href="#git-clean" class="headerlink" title="git clean"></a>git clean</h2><ul><li><code>git clean -n</code> -  查看哪些文件将被 <code>git clean</code> 清除，只是查看，并不会真正执行清除操作</li><li><code>git clean -f</code>  - 删除未跟踪的文件 <code>untracked files</code> </li><li><code>git clean -fd</code> - 连同未跟踪的目录也一起删除  </li><li><code>git clean -fdx</code> - 删除未跟踪的文件和文件目录，并移除被忽略的文件。其中，<code>-x</code> 表示移除被忽略的文件并且 <code>.gitignore</code> 文件中指定的文件和文件夹也会清除或者清除更改</li></ul><h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><ul><li><code>git tag</code>： 显示所有标签</li><li><code>git tag -l &#39;v1.0.*&#39;</code>： 用通配符查看符合筛选条件的标签</li><li><code>git show xxx</code>： 查看标签信息（提交者，邮箱等）</li><li><code>git tag xxx</code>： 创建轻量标签</li><li><code>git tag -a xxx</code>： 创建含有附注的标签</li><li><code>git tag -a xxx -m &#39;xxxx&#39;</code>： 创建含有附注的标签，并附加提交信息（默认标签打到当前Head提交状态）</li><li><code>git tag -a xxx -m &#39;xxxx&#39; \&lt;commitID&gt;</code>： 创建补丁标签，即对之前的提交添加标签</li><li><code>git tag -d xxx</code>： 删除本地标签</li><li><code>git push origin --delete tag &lt;tagname&gt;</code>： 删除远程标签</li></ul><p>需要注意的是，<br>Git 使用的标签有 2 种类型：轻量级的（<code>lightweight</code>）和含附注的（<code>annotated</code>）。 —— <a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">git tag | Doc</a></p><ul><li>轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。</li><li>含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 <code>GNU Privacy Guard</code> (<code>GPG</code>) 来签署或验证。</li></ul><p><strong>一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。</strong></p><h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><ul><li><a href="https://juejin.im/post/5925a2d9a22b9d0058b0fd9b" target="_blank" rel="noopener">Cherry-Pick | 掘金</a></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>cherry</code> 译为樱桃，<code>pick</code> 译挑选。<code>git cherry-pick</code> 即选择某一个分支中的一个或几个提交，合并到其他分支中（选择的提交即所需的樱桃），主要使用场景为</p><ul><li>情况1： 把弄错分支的提交移动到正确的分支上</li><li>情况2： 将其他分支的提交添加到当前分支</li></ul><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>假设工程有个稳定版分支 <code>v2.0</code>，还有个开发版分支 <code>v3.0</code>。开发分支还未彻底完成，不能直接把两个分支合并，这样会导致稳定版本混乱，但是又想增加一个 <code>v3.0</code> 中的功能到 <code>v2.0</code> 中，这里就可以使用 <code>cherry-pick</code> 了。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先在v3.0中查看要合并的commit的commit id</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment">// 假设是 commit f79b0b1ffe445cab6e531260743fa4e08fb4048b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切到v2.0中</span></span><br><span class="line">git checkout v2.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并commit</span></span><br><span class="line">git cherry-pick f79b0b1ffe445cab6e531260743fa4e08fb4048b     </span><br><span class="line">git cherry-pick -x f79b0b1ffe445cab6e531260743fa4e08fb4048b   <span class="comment">//表示保留原提交的作者信息进行提交</span></span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><code>git cherry_pick commitID</code>：将其他分支的 <code>commitID</code> 提交合并到当前分支</li><li><code>git cherry_pick commitID</code>：将其他分支的 <code>commitID</code> 提交合并到当前分支，<code>-x</code> 表示保留原提交的作者信息进行提交</li><li><code>git cherry_pick &lt;start-commit-id&gt;…&lt;end-commit-id&gt;</code>: 该功能在Git 1.7.2 版本后才支持，将一个连续区间范围的提交，合并到到当前分支。提交范围区间左开右闭，即<code>(start, end]</code></li><li><code>git cherry_pick &lt;start-commit-id&gt;^ … &lt;end-commit-id&gt;</code>: 同上，使用 <code>^</code> 表示包含 <code>start-commit-id</code>，即<code>[start, end]</code></li></ul><blockquote><p>JetBranins 系列IDE，内置了git cherry-pick 快捷键（樱桃图标）</p></blockquote><h2 id="git命令行代理设置"><a href="#git命令行代理设置" class="headerlink" title="git命令行代理设置"></a>git命令行代理设置</h2><h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http<span class="selector-class">.proxy</span> <span class="string">'socks5://127.0.0.1:1086'</span></span><br><span class="line">git config --global https<span class="selector-class">.proxy</span> <span class="string">'socks5://127.0.0.1:1086'</span></span><br></pre></td></tr></table></figure><h3 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global --unset http.proxy</span><br><span class="line">git<span class="built_in"> config </span>--global --unset https.proxy</span><br></pre></td></tr></table></figure><h2 id="GitUp"><a href="#GitUp" class="headerlink" title="GitUp"></a>GitUp</h2><blockquote><p>Work quickly, safely, and without headaches.<br>The Git interface you’ve been missing<br>all your life has finally arrived.</p></blockquote><ul><li><a href="http://gitup.co/" target="_blank" rel="noopener">GitUp</a></li><li><a href="http://qinghua.github.io/gitup/" target="_blank" rel="noopener">Tutorial</a></li></ul><h2 id="GitG"><a href="#GitG" class="headerlink" title="GitG"></a>GitG</h2><ul><li><code>gitg</code>是一个git图形化界面。</li><li>安装</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install gitg   <span class="comment">//安装</span></span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitg  <span class="comment">// 在目录终端下输入gitg即可</span></span><br></pre></td></tr></table></figure><h2 id="Git-代码回滚"><a href="#Git-代码回滚" class="headerlink" title="Git 代码回滚"></a>Git 代码回滚</h2><ul><li><a href="https://sunmengyuan.github.io/garden/2017/06/15/git-revert.html?page=2" target="_blank" rel="noopener">谈谈 Git 代码回滚</a></li></ul><h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>某项目，并行开发着n个需求。提测时，各需求的代码被合并到测试分支。不久之后，要求把部分需求代码从测试分支抽离出去。使用下图场景进行描述。并行开发3个需求，分别是<code>feature1</code>，<code>feature2</code>，<code>feature3</code>。测试分支为<code>master</code>。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-1.jpg" alt="git-rollback"></p><p><code>feature2</code>与<code>feature3</code>对同一文件进行修改，故意制造一个冲突。 </p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-2.jpg" alt="git-rollback"></p><p>提测时，各分支代码被合并到测试分支（<code>master</code>）。首先，<code>featuer1</code>分支被合并到测试分支。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-3.jpg" alt="git-rollback"></p><p>之后，<code>featuer2</code>分支也被合并到测试分支。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-4.jpg" alt="git-rollback"></p><p>最后，合并<code>feature3</code>至测试分支。合并时，产生了与<code>feature2</code>代码的冲突。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-5.jpg" alt="git-rollback"></p><p>解决冲突之后，继续将<code>feature3</code>合并至测试分支。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-6.jpg" alt="git-rollback"></p><p>在<code>feature3</code>提测后，在测试分支上继续修复几个bug。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-7.jpg" alt="git-rollback"></p><p>注意，此时<code>feature2</code>虽已提测但并未进入测试，此时的bug修复均是针对 <code>feature1</code>与<code>feature3</code>。</p><p>几天之后，收到通知，<code>feature2</code>的测试无法正常进行，需将代码从测试分支上抽出。</p><h3 id="代码回滚操作"><a href="#代码回滚操作" class="headerlink" title="代码回滚操作"></a>代码回滚操作</h3><h4 id="Step-1-切换分支"><a href="#Step-1-切换分支" class="headerlink" title="Step 1 切换分支"></a>Step 1 切换分支</h4><p>首先，切换到<code>featuer2</code>分支。以防万一，创建<code>feature2-copy</code>分支，对该分支进行备份。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature2   <span class="comment">//切换到feature2分支</span></span><br><span class="line"></span><br><span class="line">git checkout -b feature2-<span class="built_in">copy</span>   <span class="comment">//创建并切换到feature2-copy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第2行代码等同于</span></span><br><span class="line">git branch feature2-<span class="built_in">copy</span>  <span class="comment">//创建feature2-copy分支</span></span><br><span class="line">git checkout feature2-<span class="built_in">copy</span> <span class="comment">//切换到feature2-copy分支</span></span><br></pre></td></tr></table></figure><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-8.jpg" alt="git-rollback"></p><h4 id="Step-2-确定要回滚的提交记录"><a href="#Step-2-确定要回滚的提交记录" class="headerlink" title="Step 2 确定要回滚的提交记录"></a>Step 2 确定要回滚的提交记录</h4><p>使用<code>git log</code>查看<code>feature2-copy</code>分支的提交记录（输入<code>q</code>退出<code>git log</code>环境）。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-9.jpg" alt="git-rollback"></p><p>如图所示，需要回滚最新的3个提交。实际情况中，针对某需求的提交绝不止3个。若是将提交逐一<code>revert</code>，工作量是非常大的。需要考虑将<code>n</code>个<code>commit</code>合并为一个<code>commit</code>，最后一同<code>revert</code>。</p><h4 id="Step-3-git-rebase-合并提交"><a href="#Step-3-git-rebase-合并提交" class="headerlink" title="Step 3 git rebase 合并提交"></a>Step 3 git rebase 合并提交</h4><p>使用<code>git rebase -i</code>来合并<code>commit</code>，传入需要拼接回滚至的提交的<code>hashcode</code>。（此处，将所有回滚的提交合并到需要回滚的<code>commit</code>集合中第一个提交）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hashcode为需要回滚的commit集合中第一个提交</span></span><br><span class="line">git rebase -<span class="selector-tag">i</span> e08ddaf558b9ad84422db5e4b620dcab97623fde</span><br></pre></td></tr></table></figure><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-10.jpg" alt="git-rollback"></p><p>将最近2次提交的<code>command</code>从<code>pick</code>改为<code>s</code>。</p><blockquote><p>在Vim中，</p><ol><li>输入<code>i</code>，进入<code>INSERT</code>模式。</li><li>输入<code>ESC</code>，进入命令行模式。</li><li>输入<code>:wq</code>，保存并退出VIM编辑器。</li></ol></blockquote><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-11.jpg" alt="git-rollback"></p><p>修改后，保存并退出，进入如下对话框。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-12.jpg" alt="git-rollback"></p><p>此时，对最初一次的提交的<code>commit message</code>进行修改。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-13.jpg" alt="git-rollback"></p><p>修改后保存并退出，使用<code>git log</code> 再次查看 <code>feature2-copy</code> 分支的信息。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-14.jpg" alt="git-rollback"></p><p>如上图所示，3次提交被成功合并。</p><h4 id="Step-4-git-revert-撤销提交"><a href="#Step-4-git-revert-撤销提交" class="headerlink" title="Step 4 git revert 撤销提交"></a>Step 4 git revert 撤销提交</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">revert </span>e544464c3de69adef5ca7556001abebaf40b218b</span><br></pre></td></tr></table></figure><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-15.jpg" alt="git-rollback"></p><p>保存并退出，再次查看<code>feature2-copy</code>分支的提交记录。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-16.jpg" alt="git-rollback"></p><h4 id="Step-5-git-cherry-pick"><a href="#Step-5-git-cherry-pick" class="headerlink" title="Step 5 git cherry-pick"></a>Step 5 git cherry-pick</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="keyword">master</span>   <span class="title">//切换到测试分支</span></span><br><span class="line"><span class="title">git</span> cherry-pick b309f7944d2422d8fe647dca61bda518b192628f</span><br></pre></td></tr></table></figure><p>切换到测试分支，并执行 <code>git cherry-pick</code> 命令。至此，成功的将<code>feature2</code>分支从测试分支上抽离。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-17.jpg" alt="git-rollback"></p><h2 id="Git代码管理与团队协作"><a href="#Git代码管理与团队协作" class="headerlink" title="Git代码管理与团队协作"></a>Git代码管理与团队协作</h2><ul><li><a href="https://segmentfault.com/l/1500000015442316/play" target="_blank" rel="noopener">视频教程 | Segmentfault</a></li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-team-usage-3.png" alt="git-team-usage"></p><p>代码最终提交效果如上图所示。</p><ul><li>主分支为<code>master</code>，创建一个<code>develop</code>分支用于开发。</li><li>开发者<code>leo</code>和<code>jack</code>创建自己的分支<code>leo</code>和<code>jack</code>进行开发。开发完成后，将其合并到<code>develop</code>分支上。</li><li>项目进展到需要发布时，从<code>develop</code>分支创建<code>release</code>分支，用于测试。测试通过后，将<code>release</code>分支合并到<code>develop</code>分支和<code>master</code>分支上。</li></ul><h3 id="Demo目录和初始化"><a href="#Demo目录和初始化" class="headerlink" title="Demo目录和初始化"></a>Demo目录和初始化</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span>目录结构</span><br><span class="line">-- c4</span><br><span class="line"><span class="params">---</span>|<span class="params">---</span> origin   <span class="string">//</span>模拟远程仓库  git init <span class="params">--bare</span> 创建</span><br><span class="line"><span class="params">---</span>|<span class="params">---</span> leo    <span class="string">//</span>开发者1  设置user.name = 'leo'</span><br><span class="line"><span class="params">---</span>|<span class="params">---</span> jack    <span class="string">//</span>开发者2  设置user.name = 'jack'</span><br></pre></td></tr></table></figure><blockquote><p><code>git init --bare</code> 用于创建一个“裸仓库”——只含有 <code>.git</code> 目录，不含源文件。详情参考 <a href="https://segmentfault.com/q/1010000004683286" target="_blank" rel="noopener">Ref</a>。</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mkdir</span> <span class="string">c4</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">c4</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">origin </span></span><br><span class="line"><span class="attr">cd</span> <span class="string">origin </span></span><br><span class="line"><span class="attr">git</span> <span class="string">init --bare   //创建一个裸仓库</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cd</span> <span class="string">..</span></span><br><span class="line"></span><br><span class="line"><span class="meta">//克隆远程仓库至两个开发者目录——leo,</span> <span class="string">jack</span></span><br><span class="line"><span class="attr">git</span> <span class="string">clone origin leo</span></span><br><span class="line"><span class="attr">git</span> <span class="string">clone origin jack</span></span><br></pre></td></tr></table></figure><p>为了模拟团队协作，对两个开发者目录，分别设置不同的 <code>user.name</code> 信息。</p><blockquote><p><code>git config --local</code>，使用 <code>--local</code> 参数，只对本地参数进行配置。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> leo</span><br><span class="line">git config --<span class="built_in">local</span> user.name <span class="string">'leo'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> jack</span><br><span class="line">git config --<span class="built_in">local</span> user.name <span class="string">'jack'</span></span><br></pre></td></tr></table></figure><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><h4 id="master-分支初始化"><a href="#master-分支初始化" class="headerlink" title="master 分支初始化"></a>master 分支初始化</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd leo </span><br><span class="line">echo <span class="selector-tag">a</span> = <span class="number">1</span> &gt; leo1<span class="selector-class">.py</span>  <span class="comment">// 将a=1写入leo1.py文件</span></span><br><span class="line">cat leo1<span class="selector-class">.py</span>           <span class="comment">//显示文件的内容</span></span><br><span class="line"></span><br><span class="line">git add . </span><br><span class="line">git commit -m <span class="string">"c4 项目初始化"</span></span><br><span class="line"></span><br><span class="line">git tag <span class="number">0.0</span>.<span class="number">1</span>  <span class="comment">//添加标签 方便管理</span></span><br></pre></td></tr></table></figure><h4 id="创建develop分支"><a href="#创建develop分支" class="headerlink" title="创建develop分支"></a>创建develop分支</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git checkout -<span class="selector-tag">b</span> develop</span><br><span class="line"></span><br><span class="line">echo <span class="selector-tag">b</span> = <span class="number">2</span> &gt; leo1.py</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"建立开发分支并提交"</span></span><br><span class="line"></span><br><span class="line">git push origin develop  <span class="comment">//推送到远程分支</span></span><br><span class="line"></span><br><span class="line">gitg   <span class="comment">// 使用gitg图形化工具查看提交信息</span></span><br></pre></td></tr></table></figure><h4 id="leo进行开发"><a href="#leo进行开发" class="headerlink" title="leo进行开发"></a>leo进行开发</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git checkout -<span class="selector-tag">b</span> leo</span><br><span class="line">echo c=<span class="number">3</span> &gt; leo2.py</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"创建leo分支并开发"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//合并当前开发到dev分支</span></span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff leo  <span class="comment">//合并分支 并保留leo分支信息</span></span><br><span class="line"></span><br><span class="line">gitg  <span class="comment">//查看提交历史树  gui</span></span><br></pre></td></tr></table></figure><blockquote><p><code>git merge --no-ff leo</code>，合并分支，并保留<code>leo</code>分支的信息。关于参数<code>--no-ff</code>的详情，参考 <a href="https://segmentfault.com/q/1010000002477106" target="_blank" rel="noopener">Ref</a>。</p></blockquote><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-team-usage-1.png" alt="git-team-usage"></p><p>最后，将开发分支推送到远程。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> develop</span><br><span class="line"></span><br><span class="line">gitg</span><br></pre></td></tr></table></figure><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-team-usage-2.png" alt="git-team-usage"></p><h4 id="jack进行开发"><a href="#jack进行开发" class="headerlink" title="jack进行开发"></a>jack进行开发</h4><p>首先，从远程拉取最新代码。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git pull origin</span></span><br></pre></td></tr></table></figure><p>之后，jack进行日常开发，流程同leo开发，此处不再赘述。</p><h4 id="release分支测试"><a href="#release分支测试" class="headerlink" title="release分支测试"></a>release分支测试</h4><p>项目进展到需发布时，从<code>develop</code>分支创建<code>release</code>分支，用于测试。测试通过后，将<code>release</code>分支合并到<code>develop</code>分支和<code>master</code>分支上。</p><h2 id="远程多分支代码拉取"><a href="#远程多分支代码拉取" class="headerlink" title="远程多分支代码拉取"></a>远程多分支代码拉取</h2><p>此处记录如何拉取远程所有分支，并建立本地分支追踪远程分支。</p><ul><li>Step 1： <code>clone</code> 远程代码</li><li>Step 2： 在sourcetree中可以看出，远程分支有<code>origin/master</code>，<code>origin/dev</code>和<code>origin/webtest</code>。此时本地分支为<code>dev</code>，并建立了追踪关系。</li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-pull-branches-1.png" alt="git pull branches"></p><ul><li>Step 3： 在对应的远程分支（<code>origin/master</code>）上点击，检出分支，设定本地分支名，并追踪远程分支即可。</li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-pull-branches-2.png" alt="git pull branches"></p><ul><li>Step 4： 最终效果如下图，检出本地分支并追踪远程。</li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-pull-branches-3.png" alt="git pull branches"></p><blockquote><p>Tip</p><p><code>git branch -r</code>： 查看远程分支</p><p><code>git branch -a</code>： 查看所有分支</p><p>Ref: <a href="https://gaohaoyang.github.io/2016/07/07/git-clone-not-master-branch/" target="_blank" rel="noopener">Blog</a></p></blockquote><h2 id="多SSH配置"><a href="#多SSH配置" class="headerlink" title="多SSH配置"></a>多SSH配置</h2><ol><li>取消全局账户和邮箱设置</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--unset --global user.name</span><br><span class="line">git<span class="built_in"> config </span>--unset --global user.email</span><br></pre></td></tr></table></figure><ol start="2"><li>新建SSH key：</li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"liubaoshuai1@jd.com"</span> </span><br><span class="line">Enter <span class="built_in">file</span> <span class="keyword">in</span> which <span class="built_in">to</span> save <span class="keyword">the</span> key (/User/lbs/.ssh/id_rsa): id_rsa_jd  <span class="comment"># 输入文件名</span></span><br></pre></td></tr></table></figure><ol start="3"><li>新密钥添加到 SSH Agent</li></ol><p>默认只读取 <code>id_rsa</code>，为了让 SSH 识别新的私钥，需将其添加到 SSH Agent 中</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-<span class="keyword">add</span><span class="bash"> ~/.ssh/id_rsa_jd</span></span><br></pre></td></tr></table></figure><p>若出现 <code>Could not open a connection to your authentication agent</code> 错误，执行以下命令</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ssh</span>-agent <span class="keyword">bash</span></span><br><span class="line"><span class="keyword">ssh-add </span>~/.ssh/id_rsa_jd</span><br></pre></td></tr></table></figure><ol start="4"><li>修改 <code>config</code> 文件</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim<span class="built_in"> config </span>     # 若没有，可创建  touch config</span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">default</span> <span class="selector-tag">user</span> (lbs1203940926<span class="variable">@163</span>.com)</span><br><span class="line"><span class="selector-tag">Host</span> <span class="selector-tag">github</span><span class="selector-class">.com</span></span><br><span class="line">   <span class="selector-tag">HostName</span> <span class="selector-tag">github</span><span class="selector-class">.com</span></span><br><span class="line">   <span class="selector-tag">User</span> <span class="selector-tag">lbs1203940926</span>@<span class="selector-tag">163</span><span class="selector-class">.com</span></span><br><span class="line">   <span class="selector-tag">PreferredAuthentications</span> <span class="selector-tag">publickey</span></span><br><span class="line">   <span class="selector-tag">IdentityFile</span> /<span class="selector-tag">Users</span>/<span class="selector-tag">lbs</span>/<span class="selector-class">.ssh</span>/<span class="selector-tag">id_rsa</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="selector-tag">jd-gitlab</span>(liubaoshuai1<span class="variable">@jd</span>.com))</span><br><span class="line"><span class="selector-tag">Host</span> <span class="selector-tag">git</span><span class="selector-class">.jd</span><span class="selector-class">.com</span></span><br><span class="line">   <span class="selector-tag">HostName</span> <span class="selector-tag">git</span><span class="selector-class">.jd</span><span class="selector-class">.comm</span></span><br><span class="line">   <span class="selector-tag">User</span> <span class="selector-tag">liubaoshuai1</span>@<span class="selector-tag">jd</span><span class="selector-class">.com</span></span><br><span class="line">   <span class="selector-tag">PreferredAuthentications</span> <span class="selector-tag">publickey</span></span><br><span class="line">   <span class="selector-tag">IdentityFile</span> /<span class="selector-tag">Users</span>/<span class="selector-tag">lbs</span>/<span class="selector-class">.ssh</span>/<span class="selector-tag">id_rs_jd</span></span><br></pre></td></tr></table></figure><ol start="5"><li>拉取JD代码</li></ol><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 测试暂不支持SourceTree中远程拉取，需要终端命令行拉取</span></span><br><span class="line"><span class="meta"># 且暂只支持https协议</span></span><br><span class="line"></span><br><span class="line">git clone http:<span class="comment">//git.jd.com/jdreact/jdreact-jsbundle-jdreactonehourarrive</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># UserName: liubaoshuai</span></span><br><span class="line"><span class="meta"># PassWord: ERP's password</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;总结日常开发中的 Git 进阶使用&lt;/li&gt;
&lt;li&gt;记录多 &lt;code&gt;SSH&lt;/code&gt; 配置，&lt;code&gt;git reflog&lt;/code&gt; 解决 &lt;code&gt;detached-head&lt;/code&gt; 代码丢失问题&lt;/li&gt;
&lt;li&gt;总结团队协作下，如何保持 git 提交信息简洁&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Develop Tools" scheme="https://lbs0912.github.io/categories/Develop-Tools/"/>
    
    
      <category term="Develop Tools" scheme="https://lbs0912.github.io/tags/Develop-Tools/"/>
    
      <category term="Git" scheme="https://lbs0912.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础知识梳理</title>
    <link href="https://lbs0912.github.io/2020/01/31/redis-basic/"/>
    <id>https://lbs0912.github.io/2020/01/31/redis-basic/</id>
    <published>2020-01-31T02:25:26.000Z</published>
    <updated>2020-01-31T08:47:01.210Z</updated>
    
    <content type="html"><![CDATA[<ul><li>对 Redis 基础知识进行梳理，包括Redis的5种数据类型，事务，过期时间，消息通知，优先级队列，管道，数据持久化，复制，哨兵，事务等</li></ul><a id="more"></a><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><ul><li>2020/01/30，撰写</li></ul><h2 id="学习资料汇总"><a href="#学习资料汇总" class="headerlink" title="学习资料汇总"></a>学习资料汇总</h2><ul><li><a href="https://redis.io/" target="_blank" rel="noopener">Redis官网</a></li><li><a href="http://www.redis.cn/" target="_blank" rel="noopener">Redis中文官网</a></li><li><a href="https://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">Redis菜鸟教程</a></li><li><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Redis源码</a> —— 使用C语言开发，源码只有3万多行，降低了用户通过修改Redis源码来提升性能的门槛</li></ul><h2 id="Redis-初识"><a href="#Redis-初识" class="headerlink" title="Redis 初识"></a>Redis 初识</h2><ul><li>Redis = Remote Dictionary Server，远程字典服务器</li><li>Redis 是一个 高性能的 <code>key-value</code> 存储系统，通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和有序集合(sorted sets)等类型。</li><li>Redis 与其他 <code>key - value</code> 缓存产品有以下3个特点<ol><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储</li><li>Redis支持数据的备份，即master-slave模式的数据备份</li></ol></li><li>Redis 性能极高，读取速度是110000次/s，写入的速度是81000次/s。Redis数据库中的所有数据都存储在内存中，内存读写速度远快于磁盘。</li><li>Redis功能丰富，除了用于数据库开发，还可以用于缓存，队列系统等。</li><li>Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li></ul><h2 id="Redis环境配置"><a href="#Redis环境配置" class="headerlink" title="Redis环境配置"></a>Redis环境配置</h2><h3 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h3><ul><li>Mac上，建议使用Homebrew安装Redis</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">brew install redis    <span class="comment">//会默认安装当前最新的稳定版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 此处安装路径为 usr/local/Cellar/redis/5.0.7</span></span><br><span class="line"><span class="comment">//==&gt; Caveats</span></span><br><span class="line"><span class="comment">// To have launchd start redis now and restart at login:</span></span><br><span class="line"><span class="comment">//  brew services start redis</span></span><br><span class="line"><span class="comment">//Or, if you don't want/need a background service you can just run:</span></span><br><span class="line"><span class="comment">//  redis-server /usr/local/etc/redis.conf</span></span><br><span class="line"><span class="comment">//==&gt; Summary</span></span><br><span class="line"><span class="comment">//🍺  /usr/local/Cellar/redis/5.0.7: 13 files, 3.1MB</span></span><br></pre></td></tr></table></figure><ul><li>如果需要后台运行Redis服务，使用命令 <code>brew services start redis</code></li><li>如果不需要后台运行Redis服务，使用命令 <code>redis-server /usr/local/etc/redis.conf</code></li></ul><h3 id="启动-停止Redis"><a href="#启动-停止Redis" class="headerlink" title="启动/停止Redis"></a>启动/停止Redis</h3><p>执行 <code>brew services start redi</code> 命令，第一次启动 Redis 后，在 <code>/usr/local/bin</code> 目录下，会生成如下文件夹</p><table><thead><tr><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td>redis-server</td><td>redis 服务器</td></tr><tr><td>redis-cli</td><td>redis 命令行客户端</td></tr><tr><td>redis-benchmark</td><td>redis 性能测试工具</td></tr><tr><td>redis-check-aof</td><td>AOF 文件修复工具</td></tr><tr><td>redis-check-dump</td><td>RDB 文件检查工具</td></tr><tr><td>redis-sentinel</td><td>Sentinel 服务器</td></tr></tbody></table><ul><li>启动Redis</li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-<span class="keyword">server</span>   <span class="comment">//默认端口号 6379</span></span><br><span class="line"></span><br><span class="line">redis-<span class="keyword">server</span> --port <span class="number">6380</span>  <span class="comment">//指定端口号</span></span><br></pre></td></tr></table></figure><ul><li>停止Redis</li></ul><p>考虑到 Redis 有可能正在将内存中数据同步到硬盘中，强行终止Redis进程可能会导致数据丢失。因此，正确停止Redis的方式应该是向Redis发送 <code>SHUTDOWN</code> 命令，方法为</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli <span class="built_in">SHUTDOWN</span></span><br></pre></td></tr></table></figure><p>当 Redis 收到 <code>SHUTDOWN</code>  命令后，会先断开所有客户端连接，然后根据配置执行数据持久化，最后完成退出。</p><p>Redis 可以妥善处理 <code>SIGTERM</code> 信号，所以使用 <code>kill</code> Redis 进程的 PID，也可以正常结束 Redis，效果和发送 <code>SHUTDOWN</code> 命令一样。</p><h3 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h3><p>Redis 命令用于在 Redis 服务上执行操作。要在 Redis 服务上执行命令需要一个 Redis 客户端。</p><p><code>redis-cli</code> 是Redis自带的基于命令行的Redis客户端，下面介绍如果通过 <code>redis-cli</code> 向 Redis 发送命令。</p><p>通过 <code>redis-cli</code> 向 Redis 发送命令有2种方式</p><ul><li>方式1：将命令作为 <code>redis-cli</code> 的参数执行。例如 <code>redis-cli SHUTDOWN</code></li><li>方式2：执行 <code>redis-cli</code>（不附带任何参数），进入交互模式后，可以自由输入命令</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：将命令作为 redis-cli 的参数执行</span></span><br><span class="line"></span><br><span class="line">redis-cli SHUTDOWN</span><br><span class="line"></span><br><span class="line"><span class="comment">//redis默认服务器地址127.0.0.1，默认端口号6379 </span></span><br><span class="line"><span class="comment">//也可以使用-h指定服务器地址，-p指定端口号</span></span><br><span class="line">redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">//使用PING命令测试客户端和Redis的连接是否正常</span></span><br><span class="line">redis-cli PING  <span class="comment">//返回PONG 表示连接正常</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式2: 执行 redis-cli（不附带任何参数），进入交互模式后，可以自由输入命令</span></span><br><span class="line">lbsMacBook-Pro:~ lbs$ redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; PING</span><br><span class="line">PONG</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h3><p>Redis 是一个字典结构的存储服务器，<strong>一个 Redis 实例</strong>提供了多个用来存储的字典，可以把其中的每个字典都理解成一个独立的数据库。</p><ul><li>每个数据库对外都是一个从0开始的递增数字命名，Redis默认支持16个数据库</li><li>Redis不支持自定义数据库名称，每个数据库都以编号命名</li><li>需要注意的是，一个Redis实例的多个数据库之间并不是完全隔离的，比如 <code>FLUSHALL</code> 命令可以清空一个 Redis 实例中所有数据库中的数据。综上所述，这些数据库更像是一种命名空间，而不适宜存储不同应用程序的数据。比如，可以使用0号数据库存储应用A的生产环境数据，使用1号数据库存储应用A的测试环境数据，而不应该使用1号数据库存储应用B的数据。</li><li><strong>不同的应用，应该使用不同的Redis实例存储数据。</strong> 由于Redis非常轻量，一个空的Redis实例占用的内存只有1MB，所以不用担心多个Redis实例会额外占用很多内存。</li></ul><h2 id="Redis-入门"><a href="#Redis-入门" class="headerlink" title="Redis 入门"></a>Redis 入门</h2><h3 id="命令行基础"><a href="#命令行基础" class="headerlink" title="命令行基础"></a>命令行基础</h3><ol><li>获得符合规则的键名列表</li></ol><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEYS <span class="built_in">pattern</span></span><br></pre></td></tr></table></figure><p><code>pattern</code> 支持 <code>glob</code> 风格通配符格式，具体如下</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>?</td><td>匹配一个字符</td></tr><tr><td>*</td><td>匹配任意个（包括0个）字符</td></tr><tr><td>[]</td><td>匹配括号间的任一字符，可以使用 <code>-</code> 表示一个范围，如 <code>[1-9]</code></td></tr><tr><td>\x</td><td>用于转义字符</td></tr></tbody></table><p>例如，查询当前的所有键名列表</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">set</span> bar <span class="comment">1</span></span><br><span class="line">OK</span><br><span class="line">&gt; KEYS <span class="comment">*</span></span><br><span class="line">1) <span class="string">"bar"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>判断一个键是否存在</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXISTS <span class="built_in">key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回(integer) 1，表示存在</span></span><br><span class="line"><span class="comment">//返回(integer) 0，表示不存在</span></span><br></pre></td></tr></table></figure><ol start="3"><li>删除键</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEL <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回(integer) 1，表示删除成功</span></span><br><span class="line"><span class="comment">//返回(integer) 0，表示删除不成功</span></span><br></pre></td></tr></table></figure><ol start="4"><li>获得键值的数据类型</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TYPE</span> <span class="built_in">key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 string list 等</span></span><br></pre></td></tr></table></figure><h3 id="Redis-5-种数据类型"><a href="#Redis-5-种数据类型" class="headerlink" title="Redis 5 种数据类型"></a>Redis 5 种数据类型</h3><p>Redis 支持5种数据类型</p><ul><li>string（字符串）</li><li>hash（哈希或散列）</li><li>list（列表）</li><li>set（集合）</li><li>zset(sorted set，有序集合)</li></ul><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><ol><li>赋值和取值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">GET</span> <span class="keyword">key</span>   //当键不存在时会返回空结果</span><br></pre></td></tr></table></figure><ol start="2"><li>递增数字</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">INCR key</span></span><br></pre></td></tr></table></figure><p>当要操作的键不存在时，默认键值为0，所以第一次递增后结果为1，如下所示</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; INCR  num</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line">&gt; INCR  num</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">2</span></span><br></pre></td></tr></table></figure><ol start="3"><li>增加指定的整数</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">INCRBY key increment</span></span><br></pre></td></tr></table></figure><ol start="4"><li>减少指定的整数</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DECR <span class="built_in">key</span></span><br><span class="line"></span><br><span class="line">DECRBY <span class="built_in">key</span> increment</span><br></pre></td></tr></table></figure><ol start="5"><li>增加指定浮点数</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">INCRBYFLOAT key  increment</span></span><br></pre></td></tr></table></figure><ol start="6"><li>向尾部追加值</li></ol><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPEND <span class="built_in">key</span>  <span class="built_in">value</span></span><br></pre></td></tr></table></figure><p><code>APPEND</code> 命令中，若键不存在，则将该键的值设为 <code>value</code>，相当于执行了 <code>SET key value</code>。</p><ol start="7"><li>获取字符串长度</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">STRLEN</span> <span class="built_in">key</span></span><br></pre></td></tr></table></figure><p>对于汉字，Redis使用UTF-8编码的中文，如下示例中，“你”和“好”两个字的UTF-8编码的长度都是3，所以返回的字符串长度为6。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">SET</span> key1 你好</span><br><span class="line">OK</span><br><span class="line">&gt; STRLEN <span class="comment">key1</span></span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure><ol start="8"><li>同时获得/设置多个键值</li></ol><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MSET key<span class="number">1</span> <span class="keyword">value</span><span class="number">1</span> key<span class="number">2</span> <span class="keyword">value</span><span class="number">2</span> key<span class="number">3</span> <span class="keyword">value</span><span class="number">3</span></span><br><span class="line"></span><br><span class="line">MGET key<span class="number">1</span> key<span class="number">2</span> key<span class="number">3</span></span><br></pre></td></tr></table></figure><ol start="9"><li>位操作</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GETBIT <span class="built_in">key</span> offset   <span class="comment">//获取一个字符串类型键指定位置的二进制位的值（0或1）</span></span><br><span class="line"> </span><br><span class="line">SETBIT <span class="built_in">key</span> offset value  <span class="comment">//设置指定位置的二进制位的值</span></span><br><span class="line"></span><br><span class="line">BITCOUNT <span class="built_in">key</span> [start] [<span class="keyword">end</span>] <span class="comment">//获得字符串类型键中值是1的二进制位个数</span></span><br><span class="line"></span><br><span class="line">BITOP operation destkey <span class="built_in">key</span> [<span class="built_in">key</span> ...] <span class="comment">//对多个字符串类型键进行位运算，结果存储在destkey</span></span><br></pre></td></tr></table></figure><p>一个字节由8个二进制位组成。Redis 提供了 4 个命令可以直接对二进制位操作。</p><p>下面进行示例分析。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> foo <span class="comment">bar</span></span><br></pre></td></tr></table></figure><p>“bar”的3个字母对应的ASCII码分别是98，97，114，转换为对应的二进制数值，<code>foo</code> 键中的二进制位结构为<code>01100010,01100001,01110010</code>。</p><p>(1) 使用 <code>GETBIT key offset</code> 获取一个字符串类型键指定位置的二进制位的值（0或1）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GETBIT foo <span class="number">6</span></span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果获取的二进制位的索引超出了键值的二进制位的实际长度，则默认返回 0</p><p>(2) <code>BITOP operation destkey key [key ...]</code> 可以对多个字符串类型键进行位运算，结果存储在 <code>destkey</code></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SET foo1 bar</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SET foo2 aar</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; BITOP OR res foo1 foo2  <span class="comment">//或运算</span></span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; GET res</span><br><span class="line"><span class="string">"car"</span></span><br></pre></td></tr></table></figure><h4 id="哈希（散列）类型"><a href="#哈希（散列）类型" class="headerlink" title="哈希（散列）类型"></a>哈希（散列）类型</h4><p>哈希（或散列）<code>hash</code> 类型的键值也是一种字典结构，其存储了字段（<code>field</code>）和字段值的映射，但字段值只能是字符串，不支持其他数据类型。</p><ol><li>赋值和取值</li></ol><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HSET <span class="built_in">key</span> field <span class="built_in">value</span>  <span class="comment">//不区分插入和更新操作，即更新数据时不用事先判断是否存在 </span></span><br><span class="line">HGET <span class="built_in">key</span> field</span><br><span class="line"></span><br><span class="line">HMSET <span class="built_in">key</span> field <span class="built_in">value</span> [field <span class="built_in">value</span> ...]</span><br><span class="line">HMGET <span class="built_in">key</span> field [field ...]</span><br><span class="line"></span><br><span class="line">HGETALL <span class="built_in">key</span></span><br></pre></td></tr></table></figure><ol start="2"><li>判断字段是否存在</li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">HEXISTS</span> key <span class="meta">field</span></span><br></pre></td></tr></table></figure><ol start="3"><li>仅仅在字段不存在是赋值</li></ol><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSETNX <span class="built_in">key</span> field <span class="built_in">value</span></span><br></pre></td></tr></table></figure><p><code>HSETNX</code> 和 <code>HSET</code> 命令类似，区别在于如果字段已经存在，<code>HSETNX</code> 命令将不执行任何操作。</p><p><code>HSETNX</code> 中的 <code>NX</code> 表示 <code>if Not eXists</code>。</p><ol start="4"><li>增加数字</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HINCRBY key filed increment</span></span><br></pre></td></tr></table></figure><ol start="5"><li>删除字段</li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">HDEL</span> key <span class="meta">field</span> [<span class="meta">field</span> ...]</span><br></pre></td></tr></table></figure><ol start="6"><li>只获取字段名称或字段值</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HKEYS <span class="built_in">key</span></span><br><span class="line"></span><br><span class="line">HVALS <span class="built_in">key</span></span><br></pre></td></tr></table></figure><ol start="7"><li>获得字段数量</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HLEN key</span></span><br></pre></td></tr></table></figure><h4 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h4><p>列表（<code>list</code>）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获取列表的某一个片段。</p><p>列表类型内部使用的是双向链表实现的，所以想列表两端添加元素的时间复杂度是 <code>O(1)</code>，获取越接近两端的元素速度就越快，但是通过索引访问元素会比较慢。因此，针对双向链表的特点，列表类型特别适合如下场景</p><ul><li>如社交网站的新鲜事，我们只关心最新内容，即使新鲜事达到几千万条，获取列表尾部的100条最新数据也是很快的</li><li>如日志记录场景，双向链表保证了插入新日志的速度不会受到已有日志数量的影响</li><li>借助列表类型，Redis还可以作为队列使用</li></ul><ol><li>向列表两端增加元素</li></ol><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSH <span class="built_in">key</span> <span class="built_in">value</span> [<span class="built_in">value</span> ...]   <span class="comment">//向列表左边插入元素</span></span><br><span class="line">RPUSH <span class="built_in">key</span> <span class="built_in">value</span> [<span class="built_in">value</span> ...]</span><br></pre></td></tr></table></figure><ol start="2"><li>从列表两端弹出元素</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPOP <span class="built_in">key</span> </span><br><span class="line">RPOP <span class="built_in">key</span></span><br></pre></td></tr></table></figure><ol start="3"><li>获取列表中元素个数</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN <span class="built_in">key</span>     <span class="comment">// 当键不存在则返回0</span></span><br></pre></td></tr></table></figure><ol start="4"><li>获得列表片段</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key <span class="literal">start</span> <span class="literal">stop</span>   //返回区间[<span class="literal">start</span>,<span class="literal">stop</span>]的列表片段（区间闭合），不改变原列表</span><br></pre></td></tr></table></figure><ol start="5"><li>删除列表中指定的值</li></ol><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LREM<span class="built_in"> key</span><span class="built_in"> count</span> <span class="keyword">value</span>  </span><br><span class="line">//删除列表中<span class="built_in">前count</span>个值为<span class="keyword">value</span>的元素，返回值是实际删除的元素个数</span><br></pre></td></tr></table></figure><p>当 <code>count</code> 大于0时，会从列表左边开始删除前<code>count</code> 个；当小于0时，会从列表右边边开始；当 <code>count</code> 等于0时，会删除列表中所有值为 <code>value</code> 的元素。</p><ol start="6"><li>获得/设置指定索引的元素值</li></ol><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LINDEX key <span class="keyword">index</span></span><br><span class="line"></span><br><span class="line">LSET <span class="keyword">key</span> <span class="keyword">index</span> <span class="keyword">value</span></span><br></pre></td></tr></table></figure><p>若 <code>index</code> 小于0，表示从列表右边开始计算索引，最右边的元素的索引值是 -1。</p><ol start="7"><li>只保留列表指定片段</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LTRIM key <span class="literal">start</span> <span class="literal">stop</span>   //只保留区间[<span class="literal">start</span>,<span class="literal">stop</span>]的列表片段（区间闭合），改变了原列表</span><br></pre></td></tr></table></figure><ol start="8"><li>向列表中插入元素</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LINSERT key <span class="keyword">BEFORE</span>|<span class="keyword">AFTER</span> pivot <span class="keyword">value</span>   </span><br><span class="line">//从左到右查找列表的pivot元素，在该元素前或后，插入<span class="keyword">value</span>元素</span><br></pre></td></tr></table></figure><ol start="9"><li>将元素从一个列表转到另一个列表</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RPOPLPUSH <span class="keyword">source</span> destination</span><br><span class="line"><span class="comment">//RPOPLPUSH表示先执行RPOP，再执行LPUSH</span></span><br></pre></td></tr></table></figure><h4 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h4><p>相比于列表，集合（<code>set</code>）中的元素是全局唯一的，并且是无序的。</p><p>集合（<code>set</code>）类型在Redis内部是使用值为空的散列表(<code>hash table</code>)实现的，所以向集合中插入或删除元素，判断元素是否存在，这些操作的时间复杂度都是 <code>O(1)</code>。</p><p>更方便的是，采用集合类型，多个集合类型之间还可以进行交集，并集和差集运算。</p><ol><li>增加/删除元素</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SADD <span class="built_in">key</span> <span class="built_in">member</span> [menber ...] //如果键不存在，则自动创建，返回值为成功加入的元素的数量</span><br><span class="line">SREM <span class="built_in">key</span> <span class="built_in">member</span> [menber ...]</span><br></pre></td></tr></table></figure><ol start="2"><li>获得集合找那个所有的元素</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SMEMBERS key</span></span><br></pre></td></tr></table></figure><ol start="3"><li>判断元素是否在集合中</li></ol><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度位O(1) 速度较快</span></span><br><span class="line">SISMEMBER key <span class="keyword">member</span></span><br></pre></td></tr></table></figure><ol start="4"><li>集合之间的运算</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDIFF  <span class="built_in">key</span> [<span class="built_in">key</span> ...]    <span class="comment">//差集</span></span><br><span class="line">SINTER <span class="built_in">key</span> [<span class="built_in">key</span> ...]    <span class="comment">//交集</span></span><br><span class="line">SUNION <span class="built_in">key</span> [<span class="built_in">key</span> ...]    <span class="comment">//并集</span></span><br></pre></td></tr></table></figure><ol start="5"><li>获取集合中元素个数</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SCARD key</span></span><br></pre></td></tr></table></figure><ol start="6"><li>进行集合运算并将结果存储</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDIFFSTORE destination <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br><span class="line">SINTERSTORE destination <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br><span class="line">SUNIONSTORE destination <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br></pre></td></tr></table></figure><ol start="7"><li>随机获得集合中的元素</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SRANDMEMBER </span>key [<span class="built_in">count</span>]</span><br></pre></td></tr></table></figure><ol start="8"><li>从集合中弹出一个元素</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SPOP key</span></span><br></pre></td></tr></table></figure><h4 id="有序集合类型"><a href="#有序集合类型" class="headerlink" title="有序集合类型"></a>有序集合类型</h4><p>有序集合(<code>sorted list</code>)类型，是在集合类型的基础上，为每个元素关联一个分数（<code>score</code>，可以理解为索引值），使得元素有序。</p><p>Redis中，采用哈希表和跳跃表（<code>Skip list</code>）实现有序集合类型。所以即使读取位于中间部分的数据，速度也是很快的（时间复杂度是``O(logN)`）。</p><ol><li>增加元素</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//添加一个<span class="built_in">member</span>元素和该元素的分数score</span><br><span class="line">ZADD <span class="built_in">key</span> score <span class="built_in">member</span> [score <span class="built_in">member</span>]</span><br></pre></td></tr></table></figure><ol start="2"><li>获得元素的分数</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE <span class="built_in">key</span> <span class="built_in">member</span></span><br></pre></td></tr></table></figure><ol start="3"><li>获得排名在某个范围的元素列表</li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//按照元素分数从小到大的顺序，返回索引在区间[<span class="built_in">start</span>,<span class="built_in">stop</span>]的所有元素</span><br><span class="line">//如果有参数WITHSCORES，表示返回的元素列表包含分数信息</span><br><span class="line">ZRANGE key <span class="built_in">start</span> <span class="built_in">stop</span> [WITHSCORES]</span><br><span class="line"></span><br><span class="line">//类似ZRANGE，只不过是按照分数从大到小的顺序</span><br><span class="line">ZREVRANGE key <span class="built_in">start</span> <span class="built_in">stop</span> [WITHSCORES]</span><br></pre></td></tr></table></figure><ol start="4"><li>获得指定分数范围的元素</li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//按照元素分数从小到大的顺序，返回索引在区间[<span class="built_in">start</span>,<span class="built_in">stop</span>]的所有元素</span><br><span class="line">//如果有参数WITHSCORES，表示返回的元素列表包含分数信息</span><br><span class="line">ZRANGE key <span class="built_in">start</span> <span class="built_in">stop</span> [WITHSCORES]</span><br><span class="line"></span><br><span class="line">//类似ZRANGE，只不过是按照分数从大到小的顺序</span><br><span class="line">ZREVRANGE key <span class="built_in">start</span> <span class="built_in">stop</span> [WITHSCORES]</span><br></pre></td></tr></table></figure><ol start="5"><li>获得指定分数范围的元素</li></ol><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//按照元素分数从小到大，返回分数在区间[<span class="built_in">min</span>,<span class="built_in">max</span>]之间的元素</span><br><span class="line">//LIMIT <span class="built_in">offset</span> <span class="built_in">count</span> 表示在获得元素列表的基础上，向后偏移（跳过）<span class="built_in">offset</span>个元素，并且只获取之后的前<span class="built_in">count</span>个元素</span><br><span class="line">ZRANGEBYSCORE key <span class="built_in">min</span> <span class="built_in">max</span> [WITHSCORES] [LIMIT <span class="built_in">offset</span> <span class="built_in">count</span>]</span><br></pre></td></tr></table></figure><ol start="6"><li>增加某个元素的分数</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY <span class="built_in">key</span> increment <span class="built_in">member</span></span><br></pre></td></tr></table></figure><ol start="7"><li>获得集合中元素的数量</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ZCARD key</span></span><br></pre></td></tr></table></figure><ol start="8"><li>获得指定分数范围内的元素个数</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT <span class="built_in">key</span> <span class="built_in">min</span> <span class="built_in">max</span></span><br></pre></td></tr></table></figure><ol start="9"><li>按照排名范围删除元素</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照元素分数从小到大顺序，删除指定排名范围内的元素，并返回删除的元素数量</span></span><br><span class="line">ZREMRANGEBYRANK <span class="built_in">key</span> start <span class="keyword">stop</span></span><br></pre></td></tr></table></figure><ol start="10"><li>按照分数范围删除元素</li></ol><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回删除的元素数量</span></span><br><span class="line">ZREMRANGEBYSCORE <span class="built_in">key</span> <span class="built_in">min</span> <span class="built_in">max</span></span><br></pre></td></tr></table></figure><ol start="11"><li>获得元素的排名</li></ol><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZRANK key <span class="keyword">member</span>    <span class="comment">//按照分数从小到大顺序</span></span><br><span class="line">ZRANK key <span class="keyword">member</span>    <span class="comment">//按照分数从大到小顺序</span></span><br></pre></td></tr></table></figure><h2 id="Redis进阶"><a href="#Redis进阶" class="headerlink" title="Redis进阶"></a>Redis进阶</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="MULTI-EXEC"><a href="#MULTI-EXEC" class="headerlink" title="MULTI EXEC"></a>MULTI EXEC</h4><p>事务(<code>transaction</code>)是一组命令的集合，事务同命令一样，都是Redis的最小执行单位。一个事务中的命令要么都执行，要么都不执行。事务的应用非常普遍，如银行转账等。</p><p>Redis的事务还可以保证一个事务内的命令一次执行而不被其他命令插入。</p><p>事务的原理是先将属于一个事务的命令发送给Redis，然后再让Redis一次执行这些命令，例如</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt; SADD <span class="string">"user:1:following"</span> <span class="number">2</span></span><br><span class="line">QUEED</span><br><span class="line">redis&gt; SADD <span class="string">"user:2:following"</span> <span class="number">1</span></span><br><span class="line">QUEED</span><br><span class="line">redis&gt; EXEC</span><br><span class="line"><span class="number">1</span>) (<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"><span class="number">2</span>) (<span class="type">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>上面的代码演示了事务的使用方式。首先使用 <code>MULIL</code> 命令告诉Redis：“下面我发给你的命令属于同一个事务，你先不要执行，而是把它们暂时存起来”。</p><p>随后发送两个 <code>SADD</code> 命令执行事务操作，Redis返回 <code>QUEED</code> 表示这2条命令已经进入等待执行的事务队列中了。</p><p>最后，发送 <code>EXEC</code> 命令告诉Redis将等待执行的事务队列中的所有命令按照发送顺序执行。</p><p><strong>事务中的命令是在 <code>EXEC</code> 之后才执行的，因此，一个事务中，只有当所有命令都依次执行完成后，才能得到每个结果的返回值。</strong></p><h4 id="WATCH"><a href="#WATCH" class="headerlink" title="WATCH"></a>WATCH</h4><p><strong>一个事务中，只有当所有命令都依次执行完成后才能得到每个结果的返回值。</strong> 可是有些情况下，需要先获得一条命令的返回值，根据返回值再执行下一条命令。针对该情况，可以使用 <code>WATCH</code> 命令。</p><p><code>WATCH</code> 命令可以监控一个或多个键，一旦其中有一个键被修改或删除，之后的事务就不会执行。监控一直到 <code>EXEC</code> 命令。（事务中的命令是在 <code>EXEC</code> 之后才执行的，所以在 <code>MULTI</code> 命令后可以修改 <code>WATCH</code> 监控的键值）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; <span class="builtin-name">SET</span> key 1</span><br><span class="line">OK</span><br><span class="line">redis&gt; WATCH key</span><br><span class="line">OK</span><br><span class="line">redis&gt; <span class="builtin-name">SET</span> key 2</span><br><span class="line">OK</span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt; <span class="builtin-name">SET</span> key 3</span><br><span class="line">QUEED</span><br><span class="line">redis&gt; EXEC</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">redis&gt; <span class="builtin-name">GET</span> key</span><br><span class="line"><span class="string">"2"</span></span><br></pre></td></tr></table></figure><p>上例中，执行 <code>WATCH</code> 命令后，事务修改了 <code>key</code> 值，所以最后事务代码并没有执行，<code>EXEC</code> 命令返回结果为 <code>nil</code>。</p><p>执行 <code>EXEC</code> 命令后悔取消对所有键的监控。</p><h3 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h3><p>Redis 中可以使用 <code>EXPTRE</code> 命令设置一个键的过期时间，到时间后 Redis 会自动删除它。</p><ol><li>设置过期时间</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE <span class="built_in">key</span> seconds   <span class="comment">//seconds 单位为秒</span></span><br><span class="line"></span><br><span class="line">PEXPIRE <span class="built_in">key</span> milliseconds  <span class="comment">//milliseconds 单位为毫秒</span></span><br></pre></td></tr></table></figure><ol start="2"><li>查询键还有多少时间会被删除</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TTL <span class="built_in">key</span>   <span class="comment">//返回时间单位为秒</span></span><br><span class="line"></span><br><span class="line">PTTL <span class="built_in">key</span>  <span class="comment">//返回时间单位为毫秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 键不存在时，命令返回-2</span></span><br><span class="line"><span class="comment">// 键未设置过期时间时，命令返回-1</span></span><br></pre></td></tr></table></figure><ol start="3"><li>取消键的过期时间设置</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">PERSIST key</span></span><br></pre></td></tr></table></figure><p>除了 <code>PERSIST</code> 命令外，使用 <code>SET</code> 或 <code>GETSET</code> 命令为键赋值，也会同时清除键的过期时间。</p><h4 id="实现访问频率限制"><a href="#实现访问频率限制" class="headerlink" title="实现访问频率限制"></a>实现访问频率限制</h4><p>考虑如下场景——为了减轻服务器的压力，限制每个用户（IP）每分钟最多只能访问10次，就可以使用过期时间 <code>EXPIRE</code> 实现</p><ul><li>创建一个 <code>rate.limiting:userIP</code> 的键</li><li>设置 <code>EXPIRE key seconds</code>，过期时间为60s。一分钟后，该键会被自动删除</li><li>用户每次访问服务器，使用 <code>INCR</code> 递增该键值</li><li>当访问次数达到10后，提示用户稍后访问</li></ul><p>上述流程的伪代码如下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$isKeyExists</span> = EXISTS rate.limiting:<span class="variable">$IP</span></span><br><span class="line"><span class="keyword">if</span> isKeyExists is <span class="number">1</span></span><br><span class="line">    <span class="variable">$time</span> = INCR rate.limiting:<span class="variable">$IP</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$time</span> &gt; <span class="number">10</span></span><br><span class="line">        print 访问频率超过了限制，请稍后再试</span><br><span class="line">        <span class="keyword">exit</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    MULTI           <span class="regexp">//</span>使用事务，避免EXPIRE因为某种原因未执行，导致该键值一直存在</span><br><span class="line">    INCR rate.limiting:<span class="variable">$IP</span></span><br><span class="line">    EXPIRE <span class="variable">$keyName</span>, <span class="number">60</span></span><br><span class="line">    EXEC</span><br></pre></td></tr></table></figure><p>上述代码还有一个问题，比如用户在第1分钟的最后一秒访问了9次，又在下一分钟的第一秒访问了10次。这种访问是可以通过上述访问限制的，但实际上用户在2秒内访问了19次服务器。</p><p>为了处理上述场景，可以对代码进行优化</p><ul><li>使用一个列表存储用户最近10次访问服务器的时间</li><li>一旦键中的元素大于10个，就判断时间最早的元素距现在的时间是否小于1分钟。</li><li>如果是，则表示用户最近一分钟的访问次数超过了10次，进行限流提醒。</li><li>如果不是，就将现在的时间加入到列表中，同时把最早的元素删除。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$listLength</span> = LLEN rate<span class="selector-class">.limiting</span>:<span class="variable">$IP</span></span><br><span class="line"><span class="keyword">if</span> listLength &lt; <span class="number">10</span></span><br><span class="line">    LPUSH rate<span class="selector-class">.limiting</span>:<span class="variable">$IP</span>,now()</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="variable">$time</span> = LINDEX rate<span class="selector-class">.limiting</span>:<span class="variable">$IP</span>, -<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> now() - <span class="variable">$time</span> &gt; <span class="number">60</span></span><br><span class="line">        print 访问频率超过了限制，请稍后再试</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        LPUSH rate<span class="selector-class">.limiting</span>:<span class="variable">$IP</span>,now()</span><br><span class="line">        LTRIM rate<span class="selector-class">.limiting</span>:<span class="variable">$IP</span>,<span class="number">0</span>,<span class="number">9</span></span><br></pre></td></tr></table></figure><h4 id="实现缓存"><a href="#实现缓存" class="headerlink" title="实现缓存"></a>实现缓存</h4><p>为了提高服务器负载能力，常常需要将一些访问频率较高但是CPU或则IO资源消耗较大的操作的结果缓存起来，并希望让这些缓存过一段时间后自动过期。</p><p>实际开发中很难为缓存键设定合理的过期时间，为此可以限制Redis可以使用的最大内存，并让Redis按照一定的规则淘汰不需要的缓存键。这种方式在只将Redis用作缓存系统时非常实用。</p><p>Redis配置文件的 <code>maxmemory</code> 属性限定了Redis可以使用的最大内存。当超出这个限制时，Redis会依据 <code>maxmemory-policy</code> 参数指定的策略来删除不要的键值直到Redis占用的内存大小小于指定内存。</p><p><code>maxmemory-policy</code> 支持<code>LRU</code>(<code>Least Recently Used</code>) 算法规则，即“最近最少使用原则”，其认为最近最少使用的键在未来一段时间内也不会被用到，当内存不足时这些键是可以被删除的。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><code>SORT</code> 命令可以对列表类型，集合类型和有序集合类型键进行排序，并且可以完成和关系数据库中的连接查询类似的任务。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SORT key BY 参考键 <span class="builtin-name">GET</span> <span class="built_in">..</span>. STORE destkey</span><br></pre></td></tr></table></figure><ul><li><code>BY 参考键</code>中，如果提供了 <code>BY</code> 参数，<code>SORT</code> 命令将不再依据元素自身的值进行排序，而是对每个元素使用元素的值替换参考键中的第一个 <code>&quot;*&quot;</code> 并获取其值，然后依据该值对元素进行排序。</li></ul><p>例如，下述语句将读取如 <code>post:2</code>，<code>post:6</code>，<code>post:12</code>，<code>post:26</code> 几个散列键中的 <code>time</code> 字段的值并以此决定排序结果。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SORT</span> tag:ruby:posts <span class="keyword">BY</span> <span class="keyword">post</span>:*-&gt;time <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><ul><li><code>GET</code> 参数不影响排序，它的作用是使 <code>SORT</code> 命令的返回结果不再是元素自身的值，而是 <code>GET</code> 参数中指定的键值。</li><li><code>STORE</code> 参数用于将排序结果存储到指定的键中</li></ul><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p><code>SORT</code> 命令的时间复杂度是 <code>O(n+mlog(m))</code>，其中 <code>n</code> 表示要排序的列表（或集合或有序集合）中的元素个数，<code>m</code>表示要返回的元素个数。当 <code>n</code> 较大的时候，排序命令的性能相对较低，并且 Redis 在排序前会建立一个长度为 <code>n</code> 的容器来存储待排序的元素，虽然是一个临时的过程，但是如果同时进行较多的大数据量的排序操作则会严重影响性能。</p><p>所以开发中使用 <code>SORT</code> 命令需要注意</p><ol><li>尽可能减少待排序键中元素的数量（使 <code>n</code> 尽可能小）</li><li>使用 <code>LIMIT</code> 参数只获取需要的数据（使 <code>m</code> 尽可能小）</li><li>如果需要排序的数据量较大，尽可能使用 <code>STORE</code> 参数将结果缓存</li></ol><h3 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h3><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><p>任务队列，即“传递任务的队列”。和任务队列进行交互的实体有两类，一类是生产者（<code>producer</code>），另一类是消费者（<code>consumer</code>）。生产者会将需要处理的任务放入任务队列中，而消费者会不断地从任务队列中读入任务信息并执行。</p><p>使用任务队列的好处</p><ol><li>松耦合：生产者和消费者不需要知道彼此的实现细节，只需约定好的任务的描述格式即可。</li><li>易于扩展：消费者可以扩展到多个，而且可以分布在不同的服务器中，可以轻易地降低单台服务器的负载</li></ol><h4 id="使用Redis实现任务队列"><a href="#使用Redis实现任务队列" class="headerlink" title="使用Redis实现任务队列"></a>使用Redis实现任务队列</h4><p>使用Redis的列表结构和 <code>RPOP</code>，<code>LPUSH</code> 命令，可以实现简单的任务队列，伪代码如下所示</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无限循环读取任务队列中的内容</span></span><br><span class="line">loop</span><br><span class="line">    <span class="variable">$task</span> = RPOP queue</span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$task</span></span><br><span class="line">        # 如果任务队列中有任务则执行任务</span><br><span class="line">        execute(<span class="variable">$task</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        # 如果没有则等待1秒，以免过于频繁地请求数据</span><br><span class="line">        wait 1 second</span><br></pre></td></tr></table></figure><p>上述伪代码有个不足之处，当任务队列中没有任何任务时，消费者每秒都会调用一次 <code>RPOP</code> 命令查询是否有新任务。</p><p>如果可以实现一旦有新任务加入任务队列就通知消费者就好了。其实借助 <code>BRPOP</code> 命令就可以实现这样的需求。</p><p>如上伪代码可以优化为</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop</span><br><span class="line">    <span class="meta"># 如果任务队列中没有新任务，BRPOP命令会一直阻塞，不会执行execute()</span></span><br><span class="line">    $task = BRPOP queue, <span class="number">0</span></span><br><span class="line">    <span class="meta"># 返回值是一个数组，数组第2个元素是我们需要的任务</span></span><br><span class="line">    <span class="built_in">execute</span>($task[1])</span><br></pre></td></tr></table></figure><p><strong><code>BRPOP</code> 和 <code>RPOP</code> 命令类似，唯一的区别就是当列表中没有元素时，<code>BRPOP</code> 命令会一直阻塞连接，直到有新元素加入。</strong> </p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRPOP <span class="built_in">key</span> [<span class="built_in">key</span> ...] timeout</span><br></pre></td></tr></table></figure><p><code>BRPOP</code> 命令接收2个参数，第1个参数是键名，第2个参数是超时时间，单位是秒。当超过了此时间仍然没有获得新元素的话，就会返回 <code>nil</code>。如果传入时间参数为0（如下伪代码示例），则表示不限制等待时间，即如果没有新元素加入队列就会永远阻塞下去。</p><p>获得一个元素后，<code>BRPOP</code> 命令会返回一个数组，共2个值，分别是键名和元素值。第2个参数，元素值，就是待处理的任务。</p><h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><p>在实际开发中，针对多种不同的任务，经常会需要根据任务的优先级，去执行优先级较高的任务，即需要实现一个优先级队列。</p><p><code>BRPOP</code> 和 <code>BLPOP</code> 命令可以同时接收多个键，可以实现优先级队列。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRPOP <span class="built_in">key</span> [<span class="built_in">key</span> ...] timeout</span><br></pre></td></tr></table></figure><p>例如，<code>BLPOP queue:1 queue:2 0</code>，表示同时检测多个键——<code>queue:1</code> 和 <code>queue:2</code></p><ul><li>如果所有键都没元素则阻塞</li><li>如果有一个键有元素则会从该键中弹出元素</li><li>如果多个键都有元素，则按照<strong>从左到右</strong>顺序读取第一个键中的一个元素</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LPUSH queue:<span class="number">2</span> task1</span><br><span class="line"><span class="number">1</span>) (<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line">redis&gt; LPUSH queue:<span class="number">3</span> task2</span><br><span class="line"><span class="number">1</span>) (<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">redis&gt;BRPOP queue:<span class="number">1</span> queue:<span class="number">2</span> queue:<span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"queue:2"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"task1"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis&gt;BLPOP queue:<span class="number">1</span> queue:<span class="number">2</span> queue:<span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"queue:3"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"task2"</span></span><br></pre></td></tr></table></figure><p>使用 <code>BRPOP</code> 创建优先级队列时，<code>RPOP</code> 表示队列左进右出，因此有如下结构。即 <code>BRPOP queue:1 queue:2 queue:3 0</code> 命令中，越靠左的键优先级越高（<code>queue:1</code> 的优先级最高，因此会按照<strong>从左到右</strong>顺序读取第一个键中的一个元素。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(L-左进)--- | <span class="type">queue</span>:<span class="number">3</span>| <span class="type">queue</span>:<span class="number">2</span>| <span class="type">queue</span>:<span class="number">1</span>| <span class="type">--&gt; (R</span>-右出)</span><br></pre></td></tr></table></figure><p>使用 <code>BLPOP</code> 创建优先级队列时，<code>LPOP</code> 表示队列右进左出，因此有如下结构。即 <code>BLPOP queue:1 queue:2 queue:3 0</code> 命令中，越靠右的键优先级越高（<code>queue:3</code> 的优先级最高），因此会按照<strong>从右到左</strong>顺序读取第一个键中的一个元素。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(L-左出) &lt;--- | <span class="type">queue</span>:<span class="number">1</span>| <span class="type">queue</span>:<span class="number">2</span>| <span class="type">queue</span>:<span class="number">3</span>| <span class="type">--- (R</span>-右进)</span><br></pre></td></tr></table></figure><h4 id="“发布-订阅”模式"><a href="#“发布-订阅”模式" class="headerlink" title="“发布/订阅”模式"></a>“发布/订阅”模式</h4><p>“发布/订阅”模式包含两种角色，分别是发布者和订阅者。订阅者可以订阅一个或多个频道（<code>channel</code>），发布者可以向指定的频道发送消息，所有订阅该频道的订阅者都会受到改消息。</p><ul><li>发布消息</li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH channel <span class="keyword">message</span>   <span class="comment">//命令返回值表示接收到这条消息的订阅者的数量</span></span><br></pre></td></tr></table></figure><p>发布出去的消息不会被持久化，也就是说当有客户订阅该频道 <code>channel</code>后只能收到后续发布的消息，之前发送的消息就收不到了。</p><ul><li>订阅消息</li></ul><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE channel <span class="string">[channel ...]</span></span><br></pre></td></tr></table></figure><p>执行 <code>SUBSCRIBE</code> 命令后客户端会进入订阅状态，此状态下的客户端不能使用 <code>SUBSCRIBE</code>, <code>UNSUBSCRIBE</code>, <code>PSUBSCRIBE</code> 和 <code>PUNSUBSCRIBE</code> 这4个属于 “发布/订阅”模式的命令之外的命令，否则会报错。</p><p>进入订阅状态后的客户端，可能收到3种类型的回复，每种类型的回复都包括3个值。第一个值是消息类型，根据消息类型的不同，第二，第三个值的含义也不同。消息类型的取值可能有以下3个</p><ol><li><code>subscribe</code>。表示订阅消息成功的反馈。第2个值是订阅成功的频道名称，第3个值是当前客户端订阅的频道数量</li><li><code>message</code>。表示接收到的消息。第2个参数表示频道名称，第3个参数是消息内容</li><li><code>unscribe</code>。表示成功取消订阅某个频道。第2个参数表示频道名称，第3个参数是当前客户端订阅的频道数量，当该值为0时，客户端会退出订阅状态。</li></ol><p>下面看一个实例。</p><ol><li>首先Redis的一个实例RedisA在频道 <code>channel1.1</code> 发布一个消息</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RedisA</span></span><br><span class="line">redisA&gt; PUBLISH channel1<span class="number">.1</span> hi</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">0</span>     <span class="comment">//表示当前没有客户端订阅该消息</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Redis的另外一个实例RedisB 订阅频道 <code>channel1.1</code></li></ol><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RedisB</span></span><br><span class="line">redisB&gt; SUBSCRIBE channel1<span class="number">.1</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">"subscribe"</span>   <span class="comment">//订阅消息成功</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"channel1.1"</span></span><br><span class="line"><span class="number">3</span>) (<span class="type">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="3"><li>实例RedisA继续在频道 <code>channel1.1</code> 发布一个消息</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RedisA</span></span><br><span class="line">redisA&gt; PUBLISH channel1<span class="number">.1</span> hello</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span>     <span class="comment">//表示当前没有客户端订阅该消息</span></span><br></pre></td></tr></table></figure><ol start="4"><li>此时，实例RedisB 会收到如下消息</li></ol><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">"message"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"channel1.1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><h4 id="按照规则订阅"><a href="#按照规则订阅" class="headerlink" title="按照规则订阅"></a>按照规则订阅</h4><p>可以使用 <code>PSUBSCRIBE</code> 订阅指定的规则，规则支持 <code>glob</code> 风格通配符格式。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>?</td><td>匹配一个字符</td></tr><tr><td>*</td><td>匹配任意个（包括0个）字符</td></tr><tr><td>[]</td><td>匹配括号间的任一字符，可以使用 <code>-</code> 表示一个范围，如 <code>[1-9]</code></td></tr><tr><td>\x</td><td>用于转义字符</td></tr></tbody></table><p>例如 <code>PSUBSCRIBE channel1.?*</code>命令中，规则 <code>channel1.?*</code> 可以匹配 <code>channel1.1</code> 和 <code>channel1.10</code>，但不会匹配 <code>channel1.1</code>。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul><li>客户端和Redis使用TCP协议连接。</li><li>不论是客户端向Redis发送命令，还是Redis向客户端返回命令结果，都需要经过网络传输。这两个部分的总耗时成为<strong>往返时延。</strong></li><li>大致来说，到本地回环地址（<code>loop back address</code>）的往返时间，在数量级上相当于Redis处理一条简单命令 (如 <code>LPUSH list 1 2 3</code>) 的时间。</li><li>Redis的底层通信协议对管道（<code>pipelining</code>）提供了支持。通过管道可以一次性发送多条命令并在执行完后一次性将结果返回。</li><li>当一组命令中每条命令都不依赖于之前命令的执行结果时就可以将这一组命令一起通过管道发出。管道通过减少客户端和Redis的通信次数，来实现降低往返时延累计值的目的。</li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2020/redis-basic-pipelining-1.png" alt=""></p><h3 id="节省空间"><a href="#节省空间" class="headerlink" title="节省空间"></a>节省空间</h3><p>Redis是一个基于内存的数据库，所有数据都存储在内存中。因此如何节省内存，控制成本，至关重要。节省内存空间，可以从以下方面考虑</p><ol><li>精简键名和键值</li><li>内部编码优化</li></ol><p>Redis为每种数据类型都提供了2种内部编码方式，用于节省内存空间。</p><p>以散列类型为例，散列类型是通过散列表实现的，这样可以实现时间复杂度 <code>O(1)</code> 的查找，赋值操作。然而当元素较少时，<code>O(1)</code>的操作并不会比 <code>O(n)</code> 有明显的性能提高。所以Redis会根据实际情况自动调整，采用一种更为紧凑但性能稍差（查找元素的复杂度为<code>O(n)</code>）的编码方式。</p><p><strong>内部编码方式的选择，对于开发者来说是透明的。</strong> 可以使用 <code>OBJECT ENCODING key</code> 命令查看某个键的内部编码方式。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; <span class="keyword">SET</span> foo <span class="comment">bar</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; OBJECT <span class="comment">ENCODING foo</span></span><br><span class="line"><span class="string">"raw"</span></span><br></pre></td></tr></table></figure><h2 id="Redis-脚本"><a href="#Redis-脚本" class="headerlink" title="Redis 脚本"></a>Redis 脚本</h2><p>Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本（和之后版本）通过内嵌支持 Lua 环境。执行脚本的常用命令为 <code>EVAL</code>。 使用脚本的好处包括</p><ol><li>减少网络开销：使用脚本可以将多个命令的多次请求，通过一次请求完成，减少网络往返时延</li><li>原子操作：Redis将整个脚本作为一个整体执行，中间不会被其他命令插入。即编写脚本过程中无需担心会出现竞态条件，也无需使用事务。事务可以完成的所有功能都可以使用脚本实现。</li><li>复用：客户端发送的脚本会永久存储在Redis中，其他客户端也可以复用这一脚本。</li></ol><h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><p>Redis 支持2种方式的持久化</p><ol><li><code>RDB</code> 方式：根据指定的规则“定时”将内存中的数据存储在硬盘上</li><li><code>AOF</code> 方式：每次执行命令后将命令本身记录下来</li></ol><p>通过 <code>RDB</code> 方式实现持久化，一旦 Redis 异常退出，就会丢失最后一次快照以后更改的所有数据。如果数据相对重要，希望损失降到最小，则可以使用 <code>AOF</code> 方式进行持久化。</p><p>Redis 允许同时开启 <code>RDB</code> 和 <code>AOF</code> 方式，既保证了数据安全又使得进行备份等操作十分容易。此时重新启动 Redis 后，Redis 会使用 AOF 文件来恢复数据，因为 AOF 方式的持久化可能丢失的数据更少。</p><h3 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h3><p><code>RDB</code> 方式的持久化是通过快照（<code>snapshoting</code>）完成的，当符合一定条件时 Redis 会自动将内存中的所有数据生成一份副本并存储在硬盘上，这个过程即“快照”。</p><h4 id="快照触发条件"><a href="#快照触发条件" class="headerlink" title="快照触发条件"></a>快照触发条件</h4><p>Redis 会在以下几种情况下对数据进行快照</p><ol><li>根据配置规则进行自动快照：每当时间窗口 M 内被更改的键的个数大于 N 时，即符合自动快照条件</li><li>用户执行 <code>SAVE</code> 或 <code>BGSAVE</code> 命令<ul><li>执行 <code>SAVE</code> 命令时，Redis同步地执行快照操作。快照执行过程中会阻塞所有来自客户端的请求。所以应该尽量避免在生产环境中执行该指令</li><li><code>BGSAVE</code> 命令可以在后台异步地执行快照操作，同时可以响应客户端的请求</li></ul></li><li>执行 <code>FLUSHALL</code> 命令<ul><li><code>FLUSHALL</code> 命令会清楚数据库中的所有操作</li><li>只要自动快照条件不为空（即使不满足该条件），执行 <code>FLUSHALL</code> 命令后，也会触发快照操作</li><li>当没有定义自动快照条件时，执行 <code>FLUSHALL</code> 命令不会触发快照操作</li></ul></li><li>执行复制（<code>replication</code>）时：设置了主从模式时，Redis会在复制初始化时进行自动快照</li></ol><h4 id="快照原理"><a href="#快照原理" class="headerlink" title="快照原理"></a>快照原理</h4><p>Redis 默认会将快照文件存储在 Redis 当前进程的工作目录种的 <code>dump.rdb</code> 文件中。快照的过程如下</p><ol><li>Redis 使用 <code>fork</code> 函数复制一份当前进程（父进程）的副本（子进程）</li><li>父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件</li><li>当子进程写入完成所有数据后会用该临时文件替换旧的 <code>RDB</code> 文件，至此一次快照操作完成。</li></ol><h3 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h3><p><code>AOF</code>(<code>append only file</code>) 方式可以将 Redis 执行的每一条命写命令追加到硬盘文件中，这一过程显然会降低 Redis 性能。但大部分情况下这个影响是可以接收的，另外使用较快的硬盘可以提高 <code>AOF</code> 的性能。</p><ul><li>开启AOF</li></ul><p>默认情况下没有开启AOF，执行如下命令可以开启AOF。默认情况下，AOF文件的保存位置和RDB文件的位置相同，默认的文件名是 <code>appendonly.aof</code>。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">appendonly</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><ul><li>AOF的实现</li></ul><p>AOF 文件的内容正是Redis客户端向Redis发送的原始通信协议的内容。</p><ul><li>同步硬盘数据</li></ul><p>由于操作系统的缓存机制，AOF文件数据并没有直接真正地写入硬盘，而是进入了系统的硬盘缓存。在默认情况下系统每 30 秒会执行一次同步操作，以便将硬盘缓存中的内容真正地写入硬盘。在这30秒内，如果系统异常退出则会导致硬盘缓存中的数据丢失。</p><p>一般来讲，启用AOF持久化的应用都无法容忍这样的损失。这就需要 Redis 在写入AOF 文件后主动要求系统将硬盘缓存内容同步到硬盘中。在 Redis 中，可以通过 <code>appendfsync</code> 参数设置同步的时机</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># appendfsync always</span></span><br><span class="line">appendfsync everysec   <span class="comment">//默认</span></span><br><span class="line"><span class="meta"># appendfsync no       //不主动进行同步操作，即交由操作系统处理（每30秒同步一次）</span></span><br></pre></td></tr></table></figure><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>同时拥有多个 Redis 服务器后，就会面临如果管理集群的问题，包括如何增加节点，故障恢复等操作。</p><h3 id="复制-replication"><a href="#复制-replication" class="headerlink" title="复制 replication"></a>复制 replication</h3><p>为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上。为此，Redis提供了复制 <code>replication</code> 功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库中。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在复制的概念中，数据库分为2种</p><ol><li>主数据库（<code>master</code>）：可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库</li><li>从数据库 （<code>slave</code>）：一般是只读的（也可以配置为可写入），并接受主数据库同步过来的数据</li></ol><p>Redis中，只需要在从数据库配置文件中加入如下配置，即可完成复制操作，主数据库不需要任何配置。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">salveof</span> 主数据库地址   主数据库端口</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol><li>启动一个Redis实例作为主数据库，默认端口号是6379</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$re</span>dis-server    <span class="comment">//默认端口号是6379</span></span><br></pre></td></tr></table></figure><ol start="2"><li>启动另一个Redis实例作为从数据库，监听端口号 6380</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$redis-server   --port <span class="number">6380</span> --slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>此时主数据库中任何数据变化，都会自动同步到从数据库中。</p><ol start="3"><li>打开 <code>redis-cli</code> 实例A并连接到主数据库。再打开 <code>redis-cli</code> 实例B并连接到从数据库</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$redis-cli -p <span class="number">6379</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br><span class="line"></span><br><span class="line">$redis-cli -p <span class="number">6380</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用 <code>INFO replication</code> 命令在实例A和实例B中查看复制相关的信息</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; INFO replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:<span class="number">1</span></span><br><span class="line">slave0:ip=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,port=<span class="number">6380</span>,state=online,offset=<span class="number">336</span>,lag=<span class="number">1</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>可以看到，实例A的角色是主数据库，其已连接的从数据库的个数是1。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; INFO replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">master_port:<span class="number">6379</span></span><br></pre></td></tr></table></figure><p>可以看到，实例B的角色是从数据库。</p><ol start="5"><li>在主数据库中添加键值，可以在从数据库中读取</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 主数据库写入</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SET foo bar</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 从数据库读取</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; GET foo</span><br><span class="line"><span class="string">"bar"</span></span><br></pre></td></tr></table></figure><h4 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h4><p>从数据库不仅可以接受主数据库的同步数据，自己也可以同时作为主数据库存在，形成类似图的结构，如下图所示。</p><p>主数据A的数据会同步到B和C，而B中的数据会同步到D和E中。向B中写入的数据不会同步到A或C中。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A<span class="string">[主数据库A]</span>--&gt;B<span class="string">[从数据库B]</span></span><br><span class="line">A<span class="string">[主数据库A]</span>--&gt;C<span class="string">[从数据库C]</span></span><br><span class="line"></span><br><span class="line">B<span class="string">[从数据库B]</span>--&gt;D<span class="string">[从数据库D]</span></span><br><span class="line">B<span class="string">[从数据库B]</span>--&gt;E<span class="string">[从数据库E]</span></span><br></pre></td></tr></table></figure><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><h4 id="面临的问题"><a href="#面临的问题" class="headerlink" title="面临的问题"></a>面临的问题</h4><p>为了提高性能，可以通过复制功能建立若干个从数据库，并在从数据库中启用持久化，同时在主数据中禁用持久化。这样可以保证主数据库的性能。</p><ol><li>当从数据库崩溃重启后，主数据库会自动将数据同步过来，所以无需担心数据丢失</li><li>当主数据库崩溃后，情况就比较复杂了。手动通过从数据库恢复主数据库数据时，需要严格执行如下2步<ul><li>在从数据库中使用 <code>SLAVE NO ONE</code> 命令将从数据库提升为主数据库继续服务</li><li>启动之前崩溃的主数据库，然后使用 <code>SLAVEOF</code> 命令将其设置成新的主数据库的从数据库，即可将数据同步回来</li></ul></li></ol><p>可见，手动维护主从数据库崩溃后的数据恢复是相当麻烦的。Redis提供了一种自动化方案——哨兵，避免了手工维护的麻烦和容易出错的问题。</p><h4 id="哨兵的功能"><a href="#哨兵的功能" class="headerlink" title="哨兵的功能"></a>哨兵的功能</h4><p>Redis 2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。</p><p>哨兵的作用就是监控 Redis 系统的运行状况，它的功能包括2个</p><ol><li>监控主数据库和从数据库是否正常工作</li><li>主数据库出现故障时自动将从数据库转换为主数据库</li></ol><p><strong>哨兵是一个独立的进程</strong>，使用哨兵的一个典型架构如下图所示。虚线表示主从复制关系，实线表示哨兵的监控路径。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2020/redis-basic-guard-1.png" alt=""></p><p>在一个一主多从的Redis系统中，可以使用多个哨兵进行监控任务以保证系统是足够稳健的，如下图所示。此时不仅哨兵会同时监控主从数据库，哨兵之间也会互相监控。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2020/redis-basic-guard-2.png" alt=""></p><h4 id="使用哨兵"><a href="#使用哨兵" class="headerlink" title="使用哨兵"></a>使用哨兵</h4><ol><li>创建哨兵配置文件，如 <code>sentinel.conf</code></li></ol><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor master-name  ip redis-port quorum</span></span><br><span class="line"></span><br><span class="line">sentinel<span class="built_in"> monitor </span>mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><p>其中，<code>mymaster</code> 是要监控的主数据库的名称，可以自定义一个。后面的参数是数据库的IP地址和端口号。</p><p>最后的参数 <code>1</code> 表示最低通过票数（<code>quorum</code>），即执行故障恢复操作前至少需要几个哨兵节点同意。一般情况下，取 <code>quorum</code> 的值为 <code>N/2 + 1</code>，其中 <code>N</code> 表示哨兵数目，即只有超过一半的哨兵同意后才会进行故障恢复。</p><ol start="2"><li>启动哨兵进程，并将上述配置文件的路径传递给哨兵</li></ol><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$redis-sentinel /path/<span class="keyword">to</span>/sentinel.conf</span><br></pre></td></tr></table></figure><p>需要注意的是，配置哨兵监控一个系统时，只需要配置其监控主数据库即可，哨兵会自动发现所有复制该主数据库的从数据库。</p><h3 id="集群-1"><a href="#集群-1" class="headerlink" title="集群"></a>集群</h3><p>Redis 3.0版本提供了集群（<code>Cluster</code>）特性。集群的特点在于拥有和单机实例同样的性能，同时在网络分区后能够提供一定的可访问性以及对主数据库故障恢复的支持。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;对 Redis 基础知识进行梳理，包括Redis的5种数据类型，事务，过期时间，消息通知，优先级队列，管道，数据持久化，复制，哨兵，事务等&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Back-End" scheme="https://lbs0912.github.io/categories/Back-End/"/>
    
    
      <category term="Back-End" scheme="https://lbs0912.github.io/tags/Back-End/"/>
    
      <category term="DataBase" scheme="https://lbs0912.github.io/tags/DataBase/"/>
    
      <category term="Redis" scheme="https://lbs0912.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Notes-000-Overview</title>
    <link href="https://lbs0912.github.io/2020/01/12/leetcode-otes-000-overview/"/>
    <id>https://lbs0912.github.io/2020/01/12/leetcode-otes-000-overview/</id>
    <published>2020-01-12T02:35:26.000Z</published>
    <updated>2020-01-12T09:02:22.647Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录LeetCode题目笔记，汇总LeetCode解答记录</li></ul><a id="more"></a><h2 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h2><ul><li>2019/02/13，撰写</li><li>2019/06/16，添加 LeetCode Notes-1</li><li>2020/01/05，添加 LeetCode Notes-2</li></ul><h2 id="学习资料汇总"><a href="#学习资料汇总" class="headerlink" title="学习资料汇总"></a>学习资料汇总</h2><ul><li><a href="https://leetcode.com/" target="_blank" rel="noopener">leetcode</a></li><li><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">leetcode-cn</a></li><li><a href="https://www.nowcoder.com/" target="_blank" rel="noopener">牛客网</a></li><li><a href="http://git.jd.com/algorithm-interest-group/AlgorithmShare" target="_blank" rel="noopener">AlgorithmShare @ JD</a></li><li><a href="https://github.com/MisterBooo/LeetCodeAnimation" target="_blank" rel="noopener">LeetCodeAnimation</a></li><li><a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">Leetcode Solution | github</a></li></ul><h2 id="题解记录模板"><a href="#题解记录模板" class="headerlink" title="题解记录模板"></a>题解记录模板</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## XXX</span></span><br><span class="line"><span class="comment">### Description</span></span><br><span class="line">* [LeetCode-XX. XXX]()</span><br><span class="line"></span><br><span class="line"><span class="comment">### Approach 1-XX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Analysis</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Solution</span></span><br><span class="line"></span><br><span class="line">* Java</span><br><span class="line">* C++</span><br><span class="line">* Python</span><br><span class="line">* JS</span><br></pre></td></tr></table></figure><h2 id="分类汇总"><a href="#分类汇总" class="headerlink" title="分类汇总"></a>分类汇总</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li><a href="https://leetcode.com/problems/linked-list-cycle/?tab=Description" target="_blank" rel="noopener">LeetCode- 141. Linked List Cycle</a> - 环形链表</li><li><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCode- 142. Linked List Cycle II</a> - 环形链表</li></ul><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><ul><li><a href="https://leetcode.com/problems/linked-list-cycle/?tab=Description" target="_blank" rel="noopener">LeetCode- 141. Linked List Cycle</a> - 环形链表</li><li><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCode- 142. Linked List Cycle II</a> - 环形链表</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li><a href="https://leetcode.com/problems/island-perimeter/?tab=Description" target="_blank" rel="noopener">LeetCode - 463. Island Perimeter</a> - 常规计算</li></ul><h3 id="PopCount（汉明距离）"><a href="#PopCount（汉明距离）" class="headerlink" title="PopCount（汉明距离）"></a>PopCount（汉明距离）</h3><ul><li><a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="noopener">LeetCode-191. Number of 1 Bits</a></li><li><a href="https://leetcode.com/problems/counting-bits/" target="_blank" rel="noopener">LeetCode-338. Counting Bits</a></li></ul><h3 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h3><ul><li><a href="https://leetcode.com/problems/longest-palindrome/" target="_blank" rel="noopener">LeetCode-409. Longest Palindrome</a></li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li><a href="https://leetcode.com/problems/counting-bits/" target="_blank" rel="noopener">LeetCode-338. Counting Bits</a></li></ul><h2 id="文档目录"><a href="#文档目录" class="headerlink" title="文档目录"></a>文档目录</h2><h3 id="Notes-1"><a href="#Notes-1" class="headerlink" title="Notes-1"></a>Notes-1</h3><ul><li><a href="https://leetcode.com/problems/linked-list-cycle/?tab=Description" target="_blank" rel="noopener">LeetCode-141. Linked List Cycle</a> - 环形链表</li><li><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCode-142. Linked List Cycle II</a> - 环形链表</li><li><a href="https://leetcode.com/problems/add-digits/?tab=Description" target="_blank" rel="noopener">LeetCode-258. Add Digits</a> - 数字推导（数字根）</li><li><a href="https://leetcode.com/problems/hamming-distance/" target="_blank" rel="noopener">LeetCode-461. Hamming Distance</a> - 位运算</li><li><a href="https://leetcode.com/problems/island-perimeter/?tab=Description" target="_blank" rel="noopener">LeetCode-463. Island Perimeter</a> - 常规计算</li></ul><h3 id="Notes-2"><a href="#Notes-2" class="headerlink" title="Notes-2"></a>Notes-2</h3><ul><li><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">LeetCode-206. Reverse Linked List</a> - 链表操作</li><li><a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">LeetCode-617. Merge Two Binary Trees</a> - 二叉树</li><li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">LeetCode-104. Maximum Depth of Binary Tree</a> - 遍历二叉树</li><li><a href="https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/" target="_blank" rel="noopener">LeetCode-1290. Convert Binary Number in a Linked List to Integer</a></li><li><a href="https://leetcode.com/problems/to-lower-case/" target="_blank" rel="noopener">LeetCode-709. To Lower Case</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录LeetCode题目笔记，汇总LeetCode解答记录&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/tags/LeetCode/"/>
    
      <category term="Algorithm" scheme="https://lbs0912.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>React Native 实现下拉自动切换分类</title>
    <link href="https://lbs0912.github.io/2019/06/08/rn-tab-auto-change/"/>
    <id>https://lbs0912.github.io/2019/06/08/rn-tab-auto-change/</id>
    <published>2019-06-08T02:35:26.000Z</published>
    <updated>2019-11-09T15:22:38.601Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录 <code>React Native</code> 中如何实现下拉自动切换分类</li><li>针对 IOS 和 Android 平台差异，给出不同的切换分类触发条件</li></ul><a id="more"></a><h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>如图所示，整体为 <code>FlatList</code>，顶部分类栏吸顶，底部为 <code>feed</code> 流。要实现下拉商品列表到底后，继续下拉，自动切换到一下个分类的效果。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/front-end-2019/rn-flatlist-autochange-tab-android.png" alt="rn-flatlist-autochange-tab-android"></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>代码层面，可以在  <code>FlatList</code> 的 <code>onScrollEndDrag</code> 中添加自动 Tab 切换函数，借助 <code>FlatList</code> 实例的内容区高度 <code>contentLength</code>，滑动偏移量 <code>offset</code> 和可视区高度 <code>visibleLength</code> 三者关系，实现下拉自动切换Tab功能。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="IOS-平台实现"><a href="#IOS-平台实现" class="headerlink" title="IOS 平台实现"></a>IOS 平台实现</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//页面布局相关</span></span><br><span class="line"> &lt;FlatList</span><br><span class="line">    <span class="keyword">data</span> = &#123;[&#123;banner:[]&#125;,&#123;tab:[]&#125;,&#123;goodList:[]&#125;]&#125;</span><br><span class="line">    renderItem=&#123;<span class="keyword">this</span>.renderItem&#125;</span><br><span class="line">    stickyHeaderIndices=&#123;(Platform.OS !== <span class="string">'web'</span>)?[<span class="number">1</span>]:<span class="literal">null</span>&#125;</span><br><span class="line">    ListFooterComponent=&#123;<span class="keyword">this</span>._renderFooter&#125;</span><br><span class="line">    onScroll=&#123;<span class="keyword">this</span>._onScroll&#125; <span class="comment">//滑动监听</span></span><br><span class="line">    ref=&#123;<span class="keyword">this</span>._setScrollRef&#125;</span><br><span class="line">    keyExtractor = &#123;(item, index) =&gt; &#123; `hScrollView-$&#123;index&#125;` &#125;&#125;</span><br><span class="line">    refreshing=&#123;<span class="keyword">this</span>.state.isRefreshing&#125;</span><br><span class="line">    onRefresh=&#123;<span class="keyword">this</span>._onRefresh.bind(<span class="keyword">this</span>)&#125; <span class="comment">//下拉刷新</span></span><br><span class="line">    getItemLayout=&#123;(<span class="keyword">data</span>, index) =&gt; (</span><br><span class="line">        &#123;length: <span class="number">305</span>, offset: <span class="number">305</span> * index, index&#125;</span><br><span class="line">    )&#125;</span><br><span class="line">    onScrollEndDrag = &#123;()=&gt;&#123;  <span class="comment">//滑动到底监听函数</span></span><br><span class="line">        <span class="keyword">if</span>(Platform.OS != <span class="string">'web'</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>._onScrollEndDragFun();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取flatList 实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ref</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_setScrollRef = (ref) =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>._secondGoodFlatListRef = ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> isEmpty <span class="keyword">from</span> <span class="string">"lodash/isEmpty"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Platform&#125; <span class="keyword">from</span> <span class="string">"react-native"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;JDDevice&#125; <span class="keyword">from</span> <span class="string">"@jdreact/jdreact-core-lib"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 底部列表页滑动事件 实现上拉切换品类功能</span></span><br><span class="line"><span class="comment"> * @param e</span></span><br><span class="line"><span class="comment"> * @private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_onScrollEndDragFun = (e) =&gt; &#123;</span><br><span class="line">    let scrollMetrics = (<span class="keyword">this</span>._secondGoodFlatListRef &amp;&amp; <span class="keyword">this</span>._secondGoodFlatListRef._listRef</span><br><span class="line">        &amp;&amp; <span class="keyword">this</span>._secondGoodFlatListRef._listRef._scrollMetrics) || <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    let &#123;contentLength = <span class="number">0</span>, offset = <span class="number">0</span>, visibleLength = <span class="number">0</span>&#125; = scrollMetrics;</span><br><span class="line">    <span class="comment">// console.log('===scrollMetrics',scrollMetrics);</span></span><br><span class="line">    <span class="comment">// //判断是否最后一Tab 如果是就不却换下个目录</span></span><br><span class="line">    <span class="comment">// console.log('===this.props',this.props);</span></span><br><span class="line">    <span class="comment">// console.log('===this.state',this.state);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (contentLength &amp;&amp; offset &amp;&amp; visibleLength) &#123;</span><br><span class="line">        let &#123;selectedIndex = <span class="number">0</span>&#125; = <span class="keyword">this</span>.state; <span class="comment">//当前选中的三级分类index</span></span><br><span class="line">        let &#123;tabListData = []&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isEmpty(tabListData) &amp;&amp; (selectedIndex + <span class="number">1</span>) &lt; tabListData.length) &#123;  <span class="comment">//排除最后一个分类</span></span><br><span class="line">            let item = tabListData[selectedIndex + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (Platform.OS === <span class="string">'ios'</span>) &#123;</span><br><span class="line">                <span class="comment">//IOS 系统存在弹性上拉</span></span><br><span class="line">                <span class="keyword">if</span> (offset + visibleLength &gt; contentLength + JDDevice.getRpx(<span class="number">100</span>)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>._secondGoodFlatListRef.scrollToIndex(&#123;</span><br><span class="line">                        animated: <span class="literal">false</span>,</span><br><span class="line">                        index: <span class="number">0</span>,</span><br><span class="line">                        viewOffset: <span class="number">1</span>,</span><br><span class="line">                        viewPosition: <span class="number">0</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">this</span>.ItemCategory._clickCategoryTab2 &amp;&amp; <span class="keyword">this</span>.ItemCategory._clickCategoryTab2(item, selectedIndex + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//android 无弹性滑动，滑动到底时，offset + visibleLength = contentLength。IOS有弹性滑动，需要改变判断条件  lbs 2019-03-10</span></span><br><span class="line">                <span class="keyword">if</span> (offset + visibleLength &gt; contentLength - JDDevice.getRpx(<span class="number">10</span>)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>._secondGoodFlatListRef.scrollToIndex(&#123;</span><br><span class="line">                        animated: <span class="literal">false</span>,</span><br><span class="line">                        index: <span class="number">0</span>,</span><br><span class="line">                        viewOffset: <span class="number">1</span>,</span><br><span class="line">                        viewPosition: <span class="number">0</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">this</span>.ItemCategory._clickCategoryTab2 &amp;&amp; <span class="keyword">this</span>.ItemCategory._clickCategoryTab2(item, selectedIndex + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>其中，<code>contentLength</code> 为内容区高度，<code>offset</code> 为滑动偏移量，<code>visibleLength</code> 为可视区高度。</strong></p><blockquote><p>关于<span id="inline-purple">三种高度定义</span>，可参考 <a href="https://www.jianshu.com/p/33ec6ceeb638" target="_blank" rel="noopener">React Native中ListView和ScrollView实现上拉加载</a></p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scrollMetrics = (this._secondGoodFlatListRef<span class="operator"> &amp;&amp; </span>this.<span class="module-access"><span class="module"><span class="identifier">_secondGoodFlatListRef</span>.</span><span class="module"><span class="identifier">_listRef</span></span></span></span><br><span class="line"><span class="module-access"><span class="module"> </span></span><span class="operator">       &amp;&amp; </span>this.<span class="module-access"><span class="module"><span class="identifier">_secondGoodFlatListRef</span>.</span><span class="module"><span class="identifier">_listRef</span>.</span><span class="module"><span class="identifier">_scrollMetrics</span>)</span></span><span class="operator"> || </span>null;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    contentLength = <span class="number">0</span>,  <span class="comment">// 内容区高度</span></span><br><span class="line">    offset = <span class="number">0</span>,         <span class="comment">// 滑动偏移量</span></span><br><span class="line">    visibleLength = <span class="number">0</span>   <span class="comment">// 可视区高度</span></span><br><span class="line">&#125; = scrollMetrics;</span><br></pre></td></tr></table></figure><h3 id="Android-平台实现"><a href="#Android-平台实现" class="headerlink" title="Android 平台实现"></a>Android 平台实现</h3><p>对于 Android 平台，当 <code>offset + visibleLength = contentLength</code> 时，表示滑动到底部。为了以前进行切换，对条件进行修正，当滑动到距离底部 10px 时，触发切换 Tab 函数，如下代码所示</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android 无弹性滑动，滑动到底时，offset + visibleLength = contentLength。IOS有弹性滑动，需要改变判断条件  lbs 2019-03-10</span></span><br><span class="line"><span class="keyword">if</span> (offset + visibleLength &gt; contentLength - JDDevice.getRpx(<span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="keyword">this</span>._secondGoodFlatListRef.scrollToIndex(&#123;</span><br><span class="line">        animated: <span class="literal">false</span>,</span><br><span class="line">        index: <span class="number">0</span>, </span><br><span class="line">        viewOffset: <span class="number">1</span>,</span><br><span class="line">        viewPosition: <span class="number">0</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//切换Tab</span></span><br><span class="line">    <span class="keyword">this</span>.ItemCategory._clickCategoryTab2 &amp;&amp; <span class="keyword">this</span>.ItemCategory._clickCategoryTab2(item, selectedIndex + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 IOS 平台，因为 IOS 系统存在弹性上拉，如下图所示。因此对滑动到底条件修正为  <code>offset + visibleLength &gt; contentLength + JDDevice.getRpx(100)</code>。</p><p>其中，<code>JDDevice.getRpx(100)</code> 表示弹性上拉的高度，即下图中红色框的高度。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/front-end-2019/rn-flatlist-autochange-tab-ios.png" alt="rn-flatlist-autochange-tab-ios"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Platform.OS === <span class="string">'ios'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (offset + visibleLength &gt; contentLength + JDDevice.getRpx(<span class="number">100</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>._secondGoodFlatListRef.scrollToIndex(&#123;</span><br><span class="line">            animated: <span class="literal">false</span>,</span><br><span class="line">            index: <span class="number">0</span>,</span><br><span class="line">            viewOffset: <span class="number">1</span>,</span><br><span class="line">            viewPosition: <span class="number">0</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.ItemCategory._clickCategoryTab2 &amp;&amp; <span class="keyword">this</span>.ItemCategory._clickCategoryTab2(item, selectedIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录 &lt;code&gt;React Native&lt;/code&gt; 中如何实现下拉自动切换分类&lt;/li&gt;
&lt;li&gt;针对 IOS 和 Android 平台差异，给出不同的切换分类触发条件&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="React Native" scheme="https://lbs0912.github.io/categories/React-Native/"/>
    
    
      <category term="React Native" scheme="https://lbs0912.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>JS模块化——CommonJS AMD CMD ES6 Module</title>
    <link href="https://lbs0912.github.io/2019/03/28/js-module-introduce/"/>
    <id>https://lbs0912.github.io/2019/03/28/js-module-introduce/</id>
    <published>2019-03-28T02:35:26.000Z</published>
    <updated>2019-11-09T15:22:38.601Z</updated>
    
    <content type="html"><![CDATA[<ul><li>对 JS 常见的模块化方案进行介绍和比较——<code>CommonJS</code> <code>AMD</code> <code>CMD</code> <code>ES6 Module</code></li><li>对 <code>ES6 Module</code> 和 <code>CommonJS</code> 的差异进行对比，介绍循环依赖和动态 <code>import()</code></li></ul><a id="more"></a><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><ul><li>2018/05/08，撰写</li><li>2019/03/27，内容整理</li><li>2019/04/01，动态 <code>import()</code> 和博文发表</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000004873947" target="_blank" rel="noopener">AMD, CMD, CommonJS和UMD | Segmentfault</a></li><li><a href="https://zhuanlan.zhihu.com/p/41231046" target="_blank" rel="noopener">JS模块化加载之CommonJS、AMD、CMD、ES6</a></li><li><a href="http://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="noopener">ES6 module的加载和实现 | 阮一峰</a></li><li><a href="https://div.io/topic/1078" target="_blank" rel="noopener">前端模块化开发方案小对比</a></li></ul><h2 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>模块化开发中，通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数，并且可以按需加载。</li><li>依赖自动加载，按需加载。</li><li>提高代码复用率，方便进行代码的管理，使得代码管理更加清晰、规范。</li><li>减少了命名冲突，消除全局变量。</li><li>目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统</li></ul><h3 id="常见模块化规范"><a href="#常见模块化规范" class="headerlink" title="常见模块化规范"></a>常见模块化规范</h3><ul><li>CommonJs (Node.js)</li><li>AMD (RequireJS)</li><li>CMD (SeaJS)</li></ul><h2 id="CommonJS-Node-js"><a href="#CommonJS-Node-js" class="headerlink" title="CommonJS(Node.js)"></a>CommonJS(Node.js)</h2><p><strong>CommonJS是服务器模块的规范</strong>，Node.js采用了这个规范。</p><p>根据 <code>CommonJS</code> 规范，一个单独的文件就是一个模块，每一个模块都是一个单独的作用域，在一个文件定义的变量（还包括函数和类），<strong>都是私有的</strong>，对其他文件是不可见的。</p><p><strong>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。</strong> </p><p><code>CommonJS</code> 中，加载模块使用 <code>require</code> 方法。该方法读取一个文件并执行，最后返回文件内部的 <code>exports</code> 对象。</p><blockquote><p><code>Node.js</code> 主要用于服务器编程，加载的模块文件一般都已经存在本地硬盘，加载起来较快，不用考虑异步加载的方式，所以 <code>CommonJS</code> 的同步加载模块规范是比较适用的。</p><p>但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 <code>AMD</code>，<code>CMD</code> 等解决方案。</p></blockquote><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keywords">var</span> <span class="symbol">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keywords">var</span> addX = function(value) &#123;</span><br><span class="line">  <span class="keywords">return</span> value + <span class="symbol">x</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports.<span class="symbol">x</span> = <span class="symbol">x</span>;</span><br><span class="line">module.exports.addX = addX;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以改写为如下</span></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  <span class="symbol">x</span>: <span class="symbol">x</span>,</span><br><span class="line">  addX: addX,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let <span class="built_in">math</span> = <span class="built_in">require</span>(<span class="string">'./math.js'</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'math.x'</span>,<span class="built_in">math</span>.x);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'math.addX'</span>, <span class="built_in">math</span>.addX(<span class="number">4</span>));</span><br></pre></td></tr></table></figure><h2 id="AMD-RequireJS-异步模块定义"><a href="#AMD-RequireJS-异步模块定义" class="headerlink" title="AMD (RequireJS) 异步模块定义"></a>AMD (RequireJS) 异步模块定义</h2><ul><li><code>AMD</code>  = <code>Asynchronous Module Definition</code>，即 <em>异步模块定义</em>。</li><li><strong><code>AMD</code> 规范加载模块是异步的，并允许函数回调，不必等到所有模块都加载完成，后续操作可以正常执行。</strong></li><li><code>AMD</code> 中，使用 <code>require</code> 获取依赖模块，使用 <code>exports</code> 导出 <code>API</code>。</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规范 API</span></span><br><span class="line">define(id?, dependencies?, factory);</span><br><span class="line">define.amd = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义无依赖的模块</span></span><br><span class="line">define(&#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span><span class="params">(x,y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义有依赖的模块</span></span><br><span class="line">define([<span class="string">"alpha"</span>], <span class="function"><span class="keyword">function</span><span class="params">(alpha)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        verb: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> alpha.verb() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="异步加载和回调"><a href="#异步加载和回调" class="headerlink" title="异步加载和回调"></a>异步加载和回调</h3><blockquote><p><strong>require([module], callback)</strong> 中 <code>callback</code> 为模块加载完成后的回调函数</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//加载 <span class="built_in">math</span>模块，完成之后执行回调函数</span><br><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span><span class="params">(math)</span></span> &#123;</span><br><span class="line">　<span class="built_in">math</span>.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="RequireJS"><a href="#RequireJS" class="headerlink" title="RequireJS"></a>RequireJS</h3><p><code>RequireJS</code> 是一个前端模块化管理的工具库，遵循 <code>AMD</code> 规范，<code>RequireJS</code> 是对 <code>AMD</code> 规范的阐述。</p><p><code>RequireJS</code> 基本思想为，通过一个函数来将所有所需的或者所依赖的模块装载进来，然后返回一个新的函数（模块）。后续所有的关于新模块的业务代码都在这个函数内部操作。</p><p><code>RequireJS</code> 要求每个模块均放在独立的文件之中，并使用 <code>define</code> 定义模块，使用 <code>require</code> 方法调用模块。</p><p>按照是否有依赖其他模块情况，可以分为 <em>独立模块</em> 和 <em>非独立模块</em>。</p><ul><li>独立模块，不依赖其他模块，直接定义</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define(&#123;</span><br><span class="line">    method1: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;,</span><br><span class="line">    method2: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        method1: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;,</span><br><span class="line">        method2: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>非独立模块，依赖其他模块</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">define([ <span class="string">'module1'</span>, <span class="string">'module2'</span> ], <span class="function"><span class="keyword">function</span>(<span class="params">m1, m2</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">'module1'</span>);</span><br><span class="line">    <span class="keyword">var</span> m2 = <span class="built_in">require</span>(<span class="string">'module2'</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>require</code> 方法调用模块</li></ul><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require(['foo', 'bar'], function(<span class="name">foo</span>, bar) &#123;</span><br><span class="line">    foo.func()<span class="comment">;</span></span><br><span class="line">    bar.func()<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="CMD-SeaJS"><a href="#CMD-SeaJS" class="headerlink" title="CMD (SeaJS)"></a>CMD (SeaJS)</h2><p><code>CMD</code>  = <code>Common Module Definition</code>，即 <em>通用模块定义</em>。<code>CMD</code> 是 <code>SeaJS</code> 在推广过程中对模块定义的规范化产出。</p><p>CMD规范和AMD类似，都主要运行于浏览器端，写法上看起来也很类似。主要是区别在于 <strong>模块初始化时机</strong></p><ul><li><strong>AMD中只要模块作为依赖时，就会加载并初始化</strong></li><li><strong>CMD中，模块作为依赖且被引用时才会初始化，否则只会加载。</strong></li><li><code>CMD</code> 推崇依赖就近，<code>AMD</code> 推崇依赖前置。</li><li><code>AMD</code> 的 <code>API</code> 默认是一个当多个用，<code>CMD</code> 严格的区分推崇职责单一。例如，<code>AMD</code> 里 <code>require</code> 分全局的和局部的。CMD里面没有全局的 <code>require</code>，提供 <code>seajs.use()</code> 来实现模块系统的加载启动。<code>CMD</code> 里每个 <code>API</code> 都简单纯粹。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AMD</span></span><br><span class="line">define([<span class="string">'./a'</span>,<span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//依赖一开始就写好</span></span><br><span class="line">    a.test();</span><br><span class="line">    b.test();</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">requie, exports, module</span>) </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//依赖可以就近书写</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">    a.test();</span><br><span class="line">     </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//软依赖</span></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = requie(<span class="string">'./b'</span>);</span><br><span class="line">        b.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Sea-js"><a href="#Sea-js" class="headerlink" title="Sea.js"></a>Sea.js</h3><ul><li><a href="https://github.com/seajs/seajs" target="_blank" rel="noopener">Sea.js Github Page</a></li><li><a href="https://www.douban.com/note/283566440/" target="_blank" rel="noopener">SeaJS与RequireJS最大的区别</a></li></ul><p>使用Sea.js，在书写文件时，需要遵守CMD（Common Module Definition）模块定义规范。一个文件就是一个模块。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ul><li>通过 <code>exports</code> 暴露接口。这意味着不需要命名空间了，更不需要全局变量。这是一种彻底的命名冲突解决方案。</li><li>通过 <code>require</code> 引入依赖。这可以让依赖内置，开发者只需关心当前模块的依赖，其他事情 <code>Sea.js</code> 都会自动处理好。对模块开发者来说，这是一种很好的 关注度分离，能让程序员更多地享受编码的乐趣。</li><li>通过 <code>define</code> 定义模块，更多详情参考<a href="http://wiki.jikexueyuan.com/project/hello-seajs/usage-guide.html" target="_blank" rel="noopener">SeasJS | 极客学院</a>。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>例如，对于下述<code>util.js</code>代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var org = &#123;&#125;;</span><br><span class="line">org.CoolSite = &#123;&#125;;</span><br><span class="line">org.CoolSite.Utils = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">org.<span class="module-access"><span class="module"><span class="identifier">CoolSite</span>.</span><span class="module"><span class="identifier">Utils</span>.</span></span>each = <span class="keyword">function</span> (arr) &#123;</span><br><span class="line">  <span class="comment">// 实现代码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">org.<span class="module-access"><span class="module"><span class="identifier">CoolSite</span>.</span><span class="module"><span class="identifier">Utils</span>.</span></span>log = <span class="keyword">function</span> (str) &#123;</span><br><span class="line">  <span class="comment">// 实现代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以采用SeaJS重写为</p><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">define(<span class="function"><span class="keyword">function</span><span class="params">(require, exports)</span> &#123;</span></span><br><span class="line">  exports.each = <span class="function"><span class="keyword">function</span> <span class="params">(arr)</span> &#123;</span></span><br><span class="line">    <span class="comment">// 实现代码</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  exports.<span class="built_in">log</span> = <span class="function"><span class="keyword">function</span> <span class="params">(str)</span> &#123;</span></span><br><span class="line">    <span class="comment">// 实现代码</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过 <code>exports</code> 就可以向外提供接口。通过 <code>require(&#39;./util.js&#39;)</code> 就可以拿到 <code>util.js</code> 中通过 <code>exports</code> 暴露的接口。这里的 <code>require</code>  可以认为是 <code>Sea.js</code> 给 JavaScript 语言增加的一个语法关键字，<strong>通过 <code>require</code> 可以获取其他模块提供的接口。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'./util.js'</span>);</span><br><span class="line">  exports.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 实现代码</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="SeaJS与RequireJS区别"><a href="#SeaJS与RequireJS区别" class="headerlink" title="SeaJS与RequireJS区别"></a>SeaJS与RequireJS区别</h2><p>二者区别主要表现在<strong>模块初始化时机</strong></p><ul><li><strong>AMD（RequireJS）中只要模块作为依赖时，就会加载并初始化。即尽早地执行（依赖）模块。相当于所有的require都被提前了，而且模块执行的顺序也不一定100%就是require书写顺序。</strong></li><li><strong>CMD（SeaJS）中，模块作为依赖且被引用时才会初始化，否则只会加载。即只会在模块真正需要使用的时候才初始化。模块加载的顺序是严格按照require书写的顺序。</strong></li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/front-end-2019/amd-cmd-nodek.png" alt="amd-cmd-nodek"></p><p>从规范上来说，AMD 更加简单且严谨，适用性更广，而在RequireJS强力的推动下，在国外几乎成了事实上的异步模块标准，各大类库也相继支持AMD规范。</p><p>但从SeaJS与CMD来说，也做了很多不错东西：1、相对自然的依赖声明风格 2、小而美的内部实现 3、贴心的外围功能设计 4、更好的中文社区支持。</p><h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><ul><li><code>UMD</code> = <code>Universal Module Definition</code>，即通用模块定义。<code>UMD</code> 是<code>AMD</code> 和 <code>CommonJS</code>的糅合。</li></ul><blockquote><p><code>AMD</code> 模块以浏览器第一的原则发展，异步加载模块。<br><code>CommonJS</code> 模块以服务器第一原则发展，选择同步加载。它的模块无需包装(unwrapped modules)。<br>这迫使人们又想出另一个更通用的模式 <code>UMD</code>（Universal Module Definition)，实现跨平台的解决方案。</p></blockquote><ul><li><code>UMD</code> 先判断是否支持 <code>Node.js</code> 的模块（<code>exports</code>）是否存在，存在则使用 <code>Node.js</code> 模块模式。再判断是否支持 <code>AMD</code>（<code>define</code> 是否存在），存在则使用 <code>AMD</code> 方式加载模块。</li></ul><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">function</span> (<span class="name">window</span>, factory) &#123;</span><br><span class="line">    if (<span class="name">typeof</span> exports === 'object') &#123;</span><br><span class="line">     </span><br><span class="line">        module.exports = factory()<span class="comment">;</span></span><br><span class="line">    &#125; else if (<span class="name">typeof</span> define === 'function' &amp;&amp; define.amd) &#123;</span><br><span class="line">     </span><br><span class="line">        define(<span class="name">factory</span>)<span class="comment">;</span></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     </span><br><span class="line">        window.eventUtil = factory()<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="name">this</span>, function () &#123;</span><br><span class="line">    //module ...</span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h2><h3 id="ES6模块和CommonJS区别"><a href="#ES6模块和CommonJS区别" class="headerlink" title="ES6模块和CommonJS区别"></a>ES6模块和CommonJS区别</h3><ul><li><strong>ES6 模块输出的是值的引用，输出接口动态绑定，而 <code>CommonJS</code> 输出的是值的拷贝。</strong></li><li><strong><code>CommonJS</code> 模块是运行时加载，ES6 模块是编译时输出接口。</strong></li></ul><h4 id="CommonJS-输出值的拷贝"><a href="#CommonJS-输出值的拷贝" class="headerlink" title="CommonJS 输出值的拷贝"></a>CommonJS 输出值的拷贝</h4><p><strong>CommonJS 模块输出的是值的拷贝（类比于基本类型和引用类型的赋值操作）。对于基本类型，一旦输出，模块内部的变化影响不到这个值。对于引用类型，效果同引用类型的赋值操作。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'David'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    obj.name = <span class="string">'Peter'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    counter: counter,</span><br><span class="line">    obj: obj,</span><br><span class="line">    changeValue: changeValue,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">var <span class="built_in">mod</span> = require(<span class="string">'./lib'</span>);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">mod</span>.counter);  <span class="comment">// 3</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">mod</span>.obj.<span class="built_in">name</span>);  <span class="comment">//  'David'</span></span><br><span class="line"><span class="built_in">mod</span>.changeValue();</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">mod</span>.counter);  <span class="comment">// 3</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">mod</span>.obj.<span class="built_in">name</span>);  <span class="comment">//  'Peter'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Or</span></span><br><span class="line">console.<span class="built_in">log</span>(require(<span class="string">'./lib'</span>).counter);  <span class="comment">// 3</span></span><br><span class="line">console.<span class="built_in">log</span>(require(<span class="string">'./lib'</span>).obj.<span class="built_in">name</span>);  <span class="comment">//  'Peter'</span></span><br></pre></td></tr></table></figure><ul><li><code>counter</code> 是基本类型值，模块内部值的变化不影响输出的值变化。</li><li><code>obj</code> 是引用类型值，模块内部值的变化影响输出的值变化。</li><li>上述两点区别，类比于基本类型和引用类型的赋值操作。</li></ul><p>也可以借助取值函数（<code>getter</code>），将 <code>counter</code> 转为引用类型值，效果如下。</p><blockquote><p>在类的内部，可以使用 <code>get</code> 和 <code>set</code> 关键字，对某个属性设置存执函数和取值函数，拦截该属性的存取行为。 —— <a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">class | 阮一峰</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="keyword">get</span> counter() &#123;</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line">  &#125;,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">var <span class="built-in">mod</span> = require(<span class="string">'./lib'</span>);</span><br><span class="line"></span><br><span class="line">console.<span class="built-in">log</span>(<span class="built-in">mod</span>.counter);  <span class="comment">// 3</span></span><br><span class="line"><span class="built-in">mod</span>.incCounter();</span><br><span class="line">console.<span class="built-in">log</span>(<span class="built-in">mod</span>.counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4 id="ES6-输出值的引用"><a href="#ES6-输出值的引用" class="headerlink" title="ES6 输出值的引用"></a>ES6 输出值的引用</h4><p>ES6 模块是动态关联模块中的值，输出的是值得引用。<strong>原始值变了，<code>import</code> 加载的值也会跟着变。</strong></p><blockquote><p><code>ES6</code> 模块的运行机制与 <code>CommonJS</code> 不一样。JS 引擎对脚本静态分析时，遇到模块加载命令 <code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。<strong>ES6 模块中，原始值变了，<code>import</code> 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值</strong>。  —— <a href="http://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="noopener">ES6 Module 的加载实现 | 阮一峰</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4 id="CommonJS-运行时加载-ES6静态编译"><a href="#CommonJS-运行时加载-ES6静态编译" class="headerlink" title="CommonJS 运行时加载 ES6静态编译"></a>CommonJS 运行时加载 ES6静态编译</h4><p><code>CommonJS</code> 模块是运行时加载，ES6 模块是编译时输出接口。</p><p>这是因为，<strong><code>CommonJS</code> 加载的是一个对象</strong>（即 <code>module.exports</code> 属性），该对象只有在脚本运行完才会生成。而 <strong><code>ES6</code> 模块不是对象</strong>，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><p>ES6 模块是编译时输出接口，因此有如下2个特点</p><ul><li><code>import</code> 命令会被 JS 引擎静态分析，优先于模块内的其他内容执行</li><li><code>export</code> 命令会有变量声明提升的效果</li></ul><h5 id="import-优先执行"><a href="#import-优先执行" class="headerlink" title="import 优先执行"></a>import 优先执行</h5><p>在文件中的任何位置引入 <code>import</code> 模块都会被提前到文件顶部</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.js'</span>)</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b.js 先执行'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果:</span></span><br><span class="line"><span class="comment">// b.js 先执行</span></span><br><span class="line"><span class="comment">// a.js</span></span><br></pre></td></tr></table></figure><p>虽然 <code>a</code> 模块中 <code>import</code> 引入晚于 <code>console.log(&#39;a&#39;)</code>，但是它被 JS 引擎通过静态分析，提到模块执行的最前面，优于模块中的其他部分的执行。</p><h5 id="export-命令变量提升效果"><a href="#export-命令变量提升效果" class="headerlink" title="export 命令变量提升效果"></a>export 命令变量提升效果</h5><p>由于 <code>import</code> 和 <code>export</code> 是静态执行，所以 <code>import</code> 和 <code>export</code> 具有变量提升效果。即 <code>import</code> 和 <code>export</code> 命令在模块中的位置并不影响程序的输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.js'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar3'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> a <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果:</span></span><br><span class="line"><span class="comment">// &#123; bar: undefined, bar2: undefined, bar3: [Function: bar3] &#125;</span></span><br><span class="line"><span class="comment">// a.js</span></span><br></pre></td></tr></table></figure><p><code>a</code> 模块引用了 <code>b</code> 模块，<code>b</code> 模块也引用了 <code>a</code> 模块，<code>export</code> 声明的变量也是优于模块其它内容的执行的。但具体对变量赋值需要等到执行到相应代码的时候。</p><h3 id="ES6模块和CommonJS相同点"><a href="#ES6模块和CommonJS相同点" class="headerlink" title="ES6模块和CommonJS相同点"></a>ES6模块和CommonJS相同点</h3><h4 id="模块不会重复执行"><a href="#模块不会重复执行" class="headerlink" title="模块不会重复执行"></a>模块不会重复执行</h4><p>重复引入某个相同的模块时，模块只会执行一次。</p><h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><h4 id="CommonJS-模块循环依赖"><a href="#CommonJS-模块循环依赖" class="headerlink" title="CommonJS 模块循环依赖"></a>CommonJS 模块循环依赖</h4><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在 <code>require</code> 的时候，就会全部执行。一旦出现某个模块被“循环加载”，<strong>就只输出已经执行的部分，还未执行的部分不会输出。</strong></p><h5 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo 1"></a>Demo 1</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'在 a.js 之中，b.done = %j'</span>, b.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.js 执行完毕'</span>);</span><br></pre></td></tr></table></figure><p>上面代码之中，<code>a.js</code> 脚本先输出一个 <code>done</code> 变量，然后加载另一个脚本文件 <code>b.js</code>。注意，此时 <code>a.js</code> 代码就停在这里，等待 <code>b.js</code> 执行完毕，再往下执行。</p><p>再看 <code>b.js</code> 的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b.js</span></span><br><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'在 b.js 之中，a.done = %j'</span>, a.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b.js 执行完毕'</span>);</span><br></pre></td></tr></table></figure><p>上面代码之中，<code>b.js</code> 执行到第二行，就会去加载 <code>a.js</code>，这时，就发生了“循环加载”。系统会 <code>a.js</code> 模块对应对象的 <code>exports</code> 属性取值，可是因为 <code>a.js</code> 还没有执行完，从 <code>exports</code> 属性只能取回已经执行的部分，而不是最后的值。</p><p><code>a.js</code> 已经执行的部分，只有一行。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">exports.done</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>因此，对于 <code>b.js</code>来说，它从 <code>a.js</code> 只输入一个变量 <code>done</code>，值为 <code>false</code>。</p><p>然后，<strong><code>b.js</code> 接着往下执行，等到全部执行完毕，再把执行权交还给 <code>a.js</code></strong>。于是，<code>a.js</code> 接着往下执行，直到执行完毕。我们写一个脚本 <code>main.js</code>，验证这个过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'在 main.js 之中, a.done=%j, b.done=%j'</span>, a.done, b.done);</span><br></pre></td></tr></table></figure><p>执行 <code>main.js</code>，运行结果如下。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line"></span><br><span class="line">在 <span class="selector-tag">b</span><span class="selector-class">.js</span> 之中，<span class="selector-tag">a</span><span class="selector-class">.done</span> = false</span><br><span class="line"><span class="selector-tag">b</span><span class="selector-class">.js</span> 执行完毕</span><br><span class="line">在 <span class="selector-tag">a</span><span class="selector-class">.js</span> 之中，<span class="selector-tag">b</span><span class="selector-class">.done</span> = true</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.js</span> 执行完毕</span><br><span class="line">在 main<span class="selector-class">.js</span> 之中, <span class="selector-tag">a</span>.done=true, <span class="selector-tag">b</span>.done=true</span><br></pre></td></tr></table></figure><p>上面的代码证明了2点</p><ul><li>在 <code>b.js</code> 之中，<code>a.js</code> 没有执行完毕，只执行了第一行</li><li><code>main.js</code> 执行到第二行时，不会再次执行 <code>b.js</code>，而是输出缓存的 <code>b.js</code> 的执行结果，即它的第四行。</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">exports.done</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>总之，<strong>CommonJS 输入的是被输出值的拷贝，不是引用。</strong></p><p>另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>); <span class="comment">// 安全的写法 导入整体，保证module已经执行完成</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">'a'</span>).foo; <span class="comment">// 危险的写法</span></span><br><span class="line"></span><br><span class="line">exports.good = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.foo(<span class="string">'good'</span>, arg); <span class="comment">// 使用的是 a.foo 的最新值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.bad = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> foo(<span class="string">'bad'</span>, arg); <span class="comment">// 使用的是一个部分加载时的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，如果发生循环加载，<code>require(&#39;a&#39;).foo</code> 的值很可能后面会被改写，改用 <code>require(&#39;a&#39;)</code> 会更保险一点。</p><h5 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo 2"></a>Demo 2</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a starting'</span>);</span><br><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in a, b.done ='</span>, b.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a done'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b starting'</span>);</span><br><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in b, a.done ='</span>, a.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b done'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// node a.js</span></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// a starting</span></span><br><span class="line"><span class="comment">// b starting</span></span><br><span class="line"><span class="comment">// in b, a.done = false</span></span><br><span class="line"><span class="comment">// b done</span></span><br><span class="line"><span class="comment">// in a, b.done = true</span></span><br><span class="line"><span class="comment">// a done</span></span><br></pre></td></tr></table></figure><p>从上面的执行过程中，可以看到，在 CommonJS 规范中，当遇到 <code>require()</code> 语句时，会执行 <code>require</code> 模块中的代码，<strong>并缓存执行的结果，当下次再次加载时不会重复执行，而是直接取缓存的结果。正因为此，出现循环依赖时才不会出现无限循环调用的情况。</strong></p><h4 id="ES6-模块循环依赖"><a href="#ES6-模块循环依赖" class="headerlink" title="ES6 模块循环依赖"></a>ES6 模块循环依赖</h4><p><strong>跟 CommonJS 模块一样，ES6 不会再去执行重复加载的模块，又由于 ES6 动态输出绑定的特性，能保证 ES6 在任何时候都能获取其它模块当前的最新值。</strong></p><h3 id="动态-import"><a href="#动态-import" class="headerlink" title="动态 import()"></a>动态 import()</h3><p>ES6 模块在编译时就会静态分析，<strong>优先于模块内的其他内容执行</strong>，所以导致了我们无法写出像下面这样的代码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">some</span> condition) &#123;</span><br><span class="line">  <span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="keyword">or</span> </span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> (str + <span class="string">'b'</span>);</span><br></pre></td></tr></table></figure><p>因为编译时静态分析，导致了我们无法在条件语句或者拼接字符串模块，因为这些都是需要在运行时才能确定的结果在 ES6 模块是不被允许的，所以 动态引入<code>import()</code> 应运而生。</p><p><code>import()</code> 允许你在运行时动态地引入 ES6 模块，想到这，你可能也想起了 <code>require.ensure</code> 这个语法，但是它们的用途却截然不同的。</p><p><code>require.ensure</code> 的出现是 <code>webpack</code> 的产物，它是因为浏览器需要一种异步的机制可以用来异步加载模块，从而减少初始的加载文件的体积，所以如果在服务端的话， <code>require.ensure</code> 就无用武之地了，因为服务端不存在异步加载模块的情况，模块同步进行加载就可以满足使用场景了。 CommonJS 模块可以在运行时确认模块加载。</p><p>而 <code>import()</code> 则不同，它主要是为了解决 ES6 模块无法在运行时确定模块的引用关系，所以需要引入 <code>import()</code>。</p><p>先来看下它的用法</p><ul><li>动态的 <code>import()</code> 提供一个基于 <code>Promise</code> 的 <code>API</code></li><li>动态的 <code>import()</code> 可以在脚本的任何地方使用 <code>import()</code> 接受字符串文字，可以根据需要构造说明符</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'./b'</span>;</span><br><span class="line"><span class="keyword">const</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./b'</span>).then(<span class="function">(<span class="params">&#123;foo&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span>(str).then(<span class="function">(<span class="params">&#123;foo&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// babel-node a.js</span></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure><p>当然，如果在浏览器端的 <code>import()</code> 的用途就会变得更广泛，比如 按需异步加载模块，那么就和 <code>require.ensure</code> 功能类似了。</p><p>因为是基于 <code>Promise</code> 的，所以如果你想要同时加载多个模块的话，可以是 <code>Promise.all</code> 进行并行异步加载。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./a.js'</span>),</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./b.js'</span>),</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./c.js'</span>),</span><br><span class="line">]).<span class="keyword">then</span>(<span class="function"><span class="params">([a, &#123;<span class="keyword">default</span>: b&#125;, &#123;c&#125;])</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a.js is loaded dynamically'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b.js is loaded dynamically'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'c.js is loaded dynamically'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还有 <code>Promise.race</code> 方法，它检查哪个 <code>Promise</code> 被首先 <code>resolved</code> 或 <code>reject</code>。我们可以使用 <code>import()</code> 来检查哪个 <code>CDN</code> 速度更快：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CDNs = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'jQuery.com'</span>,</span><br><span class="line">    url: <span class="string">'https://code.jquery.com/jquery-3.1.1.min.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'googleapis.com'</span>,</span><br><span class="line">    url: <span class="string">'https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`------`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`jQuery is: <span class="subst">$&#123;<span class="built_in">window</span>.jQuery&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">  <span class="keyword">import</span>(CDNs[<span class="number">0</span>].url).then(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(CDNs[<span class="number">0</span>].name, <span class="string">'loaded'</span>)),</span><br><span class="line">  <span class="keyword">import</span>(CDNs[<span class="number">1</span>].url).then(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(CDNs[<span class="number">1</span>].name, <span class="string">'loaded'</span>))</span><br><span class="line">]).then(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`jQuery version: <span class="subst">$&#123;<span class="built_in">window</span>.jQuery.fn.jquery&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然，如果你觉得这样写还不够优雅，也可以结合 <code>async/await</code> 语法糖来使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> myModule = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./myModule.js'</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123;export1, export2&#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./myModule.js'</span>);</span><br><span class="line">  <span class="keyword">const</span> [module1, module2, module3] =</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">'./module1.js'</span>),</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">'./module2.js'</span>),</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">'./module3.js'</span>),</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态 <code>import()</code> 为我们提供了以异步方式使用 ES 模块的额外功能。</p><p>根据我们的需求动态或有条件地加载它们，这使我们能够更快，更好地创建更多优势应用程序。</p><h2 id="webpack中加载3种模块-语法"><a href="#webpack中加载3种模块-语法" class="headerlink" title="webpack中加载3种模块 | 语法"></a>webpack中加载3种模块 | 语法</h2><p>Webpack允许使用不同的模块类型，但是<code>底层</code>必须使用同一种实现。所有的模块可以直接在盒外运行。</p><ul><li>ES6 模块</li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MyModule <span class="keyword">from</span> <span class="string">'./MyModule.js'</span>;</span><br></pre></td></tr></table></figure><ul><li>CommonJS(Require)</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var MyModule</span> = require(<span class="string">'./MyModule.js'</span>);</span><br></pre></td></tr></table></figure><ul><li>AMD</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'./MyModule.js'</span>], <span class="function"><span class="keyword">function</span> <span class="params">(MyModule)</span> </span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;对 JS 常见的模块化方案进行介绍和比较——&lt;code&gt;CommonJS&lt;/code&gt; &lt;code&gt;AMD&lt;/code&gt; &lt;code&gt;CMD&lt;/code&gt; &lt;code&gt;ES6 Module&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对 &lt;code&gt;ES6 Module&lt;/code&gt; 和 &lt;code&gt;CommonJS&lt;/code&gt; 的差异进行对比，介绍循环依赖和动态 &lt;code&gt;import()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Front-End Develop" scheme="https://lbs0912.github.io/categories/Front-End-Develop/"/>
    
    
      <category term="Front-End Developer" scheme="https://lbs0912.github.io/tags/Front-End-Developer/"/>
    
      <category term="JS" scheme="https://lbs0912.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>HomePageImage</title>
    <link href="https://lbs0912.github.io/2018/09/12/home-page-img/"/>
    <id>https://lbs0912.github.io/2018/09/12/home-page-img/</id>
    <published>2018-09-12T08:50:21.000Z</published>
    <updated>2019-11-09T15:38:22.409Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/Blog-20190315/my-riding-bike.jpg" alt="my-riding-bike"></div><div class="group-picture-column" style="width: 50%;"><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/Blog-20190315/football.jpg" alt="football"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/Blog-20190315/sjtu-title-3.jpg" alt="sjtu-title-3"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/Blog-20190315/front-end-logo-1.jpg" alt="front-end-logo-1"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/Blog-20190315/java-c-vs.jpg" alt="java-c-vs123"></div></div></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo Blog 搭建与配置</title>
    <link href="https://lbs0912.github.io/2016/03/10/blog-configure/"/>
    <id>https://lbs0912.github.io/2016/03/10/blog-configure/</id>
    <published>2016-03-10T06:35:26.000Z</published>
    <updated>2019-11-09T15:50:33.844Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录 <code>Hexo Blog</code> 的搭建与配置</li><li>对 <code>Next</code> 主题进行定制，添加搜索，统计，置顶，加密阅读，自定义CSS等</li></ul><a id="more"></a><h2 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h2><ul><li>2018/08/23，撰写</li><li>2018/09/04，整理</li><li>2018/09/25，添加 <code>Font Awesome</code>使用</li><li>2019/03/18，添加文章加密阅读</li><li>本博客全部配置信息可在 <a href="https://github.com/lbs0912/BlogSpace" target="_blank" rel="noopener">BlogSpace | lbs0912-github</a> 查看</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><h3 id="Hexo-基础使用"><a href="#Hexo-基础使用" class="headerlink" title="Hexo 基础使用"></a>Hexo 基础使用</h3><ul><li><a href="https://wsgzao.github.io/post/hexo-guide/" target="_blank" rel="noopener">使用GitHub和Hexo搭建免费静态Blog</a></li><li><a href="http://ehlxr.me/2016/08/30/%E4%BD%BF%E7%94%A8Hexo%E5%9F%BA%E4%BA%8EGitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89/" target="_blank" rel="noopener">使用Hexo基于GitHub-Pages搭建个人博客（三）</a></li></ul><h3 id="Blog-进阶管理"><a href="#Blog-进阶管理" class="headerlink" title="Blog 进阶管理"></a>Blog 进阶管理</h3><ul><li><a href="https://theme-next.iissnan.com/" target="_blank" rel="noopener">Next Theme 官方配置手册</a></li><li><a href="http://feg.netease.com/archives/634.html" target="_blank" rel="noopener">如何更好地对hexo博客管理</a></li><li><a href="http://blog.junyu.io/posts/0010-hexo-learn-from-Never-yu.html#background" target="_blank" rel="noopener">Hexo 博客进阶配置</a></li><li><a href="https://zhuanlan.zhihu.com/p/33616481" target="_blank" rel="noopener">Hexo搭建的GitHub博客之优化大全</a></li><li><a href="https://timding.top/2017/09/18/Hexo-NexT-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%86%8C-%E4%BA%8C/" target="_blank" rel="noopener">Next Theme 相册配置</a> </li><li><a href="https://juejin.im/post/5b8bc953518825284910dcdd" target="_blank" rel="noopener">搭建Hexo 相册</a></li></ul><h3 id="优质博客参考"><a href="#优质博客参考" class="headerlink" title="优质博客参考"></a>优质博客参考</h3><ul><li><a href="https://sunmengyuan.github.io/garden/" target="_blank" rel="noopener">Sunmengyuan Blog</a></li><li><a href="http://zhangwenli.com/" target="_blank" rel="noopener">羡辙 Blog</a></li><li><a href="https://www.byvoid.com/" target="_blank" rel="noopener">BYvoid</a></li></ul><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><blockquote><p>Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds.   — <a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo</a></p></blockquote><p>参考 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo官网</a>了解Hexo更多信息。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install </span>hexo-cli -g</span><br><span class="line">mkdir <span class="keyword">Blog </span>&amp;&amp; cd <span class="keyword">Blog</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">hexo </span>init <span class="keyword">blog</span></span><br><span class="line"><span class="keyword">cd </span><span class="keyword">blog</span></span><br><span class="line"><span class="keyword">npm </span><span class="keyword">install</span></span><br><span class="line"><span class="keyword">hexo </span>server</span><br></pre></td></tr></table></figure><p>Hexo生成的目录结构如下</p><ul><li><code>.deploy</code> :  需要部署的文件</li><li><code>node_modules</code></li><li><code>public</code>:  生成的静态网页文件</li><li><code>scaffolds</code>:  模板</li><li><code>source</code>: 博客正文和其他源文件，404，favicon，CNAME<ul><li><code>_drafts</code>:  草稿</li><li><code>_posts</code>:  文章</li></ul></li><li><code>themes</code>:  主题</li><li><code>_config.yml</code>:  全局配置文件</li><li><code>package.json</code></li></ul><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">hexo new page archive</span><br><span class="line"><span class="comment"># 创建分类目录并初始化index.md  等同于  hexo n</span></span><br><span class="line"></span><br><span class="line">hexo server    </span><br><span class="line"><span class="comment"># run hexo server  等同于  hexo s</span></span><br><span class="line"></span><br><span class="line">hexo generate  </span><br><span class="line"><span class="comment"># Generate static files   等同于  hexo g</span></span><br><span class="line"></span><br><span class="line">hexo deploy   </span><br><span class="line"><span class="comment"># Deploy to remote sites   等同于  hexo d</span></span><br><span class="line"></span><br><span class="line">hexo clean  <span class="comment"># 清空缓存文件</span></span><br><span class="line">hexo -v     <span class="comment"># 查看hexo版本</span></span><br><span class="line">hexo <span class="built_in">help</span>   <span class="comment"># 查看hexo帮助</span></span><br><span class="line">hexo d -g   <span class="comment"># 生成部署  组合命令</span></span><br><span class="line">hexo s -g   <span class="comment"># 生成预览  组合命令</span></span><br><span class="line">hexo s --debug  <span class="comment"># 本地预览，并开启调试模式</span></span><br></pre></td></tr></table></figure><p>在后续博文发布时，依次执行如下命令</p><ul><li><code>hexo clean</code>: 清空缓存文件</li><li><code>hexo g</code>: 编译产生静态文件</li><li><code>hexo s</code>: 本地预览，可选</li><li><code>hexo d</code>: 部署到服务端</li></ul><h2 id="Hexo-to-GitHub"><a href="#Hexo-to-GitHub" class="headerlink" title="Hexo to GitHub"></a>Hexo to GitHub</h2><h3 id="创建GitHub仓库"><a href="#创建GitHub仓库" class="headerlink" title="创建GitHub仓库"></a>创建GitHub仓库</h3><ul><li>创建一个仓库，并命名为 <code>YourAccountName.github.io</code>（此处以<code>lbs0912.github.io</code>为例）</li><li>设置仓库属性，选择 <code>GitHub Page</code> 的主题，访问 <code>https://lbs0912.github.io/</code>进行预览</li></ul><h3 id="同步内容至-GitHub"><a href="#同步内容至-GitHub" class="headerlink" title="同步内容至 GitHub"></a>同步内容至 GitHub</h3><p>在Hexo安装目录下打开 <code>_config.yml</code> 文件，进行如下修改</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Deployment</span></span><br><span class="line"><span class="meta">## Docs: https:<span class="comment">//hexo.io/docs/deployment.html</span></span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repository:</span> https:<span class="comment">//github.com/lbs0912/lbs0912.github.io.git</span></span><br><span class="line"><span class="symbol">  branch:</span> master</span><br></pre></td></tr></table></figure><blockquote><p>该配置文件遵循 <code>Yaml</code> 语法，<code>type:</code> 和 <code>git</code> 中间需有一空格。</p></blockquote><p>对静态网页的标题，子标题，介绍，时区等内容进行如下设置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Liu</span> <span class="string">Baoshuai's</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">Do</span> <span class="string">one</span> <span class="string">thing</span> <span class="string">at</span> <span class="string">a</span> <span class="string">time</span> <span class="string">and</span> <span class="string">do</span> <span class="string">well.</span>  </span><br><span class="line"><span class="attr">description:</span> <span class="string">Record</span> <span class="string">and</span> <span class="string">become</span> <span class="string">better</span> <span class="string">myself.</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Liu</span> <span class="string">Baoshuai</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">https://lbs0912.github.io/</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="string">//...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br></pre></td></tr></table></figure><p>配置文件修改完成后，输入如下命令，将更新后的内容同步至GitHub。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-deployer-git --save  <span class="comment">#deploy to git  </span></span><br><span class="line"></span><br><span class="line">hexo clean      </span><br><span class="line">hexo generate    <span class="comment"># or hexo g</span></span><br><span class="line">hexo deploy      <span class="comment"># or hexo d</span></span><br></pre></td></tr></table></figure><p>打开 <code>https://lbs0912.github.io/</code> 可以访问博客界面。</p><h2 id="域名和DNS"><a href="#域名和DNS" class="headerlink" title="域名和DNS"></a>域名和DNS</h2><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>申请域名用于博客访问。此处申请域名 <code>liubaoshuai.com</code>。</p><blockquote><p>已申请的域名包括</p><ul><li><code>liubaoshuai.com</code></li><li><code>liubaoshuai.tech</code></li></ul></blockquote><h3 id="设置CNAME"><a href="#设置CNAME" class="headerlink" title="设置CNAME"></a>设置CNAME</h3><p>在Hexo的安装目录下的 <code>source</code> 目录下，创建 <code>CNAME</code> 文件，并存入申请的域名 <code>liubaoshuai.com</code>。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>推荐使用 <a href="https://www.dnspod.cn/" target="_blank" rel="noopener">DNSPod</a> 进行DNS解析。</p><p>此处，由于域名 <code>http://liubaoshuai.com/</code> 在阿里云购买，故使用阿里云的 DNS 云解析。DNS 界面进行如下设置。</p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>记录值</th></tr></thead><tbody><tr><td>CNAME</td><td>www</td><td>lbs0912.github.io</td></tr><tr><td>A</td><td>@</td><td>192.30.252.154</td></tr><tr><td>A</td><td>@</td><td>192.30.252.153</td></tr></tbody></table><blockquote><p><a href="https://help.github.com/en/articles/troubleshooting-custom-domains#dns-configuration-errors" target="_blank" rel="noopener">DNS Update | github</a></p></blockquote><p>其中A记录为GitHub Page提供的IP地址，可以访问 <a href="https://help.github.com/articles/github-s-ip-addresses/" target="_blank" rel="noopener">GitHub Page</a> 查询最新 <code>IP</code> 地址。</p><p>最后，执行如下命令，并访问 <code>liubaoshuai.com</code> 查看修改效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  </span><br><span class="line">hexo g    <span class="comment"># or hexo generate</span></span><br><span class="line">hexo d    <span class="comment"># or hexo deploy</span></span><br></pre></td></tr></table></figure><ul><li>至此，便可通过访问 <code>liubaoshuai.com</code> 来访问自己的博客。</li><li>访问 <code>lbs0912.github.io</code>，会被重定向到 <code>liubaoshuai.com</code> 网址。</li></ul><h2 id="Blog-配置"><a href="#Blog-配置" class="headerlink" title="Blog 配置"></a>Blog 配置</h2><ul><li><strong><a href="https://theme-next.iissnan.com/" target="_blank" rel="noopener">Next Theme 官方配置手册</a></strong></li></ul><h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h3><p>安装Hexo插件来增强Hexo效果和美化页面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-deployer-git --save  <span class="comment">#deploy to git</span></span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-stylus --save</span><br><span class="line">npm install hexo-generator-feed --save   <span class="comment"># RSS</span></span><br><span class="line">npm install hexo-generator-sitemap --save <span class="comment">#sitemap</span></span><br></pre></td></tr></table></figure><h3 id="添加Meta信息"><a href="#添加Meta信息" class="headerlink" title="添加Meta信息"></a>添加Meta信息</h3><p><code>Hexo</code> 默认的文件头只有<code>title</code>、<code>date</code>、<code>tags</code> 属性，生成的 <code>html</code> 缺少 <code>Meta</code>信息，不利于搜索引擎收录。建议自行在文件头中添加 <code>keywords</code> 和 <code>description</code> 属性。<code>categories</code> 属性可自行选择是否添加。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="comment">##文章标题</span></span><br><span class="line"><span class="attr">date:</span> <span class="comment">##时间，格式为 YYYY-MM-DD HH:mm:ss</span></span><br><span class="line"><span class="attr">categories:</span> <span class="comment">##分类</span></span><br><span class="line"><span class="attr">tags:</span> <span class="comment">##标签，多标签格式为 [tag1,tag2,...]</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="comment">##文章关键词，多关键词格式为 keyword1,keywords2,...</span></span><br><span class="line"><span class="attr">description:</span> <span class="comment">##文章描述</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>文件头模板如上所示，一个文件头实例如下所示。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">这是一篇测试文章</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2015</span><span class="bullet">-03</span><span class="bullet">-21</span> <span class="number">15</span><span class="string">:13:48</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">[Hexo,测试]</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">Hexo,文章,测试</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">这是一篇测试文章，用于测试Hexo文章文件头。</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>需要注意的是，多个标签也可采用如下写法</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tags:</span></span><br><span class="line">  - Testing Tag</span><br><span class="line">  - Another Tag</span><br></pre></td></tr></table></figure><h3 id="分页功能"><a href="#分页功能" class="headerlink" title="分页功能"></a>分页功能</h3><p>在 Hexo 安装目录下打开 <code>_config.yml</code>，添加如下配置， 为博客添加分页功能。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Plugins</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="number">8</span> <span class="comment">##首页默认8篇文章标题，如果值为0不分页</span></span><br><span class="line"><span class="attr">  order_by:</span> <span class="bullet">-date</span></span><br><span class="line"><span class="attr">archive_generator:</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="number">8</span> <span class="comment">##归档页面默认8篇文章标题，如果值为0不分页</span></span><br><span class="line"><span class="attr">  yearly:</span> <span class="literal">true</span> <span class="comment">##生成年视图</span></span><br><span class="line"><span class="attr">  monthly:</span> <span class="literal">true</span> <span class="comment">##生成月视图</span></span><br><span class="line"><span class="attr">tag_generator:</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="number">8</span> <span class="comment">##标签页面默认8篇文章，如果值为0不分页</span></span><br><span class="line"><span class="attr">category_generator:</span> </span><br><span class="line"><span class="attr">  per_page:</span> <span class="number">8</span> <span class="comment">##分类页面默认8篇文章，如果值为0不分页</span></span><br></pre></td></tr></table></figure><h3 id="Hexo-主题配置"><a href="#Hexo-主题配置" class="headerlink" title="Hexo 主题配置"></a>Hexo 主题配置</h3><p>访问如下链接，查看 Hexo 主题列表</p><ul><li><a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo Themes List</a></li><li><a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">Hexo Themes List on GitHub</a> </li></ul><h4 id="Next-Theme"><a href="#Next-Theme" class="headerlink" title="Next Theme"></a>Next Theme</h4><ul><li>参考 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next Theme | github</a> 完成基本配置。</li><li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Next Theme Configure</a></li><li>参考 <a href="https://segmentfault.com/a/1190000009544924" target="_blank" rel="noopener">Next主题美化进阶 | Segmentfault</a> 进行定制。</li><li>Install</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd hexo</span><br><span class="line"><span class="variable">$ </span>git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/theme</span>-<span class="keyword">next</span>/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure><ul><li>将下载好的 <code>Huno</code> 主题放置在 <code>blog/themes</code> 目录下。修改 <code>Hexo</code> 配置文件<code>_config.xml</code></li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: <span class="keyword">next</span></span><br></pre></td></tr></table></figure><ul><li>Update</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd themes/<span class="keyword">next</span></span><br><span class="line"><span class="variable">$ </span>git pull</span><br></pre></td></tr></table></figure><ul><li>设置界面个人头像和网页收藏夹图标</li></ul><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Site favicon</span></span><br><span class="line"><span class="meta">#favicon: /favicon.png</span></span><br><span class="line">favicon: https:<span class="comment">//image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/Blog-20190315/blog-logo-1.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Site logo</span></span><br><span class="line"><span class="meta">#logo: /avatar.png</span></span><br><span class="line">logo: https:<span class="comment">//image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/Blog-20190315/blog-logo-1.jpg</span></span><br></pre></td></tr></table></figure><ul><li>作品设计参考网站<ul><li><a href="https://dribbble.com/" target="_blank" rel="noopener">Dribbble</a></li><li><a href="https://www.behance.net/" target="_blank" rel="noopener">Behance</a></li></ul></li></ul><h4 id="Huno-Theme"><a href="#Huno-Theme" class="headerlink" title="Huno Theme"></a>Huno Theme</h4><p>参考 <a href="https://github.com/letiantian/huno" target="_blank" rel="noopener">Huno Theme | github</a> 完成基本配置。</p><h3 id="集成第三方服务"><a href="#集成第三方服务" class="headerlink" title="集成第三方服务"></a>集成第三方服务</h3><ul><li><a href="https://theme-next.iissnan.com/getting-started.html#third-party-services" target="_blank" rel="noopener">Next Theme 官方配置手册</a></li></ul><h4 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h4><ul><li>用户名：15821929853</li><li>密码：Ab758123aB</li><li>百度统计-脚本 ID：17082ee15df20dad9762c5512f336eb2</li><li>登陆 <a href="https://tongji.baidu.com/web/homepage/index?castk=df83afg752126b970d267" target="_blank" rel="noopener">百度统计</a> 网站，可以查阅网站访问量</li></ul><h4 id="阅读次数统计-LeanCloud"><a href="#阅读次数统计-LeanCloud" class="headerlink" title="阅读次数统计 LeanCloud"></a>阅读次数统计 LeanCloud</h4><ul><li><a href="https://leancloud.cn/" target="_blank" rel="noopener">leancloud</a></li><li><a href="https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">LeanCloud 配置</a></li><li>使用 <code>Github</code> 第三方账登录 <code>leancloud</code></li><li>APP ID：gksxcfwJlMV3zkhz1pQc7pl2-gzGzoHsz</li><li>APP Key：kjOanp812G7TIGMSQpPCVIhj</li></ul><h4 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h4><ul><li><a href="https://theme-next.iissnan.com/third-party-services.html#algolia-search" target="_blank" rel="noopener">搜索服务配置</a></li></ul><p><code>NexT</code> 主题支持集成 <code>Swiftype</code>，<code>微搜索</code>，<code>Local Search</code> 和 <code>Algolia</code> 搜索功能。<code>Swiftype</code> 和 <code>Algolia</code> 均收费，可以采用 <code>Hexo</code> 提供的 <code>Local Search</code> 搜索服务，其原理是通过 <code>hexo-generator-searchdb</code> 插件在本地生成一个 <code>search.xml</code> 文件，搜索的时候从这个文件中根据关键字检索出相应的链接。</p><h4 id="博文分享功能"><a href="#博文分享功能" class="headerlink" title="博文分享功能"></a>博文分享功能</h4><ul><li><p><a href="https://blog.csdn.net/lanuage/article/details/78991798" target="_blank" rel="noopener">hexo next主题为博客添加分享功能</a></p></li><li><p>百度分享</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidushare:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">button</span>  <span class="comment"># 需要设置 type: button </span></span><br><span class="line"><span class="attr">  baidushare:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>likely 分享</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">likely:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  look:</span> <span class="string">light</span>  <span class="comment"># available values: normal, light, small, big</span></span><br><span class="line"><span class="attr">  networks:</span></span><br><span class="line"><span class="attr">    twitter:</span> <span class="string">Tweet</span></span><br><span class="line"><span class="attr">    facebook:</span> <span class="string">Share</span></span><br><span class="line"><span class="attr">    linkedin:</span> <span class="string">Link</span></span><br><span class="line">    <span class="comment">#gplus: Plus</span></span><br><span class="line">    <span class="comment">#vkontakte: Share</span></span><br><span class="line">    <span class="comment">#odnoklassniki: Class</span></span><br><span class="line">    <span class="comment">#telegram: Send</span></span><br><span class="line"><span class="attr">    whatsapp:</span> <span class="string">Send</span></span><br><span class="line">    <span class="comment">#pinterest: Pin</span></span><br></pre></td></tr></table></figure><h4 id="Disqus-评论"><a href="#Disqus-评论" class="headerlink" title="Disqus 评论"></a>Disqus 评论</h4><ul><li><p>使用谷歌账户登录Disqus</p></li><li><p>shortName：liubaoshuaiBlog</p></li><li><p>之后，在撰写文章时，顶部信息添加 <code>comments</code> 字段可控制是否展示评论</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Demo</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-03</span><span class="bullet">-10</span> <span class="number">14</span><span class="string">:35:26</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">Demo</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">[LeetCode,Programing,Algorithm]</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">LeetCode</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">top:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="404页面"><a href="#404页面" class="headerlink" title="404页面"></a>404页面</h3><ul><li>推荐使用 <a href="http://www.qq.com/404/" target="_blank" rel="noopener">腾讯公益404</a>，当然也可以自定义 404 页面，例如本博客采用的 404 页面。</li><li>在 <code>blog/source</code> 目录下创建 <code>404.html</code>，引入腾讯公益404脚本。(该效果需要部署到服务器才能预览，本地服务无法预览)</li></ul><h3 id="Fork-me-on-GitHub"><a href="#Fork-me-on-GitHub" class="headerlink" title="Fork me on GitHub"></a>Fork me on GitHub</h3><p>在 <a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="noopener">Fork me on GitHub Theme</a> 上获取源代码（有多种样式可选），并将 <code>&lt;a&gt;</code> 标签的 <code>href</code> 属性的链接修改为自己的 <a href="https://github.com/lbs0912" target="_blank" rel="noopener">GitHub-lbs0912</a> 地址。</p><p>以 Huno 主题为例，将上述代码添加到 <code>./themes/huno/layout/_layout.ejs</code> 文件的<code>&lt;body&gt;</code> 标签内即可。</p><blockquote><p>修改源代码中<code>img</code>标签的样式为<code>position:fixed</code>，可以将<code>Fork me on GitHub</code>固定于浏览器界面顶部。</p></blockquote><h3 id="背景音乐播放设置"><a href="#背景音乐播放设置" class="headerlink" title="背景音乐播放设置"></a>背景音乐播放设置</h3><p>参考 <a href="http://weqeo.com/2016/10/11/Hexo%E4%B8%AD%E6%92%AD%E6%94%BE%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%9A%84%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">Hexo中播放网易云音乐的实践</a> 完成该部分设置。</p><p>以 Huno 主题为例，将网易云音乐播放外链放置在 <code>./themes/next/layout/_macro/sidebar.swig</code> 文件中。</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (!is_home()) &#123; %&gt; </span><br><span class="line">    &lt;iframe frameborder="no" border="0" marginwidth="0" style="margin-top: 40px;" marginheight="0" width=330 height=86  src="//music.163.com/outchain/player?type=2&amp;id=394653&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="为-Blog-添加-README"><a href="#为-Blog-添加-README" class="headerlink" title="为 Blog 添加 README"></a>为 Blog 添加 README</h3><p>本博客中，使用了 <code>Github</code> 服务器作为托管，博客内容被存储到 <code>Github</code> 中。</p><p>一般情况下，需要给 <code>Github</code> 中每一个项目添加 <code>README.md</code> 文件进行说明。</p><p>但是，在 <code>Blog</code> 项目中，在 <code>blog\source</code> 目录下创建的 <code>README.md</code> 文件，会被 <code>hexo</code> 解析掉，并不会被部署到 <code>Github</code> 服务器上。</p><h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h4><ul><li>在博客 <code>Source</code> 目录下创建 <code>README.md</code> 文件</li><li>修改博客配置文件的 <code>skip_render</code> 字段如下 </li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: <span class="module-access"><span class="module"><span class="identifier">README</span>.</span></span>md</span><br></pre></td></tr></table></figure><h4 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h4><p>正确的解决方法如下。</p><ul><li>把 <code>README.md</code> 文件的后缀名改成 <code>.MDOWN</code></li><li>仍将该文件置于 <code>blog/source</code> 文件夹</li><li>这样可以保证 <code>hexo</code> 不会解析该文件，同时 <code>Github</code> 也会将其作为<code>.MD</code> 文件解析</li></ul><h3 id="背景效果优化"><a href="#背景效果优化" class="headerlink" title="背景效果优化"></a>背景效果优化</h3><p>此处介绍博客背景动态效果图的添加，以及鼠标点击界面出现心形图案的相关设置。</p><ul><li>下载 <a href="https://github.com/lbs0912/lbs0912.github.io/blob/master/js/src/love.js" target="_blank" rel="noopener">love.js</a> 和 <a href="https://github.com/lbs0912/lbs0912.github.io/blob/master/js/src/particle.js" target="_blank" rel="noopener">particle.js</a> 文件，将其存放至<code>\themes\huno\source\js\src</code>目录下。</li><li>在 <code>\themes\huno\layout\layout.ejs</code> 文件末尾，引入上述 2 个 js 文件。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 背景动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/particle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 页面点击小红心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/love.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h3><ul><li>修改 <code>./node_modules/hexo-generator-index/lib/generator.js</code> 文件的</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var posts</span> = locals.posts.sort(config.index_generator.order_by);</span><br></pre></td></tr></table></figure><p>为</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(function(a, b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="built_in">top</span> &amp;&amp; b.<span class="built_in">top</span>) &#123; // 两篇文章<span class="built_in">top</span>都有定义</span><br><span class="line">            <span class="keyword">if</span>(a.<span class="built_in">top</span> == b.<span class="built_in">top</span>) <span class="keyword">return</span> b.date - a.date; // 若<span class="built_in">top</span>值一样则按照文章日期降序排</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.<span class="built_in">top</span> - a.<span class="built_in">top</span>; // 否则按照<span class="built_in">top</span>值降序排</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.<span class="built_in">top</span> &amp;&amp; !b.<span class="built_in">top</span>) &#123; // 以下是只有一篇文章<span class="built_in">top</span>有定义，那么将有<span class="built_in">top</span>的排在前面（这里用异或操作居然不行<span class="number">233</span>）</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a.<span class="built_in">top</span> &amp;&amp; b.<span class="built_in">top</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; // 都没定义按照文章日期降序排</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ul><li>设置文章置顶：在文件的头部添加 <code>top</code> 值，<code>top</code> 值越大，文章越靠前。若两篇文章的 <code>top</code> 值一样，则按照默认的日期排序。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Webpack</span> <span class="string">Notes</span> <span class="bullet">-</span> <span class="number">1</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-01</span><span class="bullet">-19</span> <span class="number">11</span><span class="string">:15:48</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">Front-end</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">[Webpack,Front-end]</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">webpack,front-end</span> </span><br><span class="line"><span class="attr">top:</span> <span class="number">5</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="博文收起添加"><a href="#博文收起添加" class="headerlink" title="博文收起添加"></a>博文收起添加</h3><p>在 <code>.MD</code> 文件中添加如下标识。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure><ul><li>该标识前的会在博客首页展示（可以在该标识前添加简要说明）</li><li>该标识后的博文会被收起折叠。</li></ul><h3 id="文章加密阅读"><a href="#文章加密阅读" class="headerlink" title="文章加密阅读"></a>文章加密阅读</h3><ul><li><p>Ref - <a href="https://segmentfault.com/a/1190000009544924#articleHeader23" target="_blank" rel="noopener">next主题 - 文章加密阅读</a></p></li><li><p>打开 <code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</code> 文件，添加如下代码</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (<span class="string">'&#123;&#123; page.password &#125;&#125;'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (prompt(<span class="string">'请输入文章密码'</span>) !== <span class="string">'&#123;&#123; page.password &#125;&#125;'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                alert(<span class="string">'密码错误！'</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (history.length === <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                    location.replace(<span class="string">"http://xxxxxxx.xxx"</span>); <span class="comment">// 这里替换成你的首页</span></span></span><br><span class="line"><span class="actionscript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="undefined">                    history.back();</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>之后，在撰写文章时，顶部信息添加 <code>password</code> 字段即可</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Demo</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-03</span><span class="bullet">-10</span> <span class="number">14</span><span class="string">:35:26</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">Demo</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">[LeetCode,Programing,Algorithm]</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">LeetCode</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">top:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="定制CSS"><a href="#定制CSS" class="headerlink" title="定制CSS"></a>定制CSS</h3><ul><li>在 <code>.\themes\next\source\css\_custom\custom.styl</code> 文件中，添加自定义CSS样式。</li></ul><p>定制CSS样式后，可以使用如下效果。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"inline-blue"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">span</span>&gt;</span>， </span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"inline-purple"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"inline-green"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"inline-yellow"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-left-red"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-left-yellow"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-left-green"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-left-blue"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-left-purple"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-right-red"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-right-yellow"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-right-green"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-right-blue"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-right-purple"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-top-red"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-top-yellow"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-top-green"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-top-blue"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-top-purple"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"yu-1"</span>&gt;</span>动画<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"download"</span> <span class="attr">href</span>=<span class="string">"https://git-scm.com/download/win"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-download"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> Download Now<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">class</span>=<span class="string">"blockquote-center"</span>&gt;</span>引用居中效果<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="链接文本样式修改"><a href="#链接文本样式修改" class="headerlink" title="链接文本样式修改"></a>链接文本样式修改</h4><p>将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。打开<code>themes\next\source\css\_custom\custom.styl</code> 文件 ，添加如下 <code>css</code> 样式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Custom styles.</span></span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0477ab</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文字增加背景色块"><a href="#文字增加背景色块" class="headerlink" title="文字增加背景色块"></a>文字增加背景色块</h4><ul><li><p>参考 <a href="http://blog.junyu.pro/posts/0010-hexo-learn-from-Never-yu.html#background" target="_blank" rel="noopener">Hexo博客设置进阶</a> 完成该部分的设置。</p></li><li><p>使用 <code>inline-blue</code>, <code>inline-purple</code>, <code>inline-yellow</code>,<code>inline-green</code> 可以对文字背景色块进行修改。</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"inline-blue"</span>&gt;</span>站点配置文件<span class="tag">&lt;/<span class="name">span</span>&gt;</span>， </span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"inline-purple"</span>&gt;</span>主题配置文件<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="图形边框效果"><a href="#图形边框效果" class="headerlink" title="图形边框效果"></a>图形边框效果</h4><p>参考 <a href="http://blog.junyu.pro/posts/0010-hexo-learn-from-Never-yu.html#background" target="_blank" rel="noopener">Hexo博客设置进阶</a> 完成该部分的设置。</p><h4 id="引用边框变色"><a href="#引用边框变色" class="headerlink" title="引用边框变色"></a>引用边框变色</h4><p>参考<a href="http://blog.junyu.pro/posts/0010-hexo-learn-from-Never-yu.html#background" target="_blank" rel="noopener">Hexo博客设置进阶</a></p><h4 id="引用居中效果"><a href="#引用居中效果" class="headerlink" title="引用居中效果"></a>引用居中效果</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">class</span>=<span class="string">"blockquote-center"</span>&gt;</span>引用居中效果<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Font-Awesome-使用"><a href="#Font-Awesome-使用" class="headerlink" title="Font Awesome 使用"></a>Font Awesome 使用</h4><ul><li><a href="http://fontawesome.dashgame.com/" target="_blank" rel="noopener">Font Awesome</a></li></ul><p>使用 <code>Font Awesome</code> 图标时，只需要使用 CSS 前缀 <code>fa</code>，再加上图标名称即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-pencil"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-pencil</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-pencil-square-o"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-pencil-square-o</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-camera-retro"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-camera-retro</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-share-square-o"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-share-square-o</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-tag"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-tag</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-video-camera"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-video-camera</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-ban"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-ban</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-code"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-code</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-cloud"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-cloud</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-pie-chart"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-pie-chart</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-thumbs-o-up"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-thumbs-o-up</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-chain"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-chain</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-link"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-link</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-edit"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-edit</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-share-alt"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-share-alt</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-jsfiddle"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-jsfiddle</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-git"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-git</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-codepen"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span> fa-codepen</span><br></pre></td></tr></table></figure><h3 id="主页图片展示"><a href="#主页图片展示" class="headerlink" title="主页图片展示"></a>主页图片展示</h3><ul><li>新建博文，设置 <code>type: &quot;picture&quot;</code>，使用 <code>{\% gp x-x \%} ... {\% endgp \%}</code> 标签引用要展示的图片地址。</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: HomePageImage</span><br><span class="line">type: "picture"</span><br><span class="line">top: 999999999999999</span><br><span class="line">date: 2018-09-12 16:50:21</span><br><span class="line">categories: HomePageImage</span><br><span class="line">tags: HomePageImage</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&#123;% gp 5-3 %&#125;</span><br><span class="line">![<span class="string">my-riding-bike</span>](<span class="link">http://ojxk3q6gs.bkt.clouddn.com/my-riding-bike.jpg</span>)</span><br><span class="line">![<span class="string">football</span>](<span class="link">http://ojxk3q6gs.bkt.clouddn.com/football.jpg</span>)</span><br><span class="line">![<span class="string">sjtu-title-3</span>](<span class="link">http://ol3kbaay9.bkt.clouddn.com/sjtu-title-3.jpg</span>)</span><br><span class="line">![<span class="string">front-end-logo-1</span>](<span class="link">http://ol3kbaay9.bkt.clouddn.com/front-end-logo-1.jpg</span>)</span><br><span class="line">![<span class="string">java-c-vs123</span>](<span class="link">http://ol3kbaay9.bkt.clouddn.com/java-c-vs123.jpg</span>)</span><br><span class="line">&#123;% endgp %&#125;</span><br></pre></td></tr></table></figure><ul><li>图片展示效果</li></ul><p><code>{\% gp 5-3 \%}</code> 用于设置图片展示效果，参考 <code>theme/next/scripts/tags/group-pictures.js</code> 注释示意图。</p><ul><li>修复图片展示</li></ul><p>博客主页目前可以正常显示上步骤中设置的图片模式效果，但是点击进入后，图片显示效果会丢失，所以需修改<br><code>themes\next\source\css\_common\components\tags\group-pictures.styl</code> 文件中的以下样式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.page-post-detail</span> <span class="selector-class">.post-body</span> <span class="selector-class">.group-picture-column</span> &#123;</span><br><span class="line">  <span class="comment">// float: none;</span></span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="comment">// width: auto !important;</span></span><br><span class="line">  <span class="selector-tag">img</span> &#123; <span class="attribute">margin</span>: <span class="number">0</span> auto; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="博文底部标签样式"><a href="#博文底部标签样式" class="headerlink" title="博文底部标签样式"></a>博文底部标签样式</h3><ul><li>将博文底部的表情样式，从改为 <code>#</code> 改为 <code>Font Awesome</code> 图标的标签样式。</li><li>修改模板 <code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将其中的 <code>#</code> 换成 <code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>。</li></ul><h3 id="首页-简历和相册分类"><a href="#首页-简历和相册分类" class="headerlink" title="首页-简历和相册分类"></a>首页-简历和相册分类</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul><li>Create</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new<span class="built_in"> page </span>resume </span><br><span class="line">hexo new<span class="built_in"> page </span>album</span><br></pre></td></tr></table></figure><ul><li>Configure</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"><span class="symbol">  home:</span> / || home</span><br><span class="line"><span class="symbol">  resume:</span> <span class="meta-keyword">/resume/</span> || child</span><br><span class="line"><span class="symbol">  album:</span> /album || picture-o</span><br></pre></td></tr></table></figure><blockquote><p>在简历和相册对应的 <code>index.md</code> 文件头部添加 <code>comments: false</code> 可以关闭评论列表。</p></blockquote><h4 id="简历配置"><a href="#简历配置" class="headerlink" title="简历配置"></a>简历配置</h4><p>除了用 <code>markdown</code> 书写个人简历外，也可以用 <code>HTML</code> 书写个人简历。此时，需要在文件头部添加不进行渲染指令。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">layout:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">个人简历</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">&lt;!doctype</span> <span class="string">html&gt;</span></span><br><span class="line"><span class="string">&lt;html</span> <span class="string">lang="zh"&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">&lt;!--</span> <span class="string">resume</span> <span class="string">code</span> <span class="string">here--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="相册配置"><a href="#相册配置" class="headerlink" title="相册配置"></a>相册配置</h4><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ul><li><a href="https://timding.top/2017/09/18/Hexo-NexT-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%86%8C-%E4%BA%8C/" target="_blank" rel="noopener">Next Theme 相册配置</a> </li><li><a href="https://juejin.im/post/5b8bc953518825284910dcdd" target="_blank" rel="noopener">搭建Hexo 相册</a></li></ul><h5 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h5><ul><li>在 <code>album</code> 目录下添加 <code>assets/empty.jpg</code>，作为图片展示的占位图。</li><li>本相册配置中是将图片存放在 <code>github</code>的，其访问链接是 <code>https://raw.githubusercontent.com</code> 开头的，并不是图片的存储地址。因此，<code>album/ins.js</code> 中图片链接地址为</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var minSrc</span> = <span class="string">'https://raw.githubusercontent.com/lbs0912/HexoBlog/master/source/album/photos_configure/min_photos/'</span> + data.link[i];</span><br><span class="line"></span><br><span class="line"><span class="attribute">var src</span> = <span class="string">'https://raw.githubusercontent.com/lbs0912/HexoBlog/master/source/album/photos_configure/photos/'</span> + data.link[i];</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li>记录，成为更好的自己。</li><li>本博客全部配置信息可在 <a href="https://github.com/lbs0912/BlogSpace" target="_blank" rel="noopener">BlogSpace | lbs0912-github</a> 查看。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录 &lt;code&gt;Hexo Blog&lt;/code&gt; 的搭建与配置&lt;/li&gt;
&lt;li&gt;对 &lt;code&gt;Next&lt;/code&gt; 主题进行定制，添加搜索，统计，置顶，加密阅读，自定义CSS等&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Front-End Develop" scheme="https://lbs0912.github.io/categories/Front-End-Develop/"/>
    
    
      <category term="Front-End Developer" scheme="https://lbs0912.github.io/tags/Front-End-Developer/"/>
    
      <category term="Hexo" scheme="https://lbs0912.github.io/tags/Hexo/"/>
    
      <category term="Next" scheme="https://lbs0912.github.io/tags/Next/"/>
    
      <category term="Blog" scheme="https://lbs0912.github.io/tags/Blog/"/>
    
  </entry>
  
</feed>
