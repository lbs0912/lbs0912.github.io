<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liu Baoshuai&#39;s Blog</title>
  
  <subtitle>Do one thing at a time and do well</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lbs0912.github.io/"/>
  <updated>2020-11-01T03:46:42.726Z</updated>
  <id>https://lbs0912.github.io/</id>
  
  <author>
    <name>Liu Baoshuai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程下ThreadLocalRandom性能分析</title>
    <link href="https://lbs0912.github.io/2020/11/04/thread-local-random-opt/"/>
    <id>https://lbs0912.github.io/2020/11/04/thread-local-random-opt/</id>
    <published>2020-11-04T00:35:26.000Z</published>
    <updated>2020-11-01T03:46:42.726Z</updated>
    
    <content type="html"><![CDATA[<ul><li>对Java中随机数相关的包进行对比分析——<code>Math.random</code>，<code>Random</code> 和 <code>concurrent.ThreadLocalRandom</code>。</li><li>对多线程下 <code>ThreadLocalRandom</code> 的性能进行分析。</li></ul><a id="more"></a><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://juejin.im/post/6863713733252743182" target="_blank" rel="noopener">多线程下的ThreadLocalRandom用法 | 掘金</a></li><li><a href="https://juejin.im/post/6844904096785235982" target="_blank" rel="noopener">Random和ThreadLocalRandom区别 | 掘金</a></li></ul><h2 id="Java中使用随机数"><a href="#Java中使用随机数" class="headerlink" title="Java中使用随机数"></a>Java中使用随机数</h2><p>Java中和随机数相关的包，主要包括3个</p><ol><li><code>java.lang.Math.random</code></li><li><code>java.util.Random</code></li><li><code>java.util.concurrent.ThreadLocalRandom</code></li></ol><h2 id="java-lang-Math-random"><a href="#java-lang-Math-random" class="headerlink" title="java.lang.Math.random"></a>java.lang.Math.random</h2><p><code>Math.random()</code> 方法可以返回区间 <code>[0.0,1.0)</code> 内的 <code>double</code> 型随机数，区间左闭右开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> val = Math.random();</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>Math.random()</code> 方法返回是 <code>double</code> 类型，注意取值的范围 <code>[0.0,1.0)</code>（能够取到零值，注意除零异常）。如果想获取整数类型的随机数，不建议将 <code>val</code> 放大 10 的若干倍然后取整。</p><p>更好的解决方案是直接使用 <code>Random</code> 对象的 <code>nextInt</code> 或者 <code>nextLong</code> 方法。 </p><h2 id="java-util-Random"><a href="#java-util-Random" class="headerlink" title="java.util.Random"></a>java.util.Random</h2><p><code>Random()</code> 有 2 种构造方法</p><ol><li><code>Random()</code>: 创建一个新的随机数生成器，默认当前系统时间的毫秒数作为种子数</li><li><code>Random(long seed)</code>: 使用指定的种子创建一个新的随机数生成器</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param seed the initial seed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="constructor">Random(<span class="params">long</span> <span class="params">seed</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (get<span class="constructor">Class()</span><span class="operator"> == </span><span class="module-access"><span class="module"><span class="identifier">Random</span>.</span></span><span class="keyword">class</span>)</span><br><span class="line">        this.seed = <span class="keyword">new</span> <span class="constructor">AtomicLong(<span class="params">initialScramble</span>(<span class="params">seed</span>)</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// subclass might have overriden setSeed</span></span><br><span class="line">        this.seed = <span class="keyword">new</span> <span class="constructor">AtomicLong()</span>;</span><br><span class="line">        set<span class="constructor">Seed(<span class="params">seed</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Random</code> 类最常用的方法是 <code>nextInt()</code>，表示返回一个随机 <code>int</code> 值。该方法可以接受参数，如 <code>nextInt(100)</code>，表示返回一个区间为 <code>[0,100)</code> 的随机数，区间左开右闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机返回一个int型整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span>          </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//随机返回一个值在[0,num)的int类型的整数,包括0不包括num</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br></pre></td></tr></table></figure><p><code>nextInt(bound)</code> 方法的源码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bound &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(BadBound);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r = next(<span class="number">31</span>);</span><br><span class="line">    <span class="keyword">int</span> m = bound - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((bound &amp; m) == <span class="number">0</span>)  <span class="comment">// i.e., bound is a power of 2</span></span><br><span class="line">        r = (<span class="keyword">int</span>)((bound * (<span class="keyword">long</span>)r) &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = r;</span><br><span class="line">             u - (r = u % bound) + m &lt; <span class="number">0</span>;</span><br><span class="line">             u = next(<span class="number">31</span>))</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="min-max-之间的随机数"><a href="#min-max-之间的随机数" class="headerlink" title="[min,max]之间的随机数"></a>[min,max]之间的随机数</h3><p><code>[min,max]</code> 之间的随机数，可以使用下面代码生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> num = rand.nextInt(MAX - MIN + <span class="number">1</span>) + MIN;</span><br></pre></td></tr></table></figure><h3 id="seed"><a href="#seed" class="headerlink" title="seed"></a>seed</h3><p>对于种子（<code>seed</code>）相同的 <code>Random</code> 对象，生成的随机数序列是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">        System.out.println(<span class="string">"====第"</span>+ j +<span class="string">"次===="</span>);</span><br><span class="line">        Random random = <span class="keyword">new</span> Random(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"index_"</span>+ i +<span class="string">"："</span> + random.nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，程序输入如下。可以看到对于种子相同的<code>Random</code> 对象，生成的随机数序列是一样的，是一种伪随机数。</p><blockquote><p>伪随机即有规则的随机。</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">====第<span class="number">1</span>次====</span><br><span class="line">index_0：<span class="number">15</span></span><br><span class="line">index_1：<span class="number">50</span></span><br><span class="line">index_2：<span class="number">74</span></span><br><span class="line">index_3：<span class="number">88</span></span><br><span class="line">====第<span class="number">2</span>次====</span><br><span class="line">index_0：<span class="number">15</span></span><br><span class="line">index_1：<span class="number">50</span></span><br><span class="line">index_2：<span class="number">74</span></span><br><span class="line">index_3：<span class="number">88</span></span><br><span class="line">====第<span class="number">3</span>次====</span><br><span class="line">index_0：<span class="number">15</span></span><br><span class="line">index_1：<span class="number">50</span></span><br><span class="line">index_2：<span class="number">74</span></span><br><span class="line">index_3：<span class="number">88</span></span><br><span class="line">====第<span class="number">4</span>次====</span><br><span class="line">index_0：<span class="number">15</span></span><br><span class="line">index_1：<span class="number">50</span></span><br><span class="line">index_2：<span class="number">74</span></span><br><span class="line">index_3：<span class="number">88</span></span><br></pre></td></tr></table></figure><h2 id="java-util-concurrent-ThreadLocalRandom"><a href="#java-util-concurrent-ThreadLocalRandom" class="headerlink" title="java.util.concurrent.ThreadLocalRandom"></a>java.util.concurrent.ThreadLocalRandom</h2><p>在多线程下，使用 <code>java.util.Random</code> 获取随机数，它是线程安全的，对于使用指定种子的情况，多个线程会竞争同一 <code>seed</code>，这会造成性能下降。</p><p>这是因为，<code>Random</code> 生成新的随机数需要 2步</p><ol><li>根据老的 <code>seed</code> 生成新的 <code>seed</code></li><li>由新的 <code>seed</code> 计算出新的随机数</li></ol><p>第 2 步的算法是固定的，<strong>如果每个线程并发地获取同样的 <code>seed</code>，那么得到的随机数也是一样的。为了避免这种情况，<code>Random</code> 使用 <code>CAS</code> 操作保证每次只有一个线程可以获取并更新 <code>seed</code>，失败的线程则需要自旋重试。</strong></p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2020/java-random-seed-1.png" alt=""></p><p>因此，在多线程下用 <code>Random</code> 不太合适，为了解决这个问题，出现了 <code>ThreadLocalRandom</code>，在多线程下，它为每个线程维护一个 <code>seed</code> 变量，这样就不用竞争了。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2020/java-random-seed-2.png" alt=""></p><h3 id="JMH性能对比测试-ThreadLocalRandom-Random"><a href="#JMH性能对比测试-ThreadLocalRandom-Random" class="headerlink" title="JMH性能对比测试-ThreadLocalRandom-Random"></a>JMH性能对比测试-ThreadLocalRandom-Random</h3><p>下面使用 JMH 测试并发情况下，<code>ThreadLocalRandom</code> 和 <code>Random</code> 的性能差异。</p><p>首先，导入如下依赖（JDK9之后自带JMH，不需导入依赖）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--JMH--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写测试代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.Throughput) <span class="comment">// 测试类型：吞吐量</span></span><br><span class="line"><span class="meta">@Warmup</span>(iterations = <span class="number">3</span>, time = <span class="number">1</span>)</span><br><span class="line"><span class="meta">@Threads</span>(<span class="number">100</span>)</span><br><span class="line"><span class="meta">@OutputTimeUnit</span>(TimeUnit.MILLISECONDS)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpbAppApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line"><span class="comment">//        SpringApplication.run(SpbAppApplication.class, args);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动基准测试</span></span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(SpbAppApplication.class.getSimpleName()) <span class="comment">// 要导入的测试类</span></span><br><span class="line">                .warmupIterations(<span class="number">5</span>) <span class="comment">// 预热 5 轮</span></span><br><span class="line">                .measurementIterations(<span class="number">10</span>) <span class="comment">// 度量10轮</span></span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run(); <span class="comment">// 执行测试</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Random 性能测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">randomTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 生成 0-9 的随机数</span></span><br><span class="line">            random.nextInt(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadLocalRandom 性能测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadLocalRandomTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threadLocalRandom.nextInt(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设定 <code>forks(1)</code>，设定 <code>@Threads()</code> 分别为 16 和 100，即在一个进程中，分别测试16个线程情况下和100个线程情况下的吞吐量对比数据。</p><p>测试结果如下，其中 <code>Cnt</code> 表示运行了多少次，<code>Score</code> 表示执行的成绩，<code>Units</code> 表示每秒的吞吐量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Threads: 16 threads, will synchronize iterations</span><br><span class="line">Benchmark                                 Mode  Cnt      Score      Error   Units</span><br><span class="line">SpbAppApplication.randomTest             thrpt   <span class="number">10</span>   <span class="number">4996.466</span> ± <span class="number">3629.543</span>  ops/ms</span><br><span class="line">SpbAppApplication.threadLocalRandomTest  thrpt   <span class="number">10</span>  <span class="number">37720.715</span> ± <span class="number">6566.971</span>  ops/ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Threads: 100 threads, will synchronize iterations</span><br><span class="line">Benchmark                                 Mode  Cnt      Score       Error   Units</span><br><span class="line">SpbAppApplication.randomTest             thrpt   <span class="number">10</span>   <span class="number">3259.461</span> ±  <span class="number">1819.021</span>  ops/ms</span><br><span class="line">SpbAppApplication.threadLocalRandomTest  thrpt   <span class="number">10</span>  <span class="number">29948.252</span> ± <span class="number">10276.214</span>  ops/ms</span><br></pre></td></tr></table></figure><p><strong>从 JMH 测试的结果可以看出，在16个线程并发下，<code>ThreadLocalRandom</code> 在并发情况下的吞吐量约是 <code>Random</code> 的 5 倍。在 100个线程并发下，差距扩大到了将近10倍。</strong></p><p>因此在高并发下，尽量使用 <code>ThreadLocalRandom</code>。</p><h3 id="多线程下使用"><a href="#多线程下使用" class="headerlink" title="多线程下使用"></a>多线程下使用</h3><p>在每个线程下调用 <code>ThreadLocalRandom.current()</code> 获取对象实例，再调用 <code>nextInt()</code> 方法获取随机数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalRandomDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Player().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">": "</span> +</span><br><span class="line">            ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();</span><br><span class="line">            threadLocalRandom.nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，多线程下不能把 <code>ThreadLocalRandom.current()</code> 设置为 <code>final</code>，即下述代码。否则多线程下，产生的随机数是相同的。详情可以参考 <a href="https://juejin.im/post/6863713733252743182" target="_blank" rel="noopener">多线程下的ThreadLocalRandom用法 | 掘金</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalRandomDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocalRandom RANDOM =</span><br><span class="line">            ThreadLocalRandom.current();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Player().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">": "</span> + RANDOM.nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序的输出如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>: <span class="number">4</span></span><br><span class="line">Thread-<span class="number">1</span>: <span class="number">4</span></span><br><span class="line">Thread-<span class="number">2</span>: <span class="number">4</span></span><br><span class="line">Thread-<span class="number">3</span>: <span class="number">4</span></span><br><span class="line">Thread-<span class="number">4</span>: <span class="number">4</span></span><br><span class="line">Thread-<span class="number">5</span>: <span class="number">4</span></span><br><span class="line">Thread-<span class="number">6</span>: <span class="number">4</span></span><br><span class="line">Thread-<span class="number">7</span>: <span class="number">4</span></span><br><span class="line">Thread-<span class="number">8</span>: <span class="number">4</span></span><br><span class="line">Thread-<span class="number">9</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;对Java中随机数相关的包进行对比分析——&lt;code&gt;Math.random&lt;/code&gt;，&lt;code&gt;Random&lt;/code&gt; 和 &lt;code&gt;concurrent.ThreadLocalRandom&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;对多线程下 &lt;code&gt;ThreadLocalRandom&lt;/code&gt; 的性能进行分析。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://lbs0912.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://lbs0912.github.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://lbs0912.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="fork/join" scheme="https://lbs0912.github.io/tags/fork-join/"/>
    
  </entry>
  
  <entry>
    <title>Java fork/join 框架入门篇</title>
    <link href="https://lbs0912.github.io/2020/11/02/java-fork-join/"/>
    <id>https://lbs0912.github.io/2020/11/02/java-fork-join/</id>
    <published>2020-11-02T00:35:26.000Z</published>
    <updated>2020-11-01T03:35:00.658Z</updated>
    
    <content type="html"><![CDATA[<ul><li>介绍Java Fork/Join的基本概念和使用Demo。</li></ul><a id="more"></a><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li>《Java 8实战》书籍第7章节 - <em>分支/合并框架</em></li><li><a href="https://www.infoq.cn/article/fork-join-introduction" target="_blank" rel="noopener">聊聊并发（八）——Fork/Join框架介绍</a></li><li><a href="https://wangxin1248.github.io/java/2019/10/forkjoin.html" target="_blank" rel="noopener">Java并发 - Fork/Join框架介绍</a></li><li><a href="https://houbb.github.io/2019/01/18/jcip-14-deque-workstealing" target="_blank" rel="noopener">双端队列和工作窃取</a></li></ul><h2 id="什么是Fork-Join框架"><a href="#什么是Fork-Join框架" class="headerlink" title="什么是Fork/Join框架"></a>什么是Fork/Join框架</h2><p><code>Fork/Join</code> 框架，即分支/合并框架，是 Java 7 中提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。<br><code>Fork/Join</code> 框架，和 <code>MapReduce</code> 的原理类似，都是通过将大任务拆分为小任务来实现并行计算，主要是利用<strong>分治法</strong>的思想来实现多任务并行计算。</p><p><code>Fork</code> 就是把一个大任务切分为若干子任务并行的执行，<code>Join</code> 就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算 <code>1+2+。。＋10000</code>，可以分割成 10 个子任务，每个子任务分别对 1000 个数进行求和，最终汇总这 10 个子任务的结果。<code>Fork/Join</code> 的运行流程图如下。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2020/java-fork-join-task-1.png" alt=""></p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2020/java-fork-join-task-1-1.png" alt=""></p><p><code>Fork/Join</code> 框架创建的任务需要通过 <code>ForkJoinPool</code> 来启动，<code>ForkJoinPool</code> 是一个线程池，比较特殊的是其线程数量是根据 CPU 的核心数来设置的。<code>ForkJoinPool</code> 是通过工作窃取（<code>work-stealing</code>）算法来提高 CPU 的利用率的。</p><h2 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h2><p>工作窃取（<code>work-stealing</code>）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2020/java-fork-join-task-3.png" alt=""></p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2020/java-fork-join-task-1-2.png" alt=""></p><p>每个线程中维护了一个双端队列来存储所需要执行的任务，而工作窃取算法允许从其他线程的双端队列中窃取一个<strong>最晚（<code>Oldest</code>，队列的尾部）</strong> 的任务来执行，这样可以避免和当前任务所属的线程发生竞争。</p><blockquote><p>为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p></blockquote><p>如上图所示，Thread2 从 Thread1 队列中拿出最晚的 Task1 来执行，Thread1 则拿出 Task2 来执行，这样就会避免发生竞争。</p><p>工作窃取算法优点</p><ul><li>充分利用线程进行并行计算</li><li>减少了线程间的竞争</li></ul><p>工作窃取算法缺点</p><ul><li>在某些情况下会存在竞争（双端队列中只有一个任务）</li><li>消耗了更多的系统资源</li></ul><p>在实际应用中，工作窃取算意味着这些任务差不多被平均分配到 <code>ForkJoinPool</code> 中的所有线程上，用于在池中的工作线程之间重新分配和平衡任务。下图展示了这个过程，当工作线程队列中有一个任务被分成两个子任务时，一个子任务就被闲置的工作线程“偷走”了。如前所述，这个过程可以不断递归，直到规定子任务应顺序执行的条件为真。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2020/java-fork-join-task-2.png" alt=""></p><h2 id="Fork-Join框架基础类"><a href="#Fork-Join框架基础类" class="headerlink" title="Fork/Join框架基础类"></a>Fork/Join框架基础类</h2><p>下面考虑如何设计一个 <code>Fork/Join</code> 框架，需要考虑如下 2 点</p><ol><li><p>第 1 步分割任务。首先需要有一个 <code>fork</code> 类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。</p></li><li><p>第 2 步执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</p></li></ol><p><code>Fork/Join</code> 使用 2 个类来完成以上两件事情</p><ul><li><code>ForkJoinTask</code>：我们要使用 <code>Fork/Join</code> 框架，必须首先创建一个 <code>ForkJoinTask</code> 任务。它提供在任务中执行 <code>fork()</code> 和 <code>join()</code> 操作的机制。通常情况下我们不需要直接继承 <code>ForkJoinTask</code> 类，而只需要继承它的子类，<code>Fork/Join</code> 框架提供了以下两个子类<ul><li><code>RecursiveAction</code>：用于没有返回结果的任务。</li><li><code>RecursiveTask</code> ：用于有返回结果的任务。</li></ul></li><li><code>ForkJoinPool</code> ：<code>ForkJoinTask</code> 需要通过 <code>ForkJoinPool</code> 来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</li></ul><p>此外，框架还提供了下面 2 个类</p><ul><li><code>ForkJoinWorkerThread</code>：是 <code>ForkJoinPool</code> 内的 <code>worker thread</code>，执行 <code>ForkJoinTask</code>，内部有 <code>ForkJoinPool.WorkQueue</code> 来保存要执行的 <code>ForkJoinTask</code>。</li><li><code>ForkJoinPool.WorkQueue</code>：保存要执行的 <code>ForkJoinTask</code>。</li></ul><p>更形象的总结如下</p><ol><li><code>ForkJoinPool</code> : “管理者”</li><li><code>ForkJoinTask</code> : “任务类型”，如 <code>RecursiveAction</code> 和 <code>RecursiveTask</code></li><li><code>ForkJoinWorkerThread</code> : “工人”</li></ol><h2 id="Fork-Join-框架执行流程"><a href="#Fork-Join-框架执行流程" class="headerlink" title="Fork/Join 框架执行流程"></a>Fork/Join 框架执行流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fork/join计算斐波那契</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建分治任务线程池</span></span><br><span class="line">ForkJoinPool fjp = <span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建分治任务</span></span><br><span class="line">Fibonacci fib = <span class="keyword">new</span> Fibonacci(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动分治任务</span></span><br><span class="line">Integer result = fjp.invoke(fib);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何提交</span></span><br><span class="line">submit(ForkJoinTask&lt;T&gt; task) -&gt;externalPush(ForkJoinTask&lt;?&gt; task) -&gt;  externalSubmit(ForkJoinTask&lt;?&gt; task)</span><br><span class="line"></span><br><span class="line">execute(ForkJoinTask)</span><br><span class="line">invoke(ForkJoinTask)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务消费</span></span><br><span class="line">compute()</span><br></pre></td></tr></table></figure><ol><li><code>ForkJoinPool</code> 的每个工作线程都维护着一个双端工作队列（<code>WorkQueue</code>），队列中存放着是任务（<code>ForkJoinTask</code>）。</li><li>每个工作线程在运行中产生新的任务（调用 <code>fork()</code>）时，放入工作队列的队首（<strong>队首的任务的等待时间最短</strong>），并且工作线程在处理自己的工作队列时，使用的是 <code>FIFO</code> 方式，也就是说每次从队首取出任务来执行。</li><li>每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 <code>pool</code> 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队尾，也就是说工作线程在窃取其他工作线程的任务时，使用的是 <code>LIFO</code> 方式。</li><li>在遇到 <code>join()</code> 时，如果需要 <code>join</code> 的任务尚未完成，则会先处理其他任务，并等待其完成。</li><li>在既没有自己的任务，也没有可以窃取的任务时，进入休眠。</li></ol><blockquote><p>FIFO : First in, First out，先进先出。 LIFO : Last in, First out，后进先出。</p></blockquote><h2 id="Fork-Join-使用Demo"><a href="#Fork-Join-使用Demo" class="headerlink" title="Fork/Join 使用Demo"></a>Fork/Join 使用Demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">//创建一个计算任务，计算 由1加到12</span></span><br><span class="line">        CountTask countTask = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">        Future&lt;Integer&gt; future = forkJoinPool.submit(countTask);</span><br><span class="line">        System.out.println(<span class="string">"最终的计算结果："</span> + future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//任务已经足够小，可以直接计算，并返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"执行计算任务，计算    "</span> + start + <span class="string">"到 "</span> + end + <span class="string">"的和  ，结果是："</span> + sum + <span class="string">"   执行此任务的线程："</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//任务过大，需要切割</span></span><br><span class="line">            System.out.println(<span class="string">"任务过大，切割的任务：  "</span> + start + <span class="string">"加到 "</span> + end + <span class="string">"的和       执行此任务的线程："</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//切割成两个子任务</span></span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">//执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            <span class="comment">//等待子任务的完成，并获取执行结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line">            <span class="comment">//合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">任务过大，切割的任务： 1加到 12的和 执行此任务的线程：ForkJoinPool-1-worker-1</span><br><span class="line">任务过大，切割的任务： 7加到 12的和 执行此任务的线程：ForkJoinPool-1-worker-3</span><br><span class="line">任务过大，切割的任务： 1加到 6的和 执行此任务的线程：ForkJoinPool-1-worker-2</span><br><span class="line">执行计算任务，计算 7到 9的和 ，结果是：24 执行此任务的线程：ForkJoinPool-1-worker-3</span><br><span class="line">执行计算任务，计算 1到 3的和 ，结果是：6 执行此任务的线程：ForkJoinPool-1-worker-1</span><br><span class="line">执行计算任务，计算 4到 6的和 ，结果是：15 执行此任务的线程：ForkJoinPool-1-worker-1</span><br><span class="line">执行计算任务，计算 10到 12的和 ，结果是：33 执行此任务的线程：ForkJoinPool-1-worker-3</span><br><span class="line">最终的计算结果：78</span><br></pre></td></tr></table></figure><p>从结果可以看出，提交的计算任务是由线程1执行，线程1进行了第一次切割，切割成两个子任务 “7加到12” 和 “1加到6”，并提交这两个子任务。然后这两个任务被线程2、线程3给窃取了。线程1 的内部队列中已经没有任务了，这时候，线程2、线程3 也分别进行了一次任务切割并各自提交了两个子任务，于是线程 1 也去窃取任务（这里窃取的都是线程2的子任务）。</p><h2 id="Fork-Join-框架的异常处理"><a href="#Fork-Join-框架的异常处理" class="headerlink" title="Fork/Join 框架的异常处理"></a>Fork/Join 框架的异常处理</h2><p><code>ForkJoinTask</code> 在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以 <code>ForkJoinTask</code> 提供了 <code>isCompletedAbnormally()</code> 方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过 <code>ForkJoinTask</code> 的 <code>getException</code> 方法获取异常。使用如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(task.isCompletedAbnormally()) &#123;</span><br><span class="line">   System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getException</code> 方法返回 <code>Throwable</code> 对象，如果任务被取消了则返回 <code>CancellationException</code>。如果任务没有完成或者没有抛出异常则返回 <code>null</code>。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="ForkJoinPool-使用-submit-与-invoke-提交的区别"><a href="#ForkJoinPool-使用-submit-与-invoke-提交的区别" class="headerlink" title="ForkJoinPool 使用 submit 与 invoke 提交的区别"></a>ForkJoinPool 使用 submit 与 invoke 提交的区别</h3><ul><li><code>invoke</code> 是同步执行，调用之后需要等待任务完成，才能执行后面的代码。</li><li><code>submit</code> 是异步执行，只有在 <code>Future</code> 调用 <code>get</code> 的时候会阻塞。</li></ul><h3 id="继承-RecursiveTask-与-RecursiveAction的区别？"><a href="#继承-RecursiveTask-与-RecursiveAction的区别？" class="headerlink" title="继承 RecursiveTask 与 RecursiveAction的区别？"></a>继承 RecursiveTask 与 RecursiveAction的区别？</h3><ul><li>继承 <code>RecursiveTask</code>：适用于有返回值的场景。</li><li>继承 <code>RecursiveAction</code>：适合于没有返回值的场景。</li></ul><h3 id="子任务调用-fork-与-invokeAll-的区别？"><a href="#子任务调用-fork-与-invokeAll-的区别？" class="headerlink" title="子任务调用 fork 与 invokeAll 的区别？"></a>子任务调用 fork 与 invokeAll 的区别？</h3><ul><li><code>fork</code>：让子线程自己去完成任务，父线程监督子线程执行，浪费父线程。</li><li><code>invokeAll</code>：子父线程共同完成任务，可以更好的利用线程池。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;介绍Java Fork/Join的基本概念和使用Demo。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://lbs0912.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://lbs0912.github.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://lbs0912.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="fork/join" scheme="https://lbs0912.github.io/tags/fork-join/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-011</title>
    <link href="https://lbs0912.github.io/2020/08/15/leetcode-011/"/>
    <id>https://lbs0912.github.io/2020/08/15/leetcode-011/</id>
    <published>2020-08-15T06:35:26.000Z</published>
    <updated>2020-11-01T03:50:22.460Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录LeetCode题目笔记，汇总LeetCode解答记录</li></ul><a id="more"></a><h2 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h2><ul><li>2020/06/29，撰写</li><li>2020/11/01，完成</li></ul><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li><a href="https://leetcode-cn.com/problems/di-string-match/" target="_blank" rel="noopener">LeetCode-942. 增减字符串匹配</a></li><li><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">LeetCode-88. 合并两个有序数组组</a></li><li><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">LeetCode-209. 长度最小的子数组</a></li><li><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener">LeetCode-201. 数字范围按位与</a></li><li><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/" target="_blank" rel="noopener">LeetCode-187. 重复的DNA序列</a></li></ul><h2 id="942-增减字符串匹配"><a href="#942-增减字符串匹配" class="headerlink" title="942. 增减字符串匹配"></a>942. 增减字符串匹配</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/di-string-match/" target="_blank" rel="noopener">LeetCode-942. 增减字符串匹配</a></li></ul><h3 id="Approach-1-分治"><a href="#Approach-1-分治" class="headerlink" title="Approach 1-分治"></a>Approach 1-分治</h3><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><p>参考 <code>leetcode-cn</code> 官方题解。</p><p>首先考虑字符串中的第一个字母。如果 <code>S[0] == &#39;I&#39;</code>，那么只要令 <code>A[0] = 0</code>，就一定能满足 <code>A[0] &lt; A[1]</code>。如果 <code>S[0] == &#39;D&#39;</code>，同样我们只要令 <code>A[0] = N</code>，就一定能满足 <code>A[0] &gt; A[1]</code>。</p><p>接下来，当我们考虑 <code>S</code> 中剩下的 <code>N - 1</code> 个字母时，还剩下 <code>N</code> 个数可以使用，这 <code>N</code> 个数为 <code>[0 .. N - 1]</code> 或 <code>[1 .. N]</code>。可以发现，由于 <code>S[0]</code> 的值已经确定，那么剩下 <code>S</code> 中的 <code>N - 1</code> 个字母和 <code>N</code> 个可用的数变成了一个和原问题相同，但规模为 <code>N - 1</code> 的问题。即如果 <code>S[1] == &#39;I&#39;</code>，我们就令 <code>A[1]</code> 为剩下数中最小的那个数；如果 <code>S[1] == &#39;D&#39;</code>，我们就令 <code>A[1]</code> 为剩下数中最大的那个数。</p><p>我们每次会把可以使用的数的集合中的最小值或最大值取出，并放到当前的位置，因此可以使用的数的集合总是连续的，就可以非常方便的进行维护。</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O(N)</code></li><li>空间复杂度：<code>O(N)</code></li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] diStringMatch(String S) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> N = S.length();</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S.charAt(i) == <span class="string">'I'</span>)&#123;</span><br><span class="line">                ans[i] = low++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                ans[i] = high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[N] = low;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="88-合并两个有序数组组"><a href="#88-合并两个有序数组组" class="headerlink" title="88. 合并两个有序数组组"></a>88. 合并两个有序数组组</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">LeetCode-88. 合并两个有序数组组</a></li></ul><h3 id="Approach-1-合并后排序"><a href="#Approach-1-合并后排序" class="headerlink" title="Approach 1-合并后排序"></a>Approach 1-合并后排序</h3><h4 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h4><p>最朴素的解法就是将两个数组合并之后再排序。这种方法没有利用两个数组本身已经有序这一点。</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O((n+m)log(n+m))</code></li><li>空间复杂度：<code>O(1)</code></li></ul><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   c(nums2, <span class="number">0</span>, nums1, m, n);</span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> length)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>System.arraycopy</code> 方法有5个入参，如上所示，从源数组 <code>src</code> 的第 <code>srcPos</code> 索引开始，复制 <code>length</code> 个元素到目标数组 <code>dest</code>，从 <code>destPos</code> 开始插入。下面给出一个使用示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] num1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] num2 = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">System.arraycopy(num1,<span class="number">0</span>,num2,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//num1 = &#123;1,2,3&#125;</span></span><br><span class="line"><span class="comment">//num2 = &#123;4,5,1,2,3,9&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Approach-2-双指针-从前往后"><a href="#Approach-2-双指针-从前往后" class="headerlink" title="Approach 2-双指针 / 从前往后"></a>Approach 2-双指针 / 从前往后</h3><h4 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h4><p>一般而言，对于有序数组可以通过 <em>双指针法</em> 达到 <code>O(n + m)</code> 的时间复杂度。</p><p>最直接的算法实现是将指针 <code>p1</code> 置为 <code>nums1</code> 的开头，<code>p2</code> 为 <code>nums2</code> 的开头，在每一步将最小值放入输出数组中。</p><p>由于 <code>nums1</code> 是用于输出的数组，需要将 <code>nums1</code> 中的前 <code>m</code> 个元素放在其他地方，也就需要 <code>O(m)</code> 的空间复杂度。</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O(n+m)</code></li><li>空间复杂度：<code>O(m)</code></li></ul><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums1_copy = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        System.arraycopy(nums1,<span class="number">0</span>,nums1_copy,<span class="number">0</span>,m);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> p1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((p1&lt;m) &amp;&amp; (p2&lt;n))&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1_copy[p1] &lt; nums2[p2])&#123;</span><br><span class="line">                nums1[index] = nums1_copy[p1];</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[index] = nums2[p2];</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="comment">//nums1[index++] = (nums1_copy[p1] &lt; nums2[p2]) ? nums1_copy[p1++] : nums2[p2++];</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if there are still elements to add</span></span><br><span class="line">        <span class="keyword">if</span>(p1&lt;m)&#123;</span><br><span class="line">            <span class="comment">// System.arraycopy(nums1_copy, p1, nums1, p1 + p2, m + n - p1 - p2);</span></span><br><span class="line">            System.arraycopy(nums1_copy, p1, nums1,index, m + n -index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2&lt;n)&#123;</span><br><span class="line">            <span class="comment">// System.arraycopy(nums2, p2, nums1, p1 + p2, m + n - p1 - p2);</span></span><br><span class="line">            System.arraycopy(nums2,p2,nums1,index,m+n-index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写代码时注意代码的精简，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums1_copy[p1] &lt; nums2[p2])&#123;</span><br><span class="line">    nums1[index] = nums1_copy[p1];</span><br><span class="line">    p1++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    nums1[index] = nums2[p2];</span><br><span class="line">    p2++;</span><br><span class="line">&#125;</span><br><span class="line">index++;</span><br></pre></td></tr></table></figure><p>可以精简为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums1[index++] = (nums1_copy[p1] &lt; nums2[p2]) ? nums1_copy[p1++] : nums2[p2++];</span><br></pre></td></tr></table></figure><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h2><h3 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">LeetCode-209. 长度最小的子数组</a></li></ul><h3 id="Approach-1-暴力法"><a href="#Approach-1-暴力法" class="headerlink" title="Approach 1-暴力法"></a>Approach 1-暴力法</h3><h4 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h4><p>采用暴力求解，两重 <code>for</code> 循环求解。</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minLength = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i];</span><br><span class="line">            <span class="keyword">int</span> subLength = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;=s)&#123;</span><br><span class="line">                <span class="comment">//若单个元素大于s 直接返回1</span></span><br><span class="line">                <span class="keyword">return</span> subLength;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;length;j++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                subLength++;</span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= s &amp;&amp; minLength &gt;= subLength)&#123;</span><br><span class="line">                    minLength = subLength;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (minLength == Integer.MAX_VALUE)? <span class="number">0</span>:minLength;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-前缀和-二分查找"><a href="#Approach-2-前缀和-二分查找" class="headerlink" title="Approach 2-前缀和+二分查找"></a>Approach 2-前缀和+二分查找</h3><h4 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h4><p>方法一的时间复杂度是 <code>O(n^2)</code>，因为在确定每个子数组的开始下标后，找到长度最小的子数组需要 <code>O(n)</code> 的时间。如果使用二分查找，则可以将时间优化到 <code>O(logn)</code>。</p><p><strong>为了使用二分查找，需要额外创建一个数组 <code>sums</code> 用于存储数组 <code>nums</code> 的前缀和，其中 <code>sums[i]</code> 表示从 <code>nums[0]</code> 到 <code>nums[i−1]</code> 的元素和。</strong></p><p>得到前缀和之后，对于每个开始下标 <code>i</code>，可通过二分查找得到大于或等于 <code>i</code> 的最小下标 <code>bound</code>，使得 <code>sums[bound] - sums[i-1] ≥ s</code>，并更新子数组的最小长度，此时子数组的长度是 <code>bound−(i−1)</code>。</p><p><strong>因为这道题保证了数组中每个元素都为正，所以前缀和一定是递增的，这一点保证了二分的正确性。如果题目没有说明数组中每个元素都为正，这里就不能使用二分来查找这个位置了。</strong></p><p>在很多语言中，都有现成的库和函数来为我们实现这里二分查找大于等于某个数的第一个位置的功能，比如 C++ 的 <code>lower_bound</code>，Java 中的 <code>Arrays.binarySearch</code>，C# 中的 <code>Array.BinarySearch</code>，Python 中的 <code>bisect.bisect_left</code>。</p><p>此处给出 Java 中 <code>Arrays.binarySearch</code> 的源码。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> binarySearch(<span class="built_in">int</span>[] a, <span class="built_in">int</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearch0(a, <span class="number">0</span>, a.length, <span class="built_in">key</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> binarySearch0(<span class="keyword">short</span>[] a, <span class="built_in">int</span> fromIndex, <span class="built_in">int</span> toIndex,</span><br><span class="line">                                 <span class="keyword">short</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span> low = fromIndex;</span><br><span class="line">    <span class="built_in">int</span> high = toIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="built_in">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">short</span> midVal = a[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; <span class="built_in">key</span>)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; <span class="built_in">key</span>)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：<code>O(nlogn)</code>，其中 nn 是数组的长度。需要遍历每个下标作为子数组的开始下标，遍历的时间复杂度是 <code>O(n)</code>。对于每个开始下标，需要通过二分查找得到长度最小的子数组，二分查找得时间复杂度是 <code>O(logn)</code>，因此总时间复杂度是 <code>O(nlogn)</code></li><li>空间复杂度：<code>O(n)</code>，其中 <code>n</code> 是数组的长度。额外创建数组 <code>sums</code> 存储前缀和。</li></ul><h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; </span><br><span class="line">        <span class="comment">// 为了方便计算，令 size = n + 1 </span></span><br><span class="line">        <span class="comment">// sums[0] = 0 意味着前 0 个元素的前缀和为 0</span></span><br><span class="line">        <span class="comment">// sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span></span><br><span class="line">        <span class="comment">// 以此类推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> target = s + sums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> bound = Arrays.binarySearch(sums, target);</span><br><span class="line">            <span class="keyword">if</span> (bound &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                bound = -bound - <span class="number">1</span>; <span class="comment">//计算出插入点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bound &lt;= n) &#123;</span><br><span class="line">                ans = Math.min(ans, bound - (i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-3-双指针"><a href="#Approach-3-双指针" class="headerlink" title="Approach 3-双指针"></a>Approach 3-双指针</h3><h4 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h4><p>在方法一和方法二中，都是每次确定子数组的开始下标，然后得到长度最小的子数组，因此时间复杂度较高。为了降低时间复杂度，可以使用双指针的方法。</p><p>定义两个指针 <code>start</code> 和 <code>end</code> 分别表示子数组的开始位置和结束位置，维护变量 <code>sum</code> 存储子数组中的元素和（即从 <code>nums[start]</code> 到 <code>nums[end]</code> 的元素和）。</p><p>初始状态下，<code>start</code> 和 <code>end</code> 都指向下标 0，<code>sum</code> 的值为 `0。</p><p>每一轮迭代，将 <code>nums[end]</code> 加到 <code>sum</code>，如果 <code>sum ≥ s</code>，则更新子数组的最小长度（此时子数组的长度是 <code>end−start+1</code>），然后将 <code>nums[start]</code> 从 <code>sum</code> 中减去并将 <code>start</code> 右移，直到 <code>sum &lt; s</code>，在此过程中同样更新子数组的最小长度。在每一轮迭代的最后，将 <code>end</code> 右移。</p><p>参见 <em>leetcode-cn 官方题解</em> 的动画讲解。</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是数组的长度。指针 <code>start</code> 和 <code>end</code> 最多各移动 n 次</li><li>空间复杂度：<code>O(1)</code></li></ul><h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; n)&#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;=s)&#123;</span><br><span class="line">                ans = Math.min(ans,end-start+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//在总和sum中移除nums[start] 并把star指针右移</span></span><br><span class="line">                sum -= nums[start]; </span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="201-数字范围按位与"><a href="#201-数字范围按位与" class="headerlink" title="201. 数字范围按位与"></a>201. 数字范围按位与</h2><h3 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener">LeetCode-201. 数字范围按位与</a></li></ul><h3 id="Approach-1-位移操作"><a href="#Approach-1-位移操作" class="headerlink" title="Approach 1-位移操作"></a>Approach 1-位移操作</h3><h4 id="Description-10"><a href="#Description-10" class="headerlink" title="Description"></a>Description</h4><p>参考 <code>leetcode-cn</code> 官方题解。</p><p>对于区间中数字，考虑其二进制格式，对于一系列的位，例如 <code>[1, 1, 0, 1, 1]</code>，只要有一个零值的位，那么其位的与运算结果，都将为零。</p><p>下面对区间 <code>[9,12]</code> 的情况进行分析。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-201-1.png" alt=""></p><p>在上面的例子中，在对所有数字执行完与操作以后，<strong>剩余的部分是所有这些位字符串的公共前缀。</strong></p><p>因此，我们可以将问题重新表述为：给定两个整数，要求我们找到它们二进制字符串的公共前缀。</p><p>采用暴力求解，两重 <code>for</code> 循环求解。</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O(1)</code>。虽然算法中有一个循环，但是迭代次数是由整数的位数限定的，所以迭代次数是固定的。因此，算法的时间复杂度是常数级别的。</li><li>空间复杂度：<code>O(1)</code>。不管输入是什么，内存消耗是常数的。</li></ul><h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> shift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m &lt; n)&#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m &lt;&lt; shift;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187. 重复的DNA序列"></a>187. 重复的DNA序列</h2><h3 id="Description-11"><a href="#Description-11" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/" target="_blank" rel="noopener">LeetCode-187. 重复的DNA序列</a></li></ul><h3 id="Approach-1-基于HasSet"><a href="#Approach-1-基于HasSet" class="headerlink" title="Approach 1-基于HasSet"></a>Approach 1-基于HasSet</h3><h4 id="Description-12"><a href="#Description-12" class="headerlink" title="Description"></a>Description</h4><p>将字符串中每 10 个字符串作为一个 <code>map</code> 容器的 <code>key</code>，并记录其出现的次数。若出现的次数大于1次，则输出该字符串。注意输出最终结果时，<code>Set</code> 到 <code>List</code> 的转换。</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O((N-L)L)</code>，在执行的循环中，有 <code>N-L+1</code> 个长度为 L 的子字符串，这会导致 <code>O((N - L)L)</code> 时间复杂性。</li><li>空间复杂度：<code>O(N)</code></li></ul><h4 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">10</span>;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; length)&#123;     <span class="comment">//长度不足 直接返回空数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;=s.length();i++)&#123;</span><br><span class="line">            String key = s.substring(i-length,i);</span><br><span class="line">            map.put(key,<span class="number">1</span>+map.getOrDefault(key,<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; item : map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(item.getValue() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                set.add(item.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(set);  <span class="comment">//set to array</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录LeetCode题目笔记，汇总LeetCode解答记录&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://lbs0912.github.io/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-010</title>
    <link href="https://lbs0912.github.io/2020/06/21/leetcode-010/"/>
    <id>https://lbs0912.github.io/2020/06/21/leetcode-010/</id>
    <published>2020-06-21T06:35:26.000Z</published>
    <updated>2020-11-01T03:51:17.637Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录LeetCode题目笔记，汇总LeetCode解答记录</li></ul><a id="more"></a><h2 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h2><ul><li>2020/06/24，撰写</li><li>2020/06/27，整理完成</li></ul><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li><a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">LeetCode-771. 宝石与石头</a></li><li><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array/" target="_blank" rel="noopener">LeetCode-1486. 数组异或操作</a></li><li><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">LeetCode-16. 最接近的三数之和</a></li><li><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">LeetCode-15. 三数之和</a></li><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">LeetCode-1. 两数之和</a></li></ul><blockquote><p>第16，15，1题为同一类型题目。</p></blockquote><h2 id="771-宝石与石头"><a href="#771-宝石与石头" class="headerlink" title="771. 宝石与石头"></a>771. 宝石与石头</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">LeetCode-771. 宝石与石头</a></li></ul><h3 id="Approach-1-暴力求解"><a href="#Approach-1-暴力求解" class="headerlink" title="Approach 1-暴力求解"></a>Approach 1-暴力求解</h3><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><p>遍历每块石头，检查是不是宝石。检查步骤用简单的线性搜索来实现。</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O(J.length * S.length))</code></li><li>空间复杂度：<code>O(J.length ∗ S.length))</code></li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> s:S.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> j:J.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == s)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">break</span>;   <span class="comment">//因为字符串J中无重复，因此此处可直接break结束循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-哈希集合"><a href="#Approach-2-哈希集合" class="headerlink" title="Approach 2-哈希集合"></a>Approach 2-哈希集合</h3><h4 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h4><p>遍历每块石头，检查是不是宝石。检查步骤用 <strong>哈希集合</strong> 来高效完成。</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O(J.length + S.length))</code></li><li>空间复杂度：<code>O(J.length)</code></li></ul><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public <span class="built_in">int</span> num<span class="constructor">JewelsInStones(String J, String S)</span> &#123;</span><br><span class="line">        Set&lt;Character&gt; jSet = <span class="keyword">new</span> <span class="constructor">HashSet()</span>;</span><br><span class="line">        <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">        for(<span class="built_in">char</span> j:<span class="module-access"><span class="module"><span class="identifier">J</span>.</span></span><span class="keyword">to</span><span class="constructor">CharArray()</span>)&#123;</span><br><span class="line">            jSet.add(j);</span><br><span class="line">        &#125;</span><br><span class="line">        for(<span class="built_in">char</span> s:<span class="module-access"><span class="module"><span class="identifier">S</span>.</span></span><span class="keyword">to</span><span class="constructor">CharArray()</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(jSet.contains(s))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1486-数组异或操作"><a href="#1486-数组异或操作" class="headerlink" title="1486. 数组异或操作"></a>1486. 数组异或操作</h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array/" target="_blank" rel="noopener">LeetCode-1486. 数组异或操作</a></li></ul><h3 id="Approach-1-暴力求解-1"><a href="#Approach-1-暴力求解-1" class="headerlink" title="Approach 1-暴力求解"></a>Approach 1-暴力求解</h3><h4 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h4><p>送分题，不再赘述。</p><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">xorOperation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = start + <span class="number">2</span>*<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> value = start + <span class="number">2</span>*i;</span><br><span class="line">            res = res ^ value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h2><h3 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">LeetCode-16. 最接近的三数之和</a></li></ul><blockquote><p>本题和 <a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">LeetCode-15. 三数之和</a> 类似。</p></blockquote><h3 id="Approach-1-排序-双指针"><a href="#Approach-1-排序-双指针" class="headerlink" title="Approach 1-排序+双指针"></a>Approach 1-排序+双指针</h3><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><p>本题和 <a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">LeetCode-15. 三数之和</a> 类似，可以使用「双指针」的方法来解决。</p><p>题目要求找到与目标值 <code>target</code> 最接近的三元组，这里的「最接近」即为差值的绝对值最小。我们可以考虑直接使用三重循环枚举三元组，找出与目标值最接近的作为答案，时间复杂度为 <code>O(N^3)</code>。然而本题的 <code>N</code> 最大为 1000，会超出时间限制。</p><p>那么如何进行优化呢？我们首先考虑枚举第一个元素 <code>a</code>，对于剩下的两个元素 <code>b</code> 和 <code>c</code>，我们希望它们的和最接近 <code>target−a</code>。对于 <code>b</code> 和 <code>c</code>，如果它们在原数组中枚举的范围（既包括下标的范围，也包括元素值的范围）没有任何规律可言，那么我们还是只能使用两重循环来枚举所有的可能情况。因此，我们可以考虑对整个数组进行升序排序，这样一来</p><ul><li>假设数组的长度为 <code>n</code>，我们先枚举 <code>a</code>，它在数组中的位置为 <code>i</code>；</li><li>为了防止重复枚举，我们在位置 <code>[i+1, n)</code> 的范围内枚举 <code>b</code> 和 <code>c</code>。</li></ul><p>当我们知道了 <code>b</code> 和 <code>c</code> 可以枚举的下标范围，并且知道这一范围对应的数组元素是有序（升序）的，那么我们是否可以对枚举的过程进行优化呢？</p><p>答案是可以的。借助双指针，我们就可以对枚举的过程进行优化。我们用 <code>$p_b$</code> 和 <code>$p_c$</code> 分别表示指向 <code>b</code> 和 <code>c</code> 的指针，初始时，<code>$p_b$</code> 指向位置 <code>i+1</code>，即左边界；<code>$p_c$</code> 指向位置 <code>n-1</code>，即右边界。在每一步枚举的过程中，我们用 <code>a+b+c</code> 来更新答案，并且</p><ul><li>如果 <code>$a+b+c == target$</code>，那么直接返回 <code>target</code>，并结束循环；</li><li>如果 <code>$a+b+c \geq target$</code>，那么就将 <code>$p_c$</code> 向左移动一个位置；</li><li>如果 <code>$a+b+c \leq target$</code>，那么就将 <code>$p_b$</code> 向右移动一个位置；</li></ul><p>实际上，<code>$p_c$</code> 和 <code>$p_b$</code> 就表示了我们当前可以选择的数的范围，而每一次枚举的过程中，我们尝试边界上的两个元素，根据它们与 <code>target</code> 的值的关系，选择「抛弃」左边界的元素还是右边界的元素，从而减少了枚举的范围。这种思路与 <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a> 中的双指针解法也是类似的。</p><p><strong>小优化</strong></p><p>本题也有一些可以减少运行时间（但不会减少时间复杂度）的小优化。当我们枚举到恰好等于 <code>target</code> 的 <code>a+b+c</code> 时，可以直接返回 <code>target</code> 作为答案，因为不会有再比这个更接近的值了。</p><p>另一个优化与 <a href="https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/" target="_blank" rel="noopener">15. 三数之和</a> 的官方题解中提到的类似。当我们枚举 <code>a,b,c</code> 中任意元素并移动指针时，可以直接将其移动到下一个与这次枚举到的不相同的元素，减少枚举的次数。</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O(N^2)</code>，其中 <code>N</code> 是数组 <code>nums</code> 的长度。我们首先需要 <code>$O(N \log N)$</code> 的时间对数组进行排序，随后在枚举的过程中，使用一重循环 <code>O(N)</code> 枚举 <code>a</code>，双指针 <code>O(N)</code> 枚举 <code>b</code> 和 <code>c</code>，故一共是 <code>O(N^2)</code></li><li>空间复杂度：<code>O(logN)</code>。排序需要使用 <code>O(logN)</code> 的空间。然而我们修改了输入的数组 <code>nums</code>，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 <code>nums</code> 的副本并进行排序，此时空间复杂度为 <code>O(N)</code></li></ul><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java-1：基于 <a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">LeetCode-15. 三数之和</a> 的题解实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">//数组排序</span></span><br><span class="line">        <span class="keyword">int</span> minAbsValue = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//枚举a</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> first =<span class="number">0</span>;first&lt;n;first++)&#123;</span><br><span class="line">            <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span>(first &gt;<span class="number">0</span> &amp;&amp; nums[first] == nums[first-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// c 对应的指针初始指向数组的最右端</span></span><br><span class="line">            <span class="keyword">int</span> third = n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> remainder = target - nums[first];</span><br><span class="line">            <span class="comment">//枚举b</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> second = first+<span class="number">1</span>;second&lt;n;second++)&#123;</span><br><span class="line">                <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">                <span class="keyword">if</span>(second &gt; first+<span class="number">1</span> &amp;&amp; nums[second] == nums[second-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">                <span class="keyword">while</span>(second &lt; third)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(Math.abs(target-nums[first]-nums[second]-nums[third]) &lt; Math.abs(minAbsValue))&#123;</span><br><span class="line">                        minAbsValue = Math.abs(target-nums[first]-nums[second]-nums[third]);</span><br><span class="line">                        res = nums[first]+nums[second]+nums[third];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(nums[second] + nums[third] == remainder)&#123;</span><br><span class="line">                        <span class="keyword">return</span> target; <span class="comment">//直接返回</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(nums[second] + nums[third] &gt; remainder)&#123;</span><br><span class="line">                        --third;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        ++second;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">                <span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(second == third)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Java-2：leetcode-cn 官方题解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> best = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 保证和上一次枚举的元素不相等</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用双指针枚举 b 和 c</span></span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="comment">// 如果和为 target 直接返回答案</span></span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 根据差值的绝对值来更新答案</span></span><br><span class="line">                <span class="keyword">if</span> (Math.abs(sum - target) &lt; Math.abs(best - target)) &#123;</span><br><span class="line">                    best = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    <span class="comment">// 如果和大于 target，移动 c 对应的指针</span></span><br><span class="line">                    <span class="keyword">int</span> k0 = k - <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k0 &amp;&amp; nums[k0] == nums[k]) &#123;</span><br><span class="line">                        --k0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    k = k0;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果和小于 target，移动 b 对应的指针</span></span><br><span class="line">                    <span class="keyword">int</span> j0 = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> (j0 &lt; k &amp;&amp; nums[j0] == nums[j]) &#123;</span><br><span class="line">                        ++j0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j = j0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> best;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><h3 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">LeetCode-15. 三数之和</a></li></ul><blockquote><p>本题和 <a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">LeetCode-1. 两数之和</a> 类似，是比较经典的面试题，但是做法不尽相同。</p></blockquote><h3 id="Approach-1-排序-双指针-1"><a href="#Approach-1-排序-双指针-1" class="headerlink" title="Approach 1-排序+双指针"></a>Approach 1-排序+双指针</h3><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><p>参考 <em>leetcode-cn</em> 官方题解。</p><p>题目中要求找到所有「不重复」且和为 0 的三元组，这个「不重复」的要求使得我们无法简单地使用三重循环枚举所有的三元组。这是因为在最坏的情况下，数组中的元素全部为 0，即</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ..., <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>任意一个三元组的和都为 0。如果我们直接使用三重循环枚举三元组，会得到 <code>O(N^3)</code> 个满足题目要求的三元组（其中 <code>N</code> 是数组的长度），时间复杂度至少为 <code>O(N^3)</code>。在这之后，我们还需要使用哈希表进行去重操作，得到不包含重复三元组的最终答案，又消耗了大量的空间。这个做法的时间复杂度和空间复杂度都很高，因此我们要换一种思路来考虑这个问题。</p><p><strong>「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证</strong></p><ul><li><strong>第二重循环枚举到的元素不小于当前第一重循环枚举到的元素</strong></li><li><strong>第三重循环枚举到的元素不小于当前第二重循环枚举到的元素</strong></li></ul><p>也就是说，我们枚举的三元组 <code>(a,b,c)</code> 满足 <code>$a \leq b \leq c$</code>，保证了只有 <code>(a,b,c)</code> 这个顺序会被枚举到，而 <code>(b,a,c)</code>、<code>(c,b,a)</code> 等等这些不会，这样就减少了重复。要实现这一点，我们可以将数组中的元素从小到大进行排序，随后使用普通的三重循环就可以满足上面的要求。</p><p><strong>同时，对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复。</strong> 举个例子，如果排完序的数组为</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"> ^  ^  ^</span><br></pre></td></tr></table></figure><p>我们使用三重循环枚举到的第一个三元组为 <code>(0,1,2)</code>，如果第三重循环继续枚举下一个元素，那么仍然是三元组 <code>(0,1,2)</code>，产生了重复。<strong>因此我们需要将第三重循环「跳到」下一个不相同的元素</strong>，即数组中的最后一个元素 3，枚举三元组 <code>(0,1,3)</code>。</p><p>下面给出了改进的方法的伪代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums.sort()</span><br><span class="line"><span class="keyword">for</span> first = <span class="number">0</span> .. n-<span class="number">1</span></span><br><span class="line">    <span class="comment">// 只有和上一次枚举的元素不相同，我们才会进行枚举</span></span><br><span class="line">    <span class="keyword">if</span> first == <span class="number">0</span> or nums[first] != nums[first-<span class="number">1</span>] then</span><br><span class="line">        <span class="keyword">for</span> second = first+<span class="number">1</span> .. n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> second == first+<span class="number">1</span> or nums[second] != nums[second-<span class="number">1</span>] then</span><br><span class="line">                <span class="keyword">for</span> third = second+<span class="number">1</span> .. n-<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> third == second+<span class="number">1</span> or nums[third] != nums[third-<span class="number">1</span>] then</span><br><span class="line">                        <span class="comment">// 判断是否有 a+b+c==0</span></span><br><span class="line">                        check(first, second, third)</span><br></pre></td></tr></table></figure><p>这种方法的时间复杂度仍然为 <code>O(N^3)</code>，毕竟我们还是没有跳出三重循环的大框架。然而它是很容易继续优化的。</p><p><strong>可以发现，如果我们固定了前两重循环枚举到的元素 <code>a</code> 和 <code>b</code>，那么只有唯一的 <code>c</code> 满足 <code>a+b+c=0</code>。当第二重循环往后枚举一个元素 <code>b&#39;</code> 时，由于 <code>b&#39; &gt; b</code>，那么满足 <code>a+b&#39;+c&#39;=0</code> 的 <code>c&#39;</code>， 一定有 <code>c&#39; &lt; c</code>，即 <code>c&#39;</code> 在数组中一定出现在 <code>c</code> 的左侧。也就是说，我们可以从小到大枚举 <code>b</code>，同时从大到小枚举 <code>c</code>，即第二重循环和第三重循环实际上是并列的关系。</strong></p><p>有了这样的发现，我们就可以保持第二重循环不变，而<strong>将第三重循环变成一个从数组最右端开始向左移动的指针</strong>，从而得到下面的伪代码</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums.<span class="built_in">sort</span>()</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">first</span> = <span class="number">0</span> .. n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">first</span> == <span class="number">0</span> <span class="keyword">or</span> nums[<span class="keyword">first</span>] != nums[<span class="keyword">first</span><span class="number">-1</span>] <span class="keyword">then</span></span><br><span class="line">       <span class="comment"> // 第三重循环对应的指针</span></span><br><span class="line">        <span class="keyword">third</span> = n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">second</span> = <span class="keyword">first</span>+<span class="number">1</span> .. n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">second</span> == <span class="keyword">first</span>+<span class="number">1</span> <span class="keyword">or</span> nums[<span class="keyword">second</span>] != nums[<span class="keyword">second</span><span class="number">-1</span>] <span class="keyword">then</span></span><br><span class="line">               <span class="comment"> // 向左移动指针，直到 a+b+c 不大于 0</span></span><br><span class="line">                <span class="keyword">while</span> nums[<span class="keyword">first</span>]+nums[<span class="keyword">second</span>]+nums[<span class="keyword">third</span>] &gt; <span class="number">0</span></span><br><span class="line">                    <span class="keyword">third</span> = <span class="keyword">third</span><span class="number">-1</span></span><br><span class="line">               <span class="comment"> // 判断是否有 a+b+c==0</span></span><br><span class="line">                check(<span class="keyword">first</span>, <span class="keyword">second</span>, <span class="keyword">third</span>)</span><br></pre></td></tr></table></figure><p><font color='red'>这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 <code>O(N^2)</code> 减少至 <code>O(N)</code>。</font></p><p><strong>为什么是 <code>O(N)</code> 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 <code>b</code>），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 <code>O(N)</code>，均摊下来，每次也向左移动一个位置，因此时间复杂度为 <code>O(N)</code>。</strong></p><p>注意到我们的伪代码中还有第一重循环，时间复杂度为 <code>O(N)</code>，因此枚举的总时间复杂度为 <code>O(N^2)</code>。由于排序的时间复杂度为 <code>$O(N \log N)$</code>，在渐进意义下小于前者，因此算法的总时间复杂度为 <code>O(N^2)</code>。</p><h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">//数组排序</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">//枚举a</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> first =<span class="number">0</span>;first&lt;n;first++)&#123;</span><br><span class="line">            <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span>(first &gt;<span class="number">0</span> &amp;&amp; nums[first] == nums[first-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// c 对应的指针初始指向数组的最右端</span></span><br><span class="line">            <span class="keyword">int</span> third = n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> target = <span class="number">0</span> - nums[first];</span><br><span class="line">            <span class="comment">//枚举b</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> second = first+<span class="number">1</span>;second&lt;n;second++)&#123;</span><br><span class="line">                <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">                <span class="keyword">if</span>(second &gt; first+<span class="number">1</span> &amp;&amp; nums[second] == nums[second-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">                <span class="keyword">while</span>(second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target)&#123;</span><br><span class="line">                    --third;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">                <span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(second == third)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[second] + nums[third] == target)&#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                    list.add(nums[first]);</span><br><span class="line">                    list.add(nums[second]);</span><br><span class="line">                    list.add(nums[third]);</span><br><span class="line">                    ans.add(list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><h3 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">LeetCode-1. 两数之和</a></li></ul><h3 id="Approach-1-暴力法"><a href="#Approach-1-暴力法" class="headerlink" title="Approach 1-暴力法"></a>Approach 1-暴力法</h3><h4 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h4><p>遍历每个元素 <code>x</code>，并查找是否存在一个值与 <code>target - x</code> 相等的目标元素。</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == target - nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, j &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-两遍哈希表"><a href="#Approach-2-两遍哈希表" class="headerlink" title="Approach 2-两遍哈希表"></a>Approach 2-两遍哈希表</h3><h4 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h4><p>为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。<strong>保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。</strong></p><p>通过以空间换取速度的方式，我们可以将查找时间从 <code>O(n)</code> 降低到 <code>O(1)</code>。哈希表正是为此目的而构建的，它支持以 “近似” 恒定的时间进行快速查找。我用 “近似” 来描述，是因为一旦出现冲突，查找用时可能会退化到 <code>O(n)</code>。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 <code>O(1)</code>。</p><p>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（<code>target - nums[i]</code>）是否存在于表中。注意，该目标元素不能是 <code>nums[i]</code> 本身！</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O(n)</code>，我们把包含有 <code>n</code> 个元素的列表遍历两次。由于哈希表将查找时间缩短到 <code>O(1)</code>，所以时间复杂度为 <code>O(n)</code></li><li>空间复杂度：<code>O(n)</code>，所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 <code>n</code> 个元素</li></ul><h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(complement) &amp;&amp; map.get(complement) != i)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i,map.get(complement)&#125;; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-3-一遍哈希表"><a href="#Approach-3-一遍哈希表" class="headerlink" title="Approach 3-一遍哈希表"></a>Approach 3-一遍哈希表</h3><h4 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h4><p>事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O(n)</code>，我们只遍历了包含有 <code>n</code> 个元素的列表一次。在表中进行的每次查找只花费 <code>O(1)</code> 的时间。</li><li>空间复杂度：<code>O(n)</code>，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 <code>n</code> 个元素。</li></ul><h4 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(complement), i &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录LeetCode题目笔记，汇总LeetCode解答记录&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://lbs0912.github.io/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-009</title>
    <link href="https://lbs0912.github.io/2020/06/15/leetcode-009/"/>
    <id>https://lbs0912.github.io/2020/06/15/leetcode-009/</id>
    <published>2020-06-15T06:35:26.000Z</published>
    <updated>2020-11-01T03:41:46.732Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录LeetCode题目笔记，汇总LeetCode解答记录</li></ul><a id="more"></a><h2 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h2><ul><li>2020/06/14，撰写</li><li>2020/06/15，添加 <em>LeetCode-14. 最长公共前缀</em></li><li>2020/06/15，整理完成</li></ul><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/" target="_blank" rel="noopener">LeetCode-1480. 一维数组的动态和</a></li><li><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">LeetCode-54. 螺旋矩阵</a></li><li><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">LeetCode-59. 螺旋矩阵 II</a></li><li><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">LeetCode-14. 最长公共前缀</a></li><li><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">LeetCode-1300. 转变数组后最接近目标值的数组和</a></li></ul><h2 id="1480-一维数组的动态和"><a href="#1480-一维数组的动态和" class="headerlink" title="1480. 一维数组的动态和"></a>1480. 一维数组的动态和</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/" target="_blank" rel="noopener">LeetCode-1480. 一维数组的动态和</a></li></ul><h3 id="Approach-1-常规求解"><a href="#Approach-1-常规求解" class="headerlink" title="Approach 1-常规求解"></a>Approach 1-常规求解</h3><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><p>本题较简单，不再赘述。</p><p>可以直接在原来数组上计算修改。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] runningSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            nums[i] += nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">LeetCode-54. 螺旋矩阵</a></li></ul><h3 id="Approach-1-模拟"><a href="#Approach-1-模拟" class="headerlink" title="Approach 1-模拟"></a>Approach 1-模拟</h3><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><p>模拟螺旋矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，则顺时针旋转，进入下一个方向。</p><p>判断路径是否进入之前访问过的位置，需要使用一个与输入矩阵大小相同的辅助矩阵   <code>visited</code>，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 <code>visited</code> 中的对应位置的元素设为已访问。</p><p>如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-54-method-1.png" alt=""></p><p><strong>代码实现过程中，可以定义一个方向数组，来表示路径模拟的4个方向，如上图中4个红色的箭头所示。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义方向数组</span></span><br><span class="line"> <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><ol><li><strong>从左上角顶点到右上角顶点，数组横坐标不变，纵坐标加1，因此，方向向量为 <code>(0,1)</code></strong></li><li><strong>从右上角顶点到右下角顶点，数组横坐标不变，纵坐标加1，因此，方向向量为 <code>(1,0)</code></strong></li><li><strong>从右下角顶点到左下角顶点，数组横坐标不变，纵坐标减1，因此，方向向量为 <code>(0,-1)</code></strong></li><li><strong>从左下角顶点到左上角顶点，数组横坐标减1，纵坐标不变，因此，方向向量为 <code>(-1,0)</code></strong></li></ol><p>复杂度分析</p><ul><li>时间复杂度：<code>O(mn)</code>，其中 m 和 n 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。</li><li>空间复杂度：<code>O(mn)</code>。需要创建一个大小为 <code>m × n</code> 的矩阵 <code>visited</code> 记录每个位置是否被访问过。</li></ul><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><ul><li>java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; order = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> order;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//数组总元素</span></span><br><span class="line">        <span class="keyword">int</span> total = rows*columns;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][columns];</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义方向数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            order.add(matrix[row][column]);</span><br><span class="line">            visited[row][column] = <span class="keyword">true</span>;  <span class="comment">//标记已经访问</span></span><br><span class="line">            <span class="keyword">int</span> nextRow = row + directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> nextColumn = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nextRow &lt; <span class="number">0</span> || nextRow &gt;= rows || nextColumn &lt; <span class="number">0</span> || nextColumn &gt;= columns || visited[nextRow][nextColumn])&#123;</span><br><span class="line">                directionIndex = (directionIndex+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新directionIndex后，计算出新的row column</span></span><br><span class="line">            row = row +  directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            column = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-按层模拟"><a href="#Approach-2-按层模拟" class="headerlink" title="Approach 2-按层模拟"></a>Approach 2-按层模拟</h3><h4 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h4><p>可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。</p><p>定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，剩下的元素都是第 3 层。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于 <code>(top,left)</code>，右下角位于 <code>(bottom,right)</code>，按照如下顺序遍历当前层的元素。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-54-method-1.png" alt=""></p><ol><li>从左到右遍历上侧元素，依次为 <code>(top,left)</code> 到 <code>(top,right)</code>。</li><li>从上到下遍历右侧元素，依次为 <code>(top+1,right)</code> 到 <code>(bottom,right)</code>。</li><li>如果 <code>left &lt; right</code> 且 <code>top &lt; bottom</code>，则从右到左遍历下侧元素，依次为 <code>(bottom,right−1)</code> 到 <code>(bottom,left+1)</code>。以及从下到上遍历左侧元素，依次为 <code>(bottom,left)</code> 到 <code>(top+1,left)</code>。</li></ol><p>遍历完当前层的元素之后，将 <code>left</code> 和 <code>top</code> 分别增加 1，将 <code>right</code> 和 <code>bottom</code> 分别减少 1，进入下一层继续遍历，直到遍历完所有元素为止。</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O(mn)</code>，其中 m 和 n 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。</li><li>空间复杂度：<code>O(1)</code>。除了输出数组以外，空间复杂度是常数。</li></ul><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><ul><li>java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; order = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> order;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = columns - <span class="number">1</span>, top = <span class="number">0</span>, bottom = rows - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> column = left; column &lt;= right; column++) &#123;</span><br><span class="line">                order.add(matrix[top][column]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> row = top + <span class="number">1</span>; row &lt;= bottom; row++) &#123;</span><br><span class="line">                order.add(matrix[row][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> column = right - <span class="number">1</span>; column &gt; left; column--) &#123;</span><br><span class="line">                    order.add(matrix[bottom][column]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> row = bottom; row &gt; top; row--) &#123;</span><br><span class="line">                    order.add(matrix[row][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a>59. 螺旋矩阵 II</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">LeetCode-59. 螺旋矩阵 II</a></li></ul><h3 id="Approach-1-模拟-1"><a href="#Approach-1-模拟-1" class="headerlink" title="Approach 1-模拟"></a>Approach 1-模拟</h3><h4 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h4><p>参考 <em>LeetCode Notes-54. 螺旋矩阵</em> 中方法1的思路求解。</p><p>对于数组赋值，可以使用数组元素是否为0（数组初始化元素为0）来区分该元素是否已经被赋值。</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O(n^2)</code>，填充时候遍历了数组元素。</li><li>空间复杂度：<code>O(n^2)</code>，需要一个 <code>n*n</code> 的数组来存储结果。</li></ul><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> total = n*n;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=total;i++)&#123;</span><br><span class="line">            arr[row][col] = i;</span><br><span class="line">            <span class="keyword">int</span> nextRow = row + directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> nextCol = col + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//arr[row][col] != 0 标记元素已经被访问</span></span><br><span class="line">            <span class="keyword">if</span>(nextRow &lt; <span class="number">0</span> || nextRow &gt;= n || nextCol &lt;<span class="number">0</span> || nextCol &gt;= n || arr[nextRow][nextCol] != <span class="number">0</span>)&#123;</span><br><span class="line">                directionIndex = (directionIndex+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新row col</span></span><br><span class="line">            row = row + directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            col = col + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">LeetCode-14. 最长公共前缀</a></li></ul><h3 id="Approach-1-横向扫描"><a href="#Approach-1-横向扫描" class="headerlink" title="Approach 1-横向扫描"></a>Approach 1-横向扫描</h3><h4 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h4><p>求解整个数组的最长公共前缀，可以</p><ol><li>先求解前2个元素的最长公共前缀 <code>prefix</code></li><li>再求解 <code>prefix</code> 和第3个元素的最长公共前缀，并更新 <code>prefix</code></li><li>再求解 <code>prefix</code> 和第4个元素的最长公共前缀，并更新 <code>prefix</code></li><li>…</li></ol><p>基于上述思路，对数组元素进行横向扫描，可以求解出整个数组的最长公共前缀。</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O(mn)</code>，其中 <code>m</code> 是字符串数组中的字符串的平均长度，<code>n</code> 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。</li><li>空间复杂度：<code>O(1)</code>。使用的额外空间复杂度为常数。</li></ul><h4 id="Solutiob"><a href="#Solutiob" class="headerlink" title="Solutiob"></a>Solutiob</h4><ul><li>java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;count;i++)&#123;</span><br><span class="line">            prefix = longestCommonPrefix(prefix,strs[i]);</span><br><span class="line">            <span class="keyword">if</span>(prefix.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//如果前缀字符串长度为0 可直接返回</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = Math.min(str1.length(),str2.length());</span><br><span class="line">        <span class="keyword">int</span>  index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1.charAt(i) != str2.charAt(i))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-二分查找"><a href="#Approach-2-二分查找" class="headerlink" title="Approach 2-二分查找"></a>Approach 2-二分查找</h3><h4 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h4><p>参见 <em>leetcode-cn 官方题解。</em></p><p><strong>显然，最长公共前缀的长度不会超过字符串数组中的最短字符串的长度。</strong> 用 <code>minLength}minLength</code> 表示字符串数组中的最短字符串的长度，则可以在 <code>[0,minLength]</code> 的范围内通过二分查找得到最长公共前缀的长度。每次取查找范围的中间值 <code>mid</code>，判断每个字符串的长度为 <code>mid</code> 的前缀是否相同，如果相同则最长公共前缀的长度一定大于或等于 <code>mid</code>，如果不相同则最长公共前缀的长度一定小于 <code>mid</code>，通过上述方式将查找范围缩小一半，直到得到最长公共前缀的长度。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-14-longgest-prefix-1.jpg" alt=""></p><p>复杂度分析</p><ul><li>时间复杂度：<code>$O(mn \log m)$</code>，其中 <code>m</code> 是字符串数组中的字符串的最小长度，<code>n</code> 是字符串的数量。二分查找的迭代执行次数是 <code>$O(\log m)$</code>，每次迭代最多需要比较 <code>mn</code> 个字符，因此总时间复杂度是 <code>$O(mn \log m)$</code>。</li><li>空间复杂度：<code>O(1)</code>。使用的额外空间复杂度为常数。</li></ul><h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><ul><li>java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minLength = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//计算数组中字符的最小长度</span></span><br><span class="line">        <span class="keyword">for</span>(String str:strs)&#123;</span><br><span class="line">            minLength = Math.min(minLength,str.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high =  minLength;</span><br><span class="line">        <span class="comment">//二分查找</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="comment">// int mid = (low+high)/2;</span></span><br><span class="line">            <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="comment">// int mid = low + (high - low) / 2;</span></span><br><span class="line">            <span class="keyword">if</span>(isCommonPrefix(strs,mid))&#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>,low);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        String str0 = strs[<span class="number">0</span>].substring(<span class="number">0</span>,length);</span><br><span class="line">        <span class="keyword">int</span> count = strs.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;count;i++)&#123;</span><br><span class="line">            String str = strs[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str0.charAt(j) != str.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处，对二分查找中 <code>mid</code> 的计算做如下说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(low &lt; high&gt;)&#123;</span><br><span class="line">    <span class="comment">// int mid = (low+high)/2;</span></span><br><span class="line">    <span class="keyword">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">    <span class="comment">// int mid = low + (high - low) / 2;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>不使用 <code>mid = (low+high)/2</code>，是因为数据相加容易产生溢出</li><li>在数组长度大于1的情况下，一般使用 <code>mid = low + (high - low) / 2</code> 计算</li><li><strong>如果数组长度为1，这个时候 <code>low=0, high=1</code>，计算的 <code>mid = low + (high - low) / 2 = 0</code>，会造成无限循环。如果使用 <code>mid = (high - low + 1) / 2 + low</code> 计算，则 <code>mid = 1 = high</code>，在后续循环中执行 <code>high = mid-1</code>，从而使得 <code>low = high</code>，结束了 while 循环。</strong></li></ol><h2 id="1300-转变数组后最接近目标值的数组和"><a href="#1300-转变数组后最接近目标值的数组和" class="headerlink" title="1300. 转变数组后最接近目标值的数组和"></a>1300. 转变数组后最接近目标值的数组和</h2><h3 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">LeetCode-1300. 转变数组后最接近目标值的数组和</a></li></ul><h3 id="Approach-1-排序后遍历数组"><a href="#Approach-1-排序后遍历数组" class="headerlink" title="Approach 1-排序后遍历数组"></a>Approach 1-排序后遍历数组</h3><h4 id="Analysis-6"><a href="#Analysis-6" class="headerlink" title="Analysis"></a>Analysis</h4><p>题意可以总结为，找到某个 <code>value</code> 值，将大于 <code>value</code> 的数组元素缩小到 <code>value</code>，使得数组总和最接近 <code>target</code>。</p><p>分析题意，有如下思路</p><ol><li>对数组进行排序。</li><li>若数组本身求和小于等于 <code>target</code>，则没有必要再缩小某些值了，直接返回数组的最大值即可。</li><li>否则，用 <code>target</code> 值除以数组长度，得到一个平均值，对平均值上下的两个整数值进行判断，并返回</li></ol><p>于是乎，很容易有如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//该代码并不能通过所有测试用例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBestValue</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minDistance = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:arr)&#123;</span><br><span class="line">            max = Math.max(max,num);</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt;= target)&#123;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//平均值  向下取整</span></span><br><span class="line">        <span class="comment">//后续对平均值向上取整也进行判断</span></span><br><span class="line">        <span class="keyword">int</span> avgValue = target/arr.length;</span><br><span class="line">        <span class="keyword">if</span>((target - avgValue*arr.length) &lt; ((avgValue+<span class="number">1</span>)*arr.length - target))&#123;</span><br><span class="line">            <span class="keyword">return</span> avgValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  avgValue+<span class="number">1</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交代码，会发现对于下述测试用例，计算结果并不符合预期</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试用例</span></span><br><span class="line">[<span class="number">1547</span>,<span class="number">83230</span>,<span class="number">57084</span>,<span class="number">93444</span>,<span class="number">70879</span>]</span><br><span class="line"><span class="number">71237</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//预期正确结果</span></span><br><span class="line"><span class="number">17422</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">//程序返回的错误结果</span></span><br><span class="line"><span class="number">14247</span></span><br></pre></td></tr></table></figure><p>产生错误的原因是，若数组中有小于平均值的元素 <code>arr[i]</code>，在最后在和 <code>target</code> 值比较时，这些元素 <code>arr[i]</code> 并不会被替换为平均值参与计算，因此导致了这种情况下，计算出的数组平均值并不是符合要求的 <code>value</code> 值。</p><p>下面对求解思路进行逻辑完善。</p><ol><li>对数组进行排序。</li><li>若数组本身求和小于等于 <code>target</code>，则没有必要再缩小某些值了，直接返回数组的最大值即可。</li><li>否则，用 <code>target</code> 值除以数组长度，得到一个平均值 <code>avgValue</code>。</li><li><strong>若计算出的平均值 <code>avgValue</code>，小于数组的每一个元素，则说明数组的每一个元素值都会被替换。此时结果一定是平均值上下的两个整数中的一个。</strong></li><li>若不满足步骤4，则对数组进行遍历</li></ol><ul><li>对于已经排序好的数组，分别取 <code>value</code> 为数组中的第 <code>i</code> 个元素值，直到发现 <code>sum &gt;= target</code>。</li><li>此时记录第 <code>i</code> 个元素左边的元素和为 <code>sumLeft</code>，那么如果 <code>i</code> 和 <code>i</code> 右边的数字全部变成 <code>ans = (target - sumLeft)/(n - i)</code>，这个时候总和就是 <code>sumLeft + ans*(n - i) = target</code>。</li><li>这个时候计算出的 <code>ans</code> 就是最后要返回的结果，对其上下两个临近的整数值判断并返回正确结果即可。</li></ul><p>复杂度分析</p><ul><li>时间复杂度：<code>O((N)</code>，进行了数组遍历</li><li>空间复杂度：<code>O(1)</code>。</li></ul><blockquote><p>在 <code>leetcode-cn</code> 平台测试，方法1执行用时4ms，内存消耗40MB；下述方法2执行用时32ms，内存消耗40.1MB；</p></blockquote><h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><ul><li>java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBestValue</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(arr);   <span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">int</span> sumArr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> arrLength =  arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:arr)&#123;</span><br><span class="line">            sumArr += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sumArr &lt;= target)&#123; <span class="comment">//若数组和不大于target，返回数组的最大值</span></span><br><span class="line">            <span class="keyword">return</span> arr[arrLength-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//全部替换为数组最小值，求和若大于target</span></span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>]*arrLength &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">int</span> avgValue = target/arrLength;</span><br><span class="line">            <span class="keyword">if</span>((target - avgValue*arrLength) &lt; ((avgValue+<span class="number">1</span>)*arrLength - target))&#123;</span><br><span class="line">                <span class="keyword">return</span> avgValue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span>  avgValue+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sumLeft = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arrLength;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = sumLeft + arr[i]*(arrLength-i);</span><br><span class="line">            <span class="comment">//最开始时，sum是小于target的</span></span><br><span class="line">            <span class="comment">//从sum&lt;target  到 sum&gt;=target，说明中间一定遇到了最合适的value值                                                                                   </span></span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                <span class="keyword">int</span> ans = (target - sumLeft)/(arrLength - i);</span><br><span class="line">                <span class="keyword">if</span>(target - sumLeft - ans*(arrLength - i) &lt;= (ans + <span class="number">1</span>) * (arrLength - i) + sumLeft - target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sumLeft += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-枚举-二分查找"><a href="#Approach-2-枚举-二分查找" class="headerlink" title="Approach 2-枚举+二分查找"></a>Approach 2-枚举+二分查找</h3><h4 id="Analysis-7"><a href="#Analysis-7" class="headerlink" title="Analysis"></a>Analysis</h4><p>分析题意可知，要返回的 <code>value</code> 值的取值范围在区间 <code>[1,arrMaxNum]</code>中，即最小值可能是1，最大值是数组元素的最大值。因此可以枚举 <code>value</code> 的可能取值进行求解。</p><p>当枚举到 <code>value=x</code> 时，我们需要将数组 <code>arr</code> 中所有小于等于 <code>x</code> 的值保持不变，所有大于 <code>x</code> 的值变为 <code>x</code>。要实现这个操作，我们可以将数组 <code>arr</code> 先进行排序，随后进行二分查找，找出数组 <code>arr</code> 中最小的比 <code>x</code> 大的元素 <code>arr[i]</code>。此时数组的和变为</p><p><code>arr[0] + ... + arr[i - 1] + x * (n - i)</code></p><p>为了加速求和操作，我们可以预处理出数组 <code>arr</code> 的前缀和，这样数组求和的时间复杂度即能降为 <code>O(1)</code>。我们将和与 <code>target</code> 进行比较，同时更新答案即可。</p><p>复杂度分析</p><ul><li>时间复杂度：<code>$O((N + C)\log N)$</code>，其中 N 是数组 <code>arr</code> 的长度，C 是一个常数，为数组 <code>arr</code> 中的最大值，不会超过 <code>$10^5$</code>。排序需要的时间复杂度为 <code>$O(N\log N)$</code>，二分查找的单次时间复杂度为 <code>$O(\log N)$</code>，需要进行 C 次。</li><li>空间复杂度：<code>O(N)</code>。我们需要 <code>O(N)</code> 的空间用来存储数组 <code>arr</code> 的前缀和，排序需要 <code>O(logN)</code> 的栈空间，因此最后总空间复杂度为 <code>O(N)</code>。</li></ul><h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><ul><li>java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBestValue</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="comment">//数组前缀和 prefix[i]表示数组前i个元素的和  </span></span><br><span class="line">        <span class="comment">// prefix[1] = arr[0]   prefix[0] = 0  </span></span><br><span class="line">        <span class="keyword">int</span>[] prefix =  <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            prefix[i] = arr[i-<span class="number">1</span>] + prefix[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> diff = target;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=arr[n-<span class="number">1</span>];i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = Arrays.binarySearch(arr,i);</span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//未找到 计算出正确的插入点</span></span><br><span class="line">                <span class="comment">// index = -(insert point + 1)</span></span><br><span class="line">                <span class="comment">// index = -index-1 = (insert point + 1)-1 = insert point</span></span><br><span class="line">                index = -index-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> cur = prefix[index] + (n-index)*i;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(cur - target) &lt; diff)&#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                diff = Math.abs(cur - target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录LeetCode题目笔记，汇总LeetCode解答记录&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://lbs0912.github.io/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-008</title>
    <link href="https://lbs0912.github.io/2020/06/14/leetcode-008/"/>
    <id>https://lbs0912.github.io/2020/06/14/leetcode-008/</id>
    <published>2020-06-14T06:35:26.000Z</published>
    <updated>2020-11-01T03:41:08.295Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录LeetCode题目笔记，汇总LeetCode解答记录</li></ul><a id="more"></a><h2 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h2><ul><li>2020/05/12，撰写</li><li>2020/06/13，整理完成</li></ul><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener">LeetCode-1371. 每个元音包含偶数次的最长子字符串</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">LeetCode-5. 最长回文子串</a></li><li><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">LeetCode-207. 课程表</a></li><li><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">LeetCode-70. 爬楼梯</a></li><li><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">LeetCode-739. 每日温度</a></li></ul><h2 id="1371-每个元音包含偶数次的最长子字符串"><a href="#1371-每个元音包含偶数次的最长子字符串" class="headerlink" title="1371. 每个元音包含偶数次的最长子字符串"></a>1371. 每个元音包含偶数次的最长子字符串</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener">LeetCode-1371. 每个元音包含偶数次的最长子字符串</a></li></ul><h3 id="Approach-1-前缀和-状态压缩"><a href="#Approach-1-前缀和-状态压缩" class="headerlink" title="Approach 1-前缀和+状态压缩"></a>Approach 1-前缀和+状态压缩</h3><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><p>参考 <code>leetcode-cn</code> 官方题解。</p><p>我们先来考虑暴力方法怎么做。最直观的方法无非就是枚举所有子串，遍历子串中的所有字符，统计元音字母出现的个数。如果符合条件，我们就更新答案，但这样肯定会因为超时而无法通过所有测试用例。</p><p>再回顾一下上面的操作，其实每个子串对应着一个区间，那么有什么方法可以在不重复遍历子串的前提下，快速求出这个区间里元音字母出现的次数呢？<strong>答案就是前缀和，对于一个区间，我们可以用两个前缀和的差值，得到其中某个字母的出现次数。</strong></p><p>我们对每个元音字母维护一个前缀和，定义 <code>pre[i][k]</code> 表示在字符串前 <code>i</code> 个字符中，第 <code>k</code> 个元音字母一共出现的次数。假设我们需要求出 <code>[l,r]</code> 这个区间的子串是否满足条件，那么我们可以用 <code>pre[r][k] - pre[l-1][k]</code>，在 <code>O(1)</code> 的时间得到第 <code>k</code> 个元音字母出现的次数。对于每一个元音字母，我们都判断一下其是否出现偶数次即可。</p><p>我们利用前缀和优化了统计子串的时间复杂度，然而枚举所有子串的复杂度仍需要 <code>O(n^2)</code>，不足以通过本题，还需要继续进行优化，避免枚举所有子串。我们考虑枚举字符串的每个位置 <code>i</code> ，计算以它结尾的满足条件的最长字符串长度。其实我们要做的就是快速找到最小的 <code>$j \in [0,i)$</code>，满足 <code>pre[i][k]-pre[j][k]</code>（即每一个元音字母出现的次数）均为偶数，那么以 <code>i</code> 结尾的最长字符串 <code>s[j+1,i]</code> 长度就是 <code>i-j</code>。</p><p>有经验的读者可能马上就想到了利用哈希表来优化查找的复杂度，但是单单利用前缀和，我们无法找到 <code>i</code> 和 <code>j</code> 相关的恒等式，像 <a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">1248. 统计优美子数组</a>  这道题我们是能明确知道两个前缀的差值是恒定的。那难道就没办法了么？</p><p>其实不然，这道题我们还有一个性质没有充分利用：我们需要找的子串中，每个元音字母都恰好出现了偶数次。</p><p><strong>偶数这个条件其实告诉了我们，对于满足条件的子串而言，两个前缀和 <code>pre[i][k]</code> 和 <code>pre[j][k]</code> 的奇偶性一定是相同的，因为小学数学的知识告诉我们：奇数减奇数等于偶数，偶数减偶数等于偶数。因此我们可以对前缀和稍作修改，从维护元音字母出现的次数改作维护元音字母出现次数的奇偶性。</strong></p><p>这样我们只要实时维护每个元音字母出现的奇偶性，那么 <code>s[j+1,i]</code> 满足条件当且仅当对于所有的 <code>k</code>，<code>pre[i][k]</code> 和 <code>pre[j][k]</code> 的奇偶性都相等，此时我们就可以利用哈希表 <strong>存储每一种奇偶性（即考虑所有的元音字母）对应最早出现的位置</strong>，边遍历边更新答案。</p><p>题目做到这里基本上做完了，但是我们还可以进一步优化我们的编码方式，如果直接以每个元音字母出现次数的奇偶性为哈希表中的键，难免有些冗余，我们可能需要额外定义一个状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  a: cnta, <span class="comment">// a 出现次数的奇偶性</span></span><br><span class="line">  e: cnte, <span class="comment">// e 出现次数的奇偶性</span></span><br><span class="line">  i: cnti, <span class="comment">// i 出现次数的奇偶性</span></span><br><span class="line">  o: cnto, <span class="comment">// o 出现次数的奇偶性</span></span><br><span class="line">  u: cntu  <span class="comment">// u 出现次数的奇偶性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这么一个结构当作我们哈希表存储的键值，如果题目稍作修改扩大了字符集，那么维护起来可能会比较吃力。考虑到出现次数的奇偶性其实无非就两个值，<code>0</code> 代表出现了偶数次，<code>1</code> 代表出现了奇数次，我们可以将其压缩到一个二进制数中，第 <code>k</code> 位的 <code>0</code> 或 <code>1</code> 代表了第 <code>k</code> 个元音字母出现的奇偶性。</p><p>举一个例子，假如到第 <code>i</code> 个位置，<code>u o i e a</code> 出现的奇偶性分别为 <code>1 1 0 0 1</code>，那么我们就可以将其压成一个二进制数 <code>$(11001)_2=(25)_{10}$</code> 作为它的状态。这样我们就可以将 5 个元音字母出现次数的奇偶性压缩到了一个二进制数中，且连续对应了二进制数的  <code>$[(00000)_2,(11111)_2]$</code> 的范围，转成十进制数即 <code>[0,31]</code>。因此我们也不再需要使用哈希表，<strong>直接用一个长度为 32 的数组来存储对应状态出现的最早位置即可</strong>。</p><p>复杂度分析</p><ol><li>时间复杂度：<code>O(n)</code>，其中 n 为字符串的长度。我们只需要遍历一遍字符串即可求得答案。</li><li>空间复杂度：<code>O(S)</code>，其中 S 表示元音字母压缩成一个状态数的最大值，在本题中 <code>S = 32</code>。我们需要对应 <code>S</code> 大小的空间来存放每个状态第一次出现的位置，因此需要 <code>O(S)</code> 的空间复杂度。</li></ol><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="comment">//共5个字母，奇偶状态排列 计数最大值为1&lt;&lt;5</span></span><br><span class="line">        <span class="comment">//用一个32为数组pos，存放从0到i，第一次出现[a,e,i,o,u]各种奇偶情况的位置</span></span><br><span class="line">        <span class="comment">//从00000-11111种状态，代表5个元音字母的个数是否为偶数，0代表偶数，1代表奇数</span></span><br><span class="line">        <span class="keyword">int</span>[] bitNumArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>&lt;&lt;<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//初始化填充为-1，区分00000的情况</span></span><br><span class="line">        Arrays.fill(bitNumArr,-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//aeiou 都不出现，即bitNumArr[0]</span></span><br><span class="line">        <span class="comment">//即空字符串，字符串下标i=0 </span></span><br><span class="line">        bitNumArr[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">        <span class="comment">//最大子串长度</span></span><br><span class="line">        <span class="keyword">int</span> maxSubStrLength = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'a'</span>)&#123;</span><br><span class="line">                <span class="comment">//与1异或，相同为0，不同为1</span></span><br><span class="line">                status ^= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'e'</span>)&#123;</span><br><span class="line">                 status ^= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'i'</span>)&#123;</span><br><span class="line">                 status ^= (<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'o'</span>)&#123;</span><br><span class="line">                 status ^= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'u'</span>)&#123;</span><br><span class="line">                 status ^= (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果status对应的bitNumArr[status]大于0 说明已经找到符合要求的子串</span></span><br><span class="line">            <span class="comment">//因为两个子串的奇偶性相等，说明中间子串是符合要求的</span></span><br><span class="line">            <span class="comment">//奇偶性相同的两个数的差，必定为偶数 只会有一个偶数00000</span></span><br><span class="line">            <span class="comment">//因此出现两个相同状态的数，他们中间必定出现了偶数次数的aeiou</span></span><br><span class="line">            <span class="keyword">if</span>(bitNumArr[status] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                maxSubStrLength = Math.max(maxSubStrLength,i+<span class="number">1</span>-bitNumArr[status]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//bitNumArr[status]==-1 说明status是第一次出现，只保存这个值</span></span><br><span class="line">                bitNumArr[status] = i+<span class="number">1</span>;  <span class="comment">//i&lt;length  此处保存的是字符串的长度  所以是i+1 不是i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSubStrLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里需要说明的是，在代码中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(bitNumArr[status] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    maxSubStrLength = Math.max(maxSubStrLength,i+<span class="number">1</span>-bitNumArr[status]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    bitNumArr[status] = i+<span class="number">1</span>;  <span class="comment">//i&lt;length  此处保存的是字符串的长度  所以是i+1 不是i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bitNumArr[status]</code> 存储的是 <code>i+1</code>，不是 <code>i</code>，其原因如下</p><ol><li>为了保证第一个字母是辅音字母时也可以输出正确的值</li><li>因为如果改为 <code>bitNumArr[status] = i;</code> 那相应的 <code>if</code> 语句要改为 <code>maxSubStrLength = max(maxSubStrLength, i - bitNumArr[status]);</code>，这样当第一个字母为辅音时，<code>status = 0</code>, <code>if</code> 判为真，<code>maxSubStrLength</code> 就会被赋值为 0，这显然不是正确的。</li><li>同时题解中是用 <code>bitNumArr[status]</code> 是不是等于 -1 来判断前面是否出现过与 status 相同的奇偶性，所以也不能初始化为 <code>bitNumArr[0] = -1</code>。就只好多加一个 1。</li></ol><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">LeetCode-5. 最长回文子串</a></li></ul><h3 id="Approach-1-动态规划"><a href="#Approach-1-动态规划" class="headerlink" title="Approach 1-动态规划"></a>Approach 1-动态规划</h3><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><p>对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 <code>&quot;ababa&quot;</code>，如果我们已经知道 <code>&quot;bab&quot;</code> 是回文串，那么 <code>&quot;ababa&quot;</code> 一定是回文串，这是因为它的首尾两个字母都是 <code>&quot;a&quot;</code>。</p><p>根据这样的思路，我们就可以用动态规划的方法解决本题。我们用 <code>P(i,j)</code> 表示字符串 <code>s</code> 的第 <code>i</code> 到 <code>j</code> 个字母组成的串（下文表示成 <code>s[i:j]</code>）是否为回文串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(i,j) = \begin&#123;cases&#125; \text&#123;true,&#125; &amp;\quad\text&#123;如果子串~&#125; S_i \dots S_j \text&#123;~是回文串&#125;\\ \text&#123;false,&#125; &amp;\quad\text&#123;其它情况&#125; \end&#123;cases&#125;</span><br></pre></td></tr></table></figure><p>这里的「其它情况」包含两种可能性</p><ol><li><code>s[i,j]</code> 本身不是一个回文串</li><li><code>i &gt; j</code>，此时 <code>s[i,j]</code> 本身不合法</li></ol><p>那么我们就可以写出动态规划的状态转移方程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(i, j) = P(i+1, j-1) \wedge (S_i == S_j)</span><br></pre></td></tr></table></figure><p>也就是说，只有 <code>s[i+1:j-1]</code> 是回文串，并且 <code>s</code> 的第 <code>i</code> 和 <code>j</code> 个字母相同时，<code>s[i:j]</code> 才会是回文串。</p><p>上文的所有讨论是建立在子串长度大于 2 的前提之上的，我们还需要考虑动态规划中的边界条件，即子串的长度为 <code>1</code> 或 <code>2</code>。对于长度为 1 的子串，它显然是个回文串；对于长度为 2 的子串，只要它的两个字母相同，它就是一个回文串。因此我们就可以写出动态规划的边界条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;cases&#125; P(i, i) = \text&#123;true&#125; \\ P(i, i+1) = ( S_i == S_&#123;i+1&#125; ) \end&#123;cases&#125;</span><br></pre></td></tr></table></figure><p>根据这个思路，我们就可以完成动态规划了，最终的答案即为所有 <code>P(i,j) = true</code> 中 <code>j-i+1</code>（即子串长度）的最大值。</p><p><strong>注意，在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，因此一定要注意动态规划的循环顺序。</strong></p><p>复杂度分析</p><ol><li>时间复杂度：<code>O(n^2)</code>，其中 <code>n</code> 是字符串的长度。动态规划的状态总数为 <code>O(n^2)</code>，对于每个状态，我们需要转移的时间为 <code>O(1)</code>。</li><li>空间复杂度：<code>O(n^2)</code>，即存储动态规划状态需要的空间。</li></ol><p>（待后续加深补充）</p><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><ul><li>C++</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; dp(n, vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; ++l) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + l &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + l;</span><br><span class="line">                <span class="keyword">if</span> (l == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (l == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = (s[i] == s[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; l + <span class="number">1</span> &gt; ans.size()) &#123;</span><br><span class="line">                    ans = s.substr(i, l + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-中心扩展算法"><a href="#Approach-2-中心扩展算法" class="headerlink" title="Approach 2-中心扩展算法"></a>Approach 2-中心扩展算法</h3><h4 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h4><p>我们仔细观察一下方法一中的状态转移方程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;cases&#125; P(i, i) &amp;=\quad \text&#123;true&#125; \\ P(i, i+1) &amp;=\quad ( S_i == S_&#123;i+1&#125; ) \\ P(i, j) &amp;=\quad P(i+1, j-1) \wedge (S_i == S_j) \end&#123;cases&#125;</span><br></pre></td></tr></table></figure><p>找出其中的状态转移链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(i, j) \leftarrow P(i+1, j-1) \leftarrow P(i+2, j-2) \leftarrow \cdots \leftarrow \text&#123;某一边界情况&#125;</span><br></pre></td></tr></table></figure><p><strong>可以发现，所有的状态在转移的时候的可能性都是唯一的。也就是说，我们可以从每一种边界情况开始「扩展」，也可以得出所有的状态对应的答案。</strong></p><p><strong>边界情况即为子串长度为 1 或 2 的情况。我们枚举每一种边界情况，并从对应的子串开始不断地向两边扩展。如果两边的字母相同，我们就可以继续扩展，例如从 <code>P(i+1,j-1)</code> 扩展到 <code>P(i,j)</code>；如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了。</strong></p><p>聪明的读者此时应该可以发现，<strong>「边界情况」对应的子串实际上就是我们「扩展」出的回文串的「回文中心」。方法二的本质即为：我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。我们对所有的长度求出最大值，即可得到最终的答案。</strong></p><p>复杂度分析</p><ol><li>时间复杂度：<code>O(n^2)</code>，其中 <code>n</code> 是字符串的长度。长度为 1 和 2 的回文中心分别有 n 和 <code>n-1</code> 个，每个回文中心最多会向外扩展 <code>O(n)</code> 次。</li><li>空间复杂度：<code>O(1)</code>。</li></ol><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">        <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">            L--;</span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a>207. 课程表</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">LeetCode-207. 课程表</a></li></ul><h3 id="Approach-1-拓扑排序"><a href="#Approach-1-拓扑排序" class="headerlink" title="Approach 1-拓扑排序"></a>Approach 1-拓扑排序</h3><h4 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h4><p>本题的实质问题是判断是否是有向无环图（DAG）（即不能存在环）。</p><p>即课程间规定了前置条件，但不能构成任何环路，否则课程前置条件将不成立。</p><p>可以使用拓扑排序求解。</p><p>思路是通过 <strong>拓扑排序</strong> 判断此课程安排图是否是<strong>有向无环图(DAG)</strong> 。 </p><p>具体分析，参考<code>《数据结构 Notes 2-图》</code>笔记中的 <code>拓扑排序</code> 章节。</p><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个数组来存储课程的入度</span></span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="comment">// 定义一个队列用来排序</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化所有课程的入度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> [] arr:prerequisites)&#123;</span><br><span class="line">            <span class="comment">//比如对于[1,0]，表示学习课程1之前，需要先完成课程0</span></span><br><span class="line">            <span class="comment">//因此课程1的入度需要加1 </span></span><br><span class="line">            indegree[arr[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将所有入度为0的课程入队, 然后将入度标记为-1，防止后面重复入队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;indegree.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">                indegree[i] --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始出队，每出队一门课，就维护入度数组</span></span><br><span class="line">        <span class="comment">// 然后将所有入度为0的数组入队，然后将入度标记为-1，防止后面重复入队</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//移除并返问队列头部的元素。如果队列为空，则返回null</span></span><br><span class="line">            <span class="keyword">int</span> course = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] arr:prerequisites)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[<span class="number">1</span>] == course)&#123;</span><br><span class="line">                    indegree[arr[<span class="number">0</span>]]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;indegree.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.add(i);</span><br><span class="line">                    indegree[i] --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历indegree中入度为-1的数量，也就是已经完成的课程数</span></span><br><span class="line">        <span class="comment">// 和numCourses一样就返回true，否则返回false</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indegree.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == -<span class="number">1</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == numCourses ? <span class="keyword">true</span> : <span class="keyword">false</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-拓扑排序（广度优先）"><a href="#Approach-2-拓扑排序（广度优先）" class="headerlink" title="Approach 2-拓扑排序（广度优先）"></a>Approach 2-拓扑排序（广度优先）</h3><h4 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h4><ol><li>统计课程安排图中每个节点的入度，生成 <em>入度表</em> <code>indegrees</code>。</li><li>借助一个队列 <code>queue</code>，将所有入度为 0 的节点入队。</li><li>当 <code>queue</code> 非空时，依次将队首节点出队，在课程安排图中删除此节点 pre<ul><li>并不是真正从邻接表中删除此节点 <code>pre</code>，而是将此节点对应所有邻接节点 <code>cur</code> 的入度 −1，即 <code>indegrees[cur] -= 1</code></li><li>当入度 <code>-1</code> 后邻接节点 <code>cur</code> 的入度为 0，说明 <code>cur</code> 所有的前驱节点已经被 “删除”，此时将 <code>cur</code> 入队</li></ul></li><li>在每次 <code>pre</code> 出队时，执行 <code>numCourses--</code><ul><li>若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 0</li><li>因此，拓扑排序出队次数等于课程个数，返回 <code>numCourses == 0</code> 判断课程是否可以成功安排</li></ul></li></ol><p>复杂度分析</p><ol><li>时间复杂度 <code>O(N + M)</code>： 遍历一个图需要访问所有节点和所有邻边，N 和 M 分别为节点数量和邻边数量</li><li>空间复杂度 <code>O(N + M)</code>： 为建立邻接表所需额外空间，<code>adjacency</code> 长度为 N ，并存储 M 条邻边的数据</li></ol><p>参考 <code>leetcode-cn</code> 官方题解动画辅助理解。</p><h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] indegrees = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adjacency = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="comment">//邻接表</span></span><br><span class="line">            adjacency.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Get the indegree and adjacency of every course.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] cp:prerequisites)&#123;</span><br><span class="line">            indegrees[cp[<span class="number">0</span>]]++;</span><br><span class="line">            adjacency.get(cp[<span class="number">1</span>]).add(cp[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Get all the courses with the indegree of 0.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegrees[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// BFS TopSort.</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> pre = queue.poll();</span><br><span class="line">            numCourses--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> cur : adjacency.get(pre))&#123;</span><br><span class="line">                <span class="keyword">if</span>(--indegrees[cur] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.add(cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-拓扑排序（深度优先）"><a href="#Approach-2-拓扑排序（深度优先）" class="headerlink" title="Approach 2-拓扑排序（深度优先）"></a>Approach 2-拓扑排序（深度优先）</h3><h4 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h4><ol><li>借助一个标志列表 <code>flags</code>，用于判断每个节点 i （课程）的状态<ul><li>未被 DFS 访问：<code>i == 0</code></li><li>已被其他节点启动的 DFS 访问：<code>i == -1</code></li><li>已被当前节点启动的 DFS 访问：<code>i == 1</code></li></ul></li><li>对 <code>numCourses</code> 个节点依次执行 DFS，判断每个节点起步 DFS 是否存在环，若存在环直接返回 <code>False</code>。</li></ol><p>DFS 流程如下</p><ol><li>终止条件<ul><li>当 <code>flag[i] == -1</code>，说明当前访问节点已被其他节点启动的 DFS 访问，无需再重复搜索，直接返回 <code>True</code></li><li>当 <code>flag[i] == 1</code>，说明在本轮 DFS 搜索中节点 i 被第 2 次访问，即课程安排图有环 ，直接返回 <code>False</code></li></ul></li><li>将当前访问节点 i 对应 <code>flag[i]</code> 置 1，即标记其被本轮 DFS 访问过</li><li>递归访问当前节点 i 的所有邻接节点 j，当发现环直接返回 <code>False</code></li><li>当前节点所有邻接节点已被遍历，并没有发现环，则将当前节点 <code>flag</code> 置为 <code>−1</code> 并返回 <code>True</code></li><li>若整个图 DFS 结束并未发现环，返回 <code>True</code></li></ol><p>算法复杂度分析</p><ol><li>时间复杂度 <code>O(N + M)</code>： 遍历一个图需要访问所有节点和所有临边，N 和 M 分别为节点数量和临边数量</li><li>空间复杂度 <code>O(N + M)</code>： 为建立邻接表所需额外空间，<code>adjacency</code> 长度为 N ，并存储 M 条临边的数据</li></ol><p>参考 <code>leetcode-cn</code> 官方题解动画辅助理解。</p><p>（待后续补充）</p><h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><p>（待后续补充）</p><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">LeetCode-70. 爬楼梯</a></li></ul><h3 id="Approach-1-动态规划-1"><a href="#Approach-1-动态规划-1" class="headerlink" title="Approach 1-动态规划"></a>Approach 1-动态规划</h3><h4 id="Analysis-6"><a href="#Analysis-6" class="headerlink" title="Analysis"></a>Analysis</h4><p>用 <code>$f(x)$</code> 表示爬到第 <code>x</code> 级台阶的方案数。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span>时，f(x)=<span class="number">1</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line"></span><br><span class="line">x=<span class="number">2</span>时，f(x)=<span class="number">2</span></span><br><span class="line">    <span class="number">1</span>+<span class="number">1</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line"></span><br><span class="line">x=<span class="number">3</span>时，f(x)=<span class="number">3</span>=f(x<span class="number">-1</span>)+f(x<span class="number">-2</span>)</span><br><span class="line">    <span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span></span><br><span class="line">    <span class="number">1</span>+<span class="number">2</span></span><br><span class="line">    <span class="number">2</span>+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">x=<span class="number">4</span>时，f(x)=<span class="number">5</span>=f(x<span class="number">-1</span>)+f(x<span class="number">-2</span>)</span><br><span class="line">    -------------</span><br><span class="line">    <span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>      |</span><br><span class="line">    <span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span>        |  </span><br><span class="line">    <span class="number">1</span>+<span class="number">2</span>+<span class="number">1</span>        |   f(<span class="number">3</span>)的方案数，后面再走<span class="number">1</span>步</span><br><span class="line">    <span class="number">1</span>+<span class="number">2</span>+<span class="number">1</span>        |</span><br><span class="line">    -------------</span><br><span class="line">    <span class="number">2</span>+<span class="number">2</span>          |   f(<span class="number">2</span>)的方案数，后面再走<span class="number">2</span>步</span><br><span class="line">    -------------</span><br><span class="line"></span><br><span class="line">x=<span class="number">5</span>时，f(x)=<span class="number">8</span>=f(x<span class="number">-1</span>)+f(x<span class="number">-2</span>)</span><br><span class="line">    -------------</span><br><span class="line">    <span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>    |</span><br><span class="line">    <span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>      |  </span><br><span class="line">    <span class="number">1</span>+<span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span>      |   f(<span class="number">4</span>)的方案数，后面再走<span class="number">1</span>步</span><br><span class="line">    <span class="number">1</span>+<span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span>      |</span><br><span class="line">    <span class="number">2</span>+<span class="number">2</span>+<span class="number">1</span>        |   </span><br><span class="line">    -------------</span><br><span class="line">    <span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">2</span>      |</span><br><span class="line">    <span class="number">1</span>+<span class="number">2</span>+<span class="number">2</span>        |   f(<span class="number">3</span>)的方案数，后面再走<span class="number">1</span>步</span><br><span class="line">    <span class="number">2</span>+<span class="number">1</span>+<span class="number">2</span>        |</span><br><span class="line">    -------------</span><br></pre></td></tr></table></figure><p><strong>区分方案最后一步是1步，还是2步，对x=1,2,3,4,5的方案数进行比较，可以发现，考虑最后 1 步可能跨了 1 级台阶，也可能跨了 2 级台阶，有如下表达式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x)=f(x−1)+f(x−2)</span><br></pre></td></tr></table></figure><p>它意味着爬到第 <code>x</code> 级台阶的方案数是爬到第 <code>x - 1</code> 级台阶的方案数和爬到第 <code>x - 2</code> 级台阶的方案数的和。很好理解，因为每次只能爬 1 级或 2 级，所以 <code>f(x)</code> 只能从 <code>f(x-1)</code> 和 <code>f(x-2)</code> 转移过来，而这里要统计方案总数，我们就需要对这两项的贡献求和。</p><p>复杂度分析</p><ul><li>时间复杂度：循环执行 <code>n</code> 次，每次花费常数的时间代价，故渐进时间复杂度为 <code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><ul><li>java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//init value</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n ==<span class="number">2</span> ) <span class="keyword">return</span> n;</span><br><span class="line">  </span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        res[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            res[i] = res[i-<span class="number">1</span>] + res[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-动态规划-滚动数组"><a href="#Approach-2-动态规划-滚动数组" class="headerlink" title="Approach 2-动态规划+滚动数组"></a>Approach 2-动态规划+滚动数组</h3><h4 id="Analysis-7"><a href="#Analysis-7" class="headerlink" title="Analysis"></a>Analysis</h4><p>在 * Approach 1* 的基础上进行优化，可以发现，动态规划求解 <code>f(x)</code>，只和前面2项有关，即 <code>f(x-1)</code> 和 <code>f(x-2)</code>，因此不用创建一个长度为 <code>n</code> 的数组去存储全部的计算结果。</p><p>使用滚定数组实现，可以将空间复杂度从 <code>O(n)</code> 优化至 <code>O(1)</code>。</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><h4 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h4><ul><li>java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//init value</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n ==<span class="number">2</span> ) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev1 = <span class="number">1</span>;  <span class="comment">//f(x-2) 初始值为f(1)</span></span><br><span class="line">        <span class="keyword">int</span> prev2 = <span class="number">2</span>;  <span class="comment">//f(x-1) 初始值为f(2)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            res = prev1 + prev2;</span><br><span class="line">            prev1 = prev2;</span><br><span class="line">            prev2 = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-3-斐波那契数列-公式求解"><a href="#Approach-3-斐波那契数列-公式求解" class="headerlink" title="Approach 3-斐波那契数列+公式求解"></a>Approach 3-斐波那契数列+公式求解</h3><h4 id="Analysis-8"><a href="#Analysis-8" class="headerlink" title="Analysis"></a>Analysis</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x)=f(x−1)+f(x−2)</span><br></pre></td></tr></table></figure><p>考虑上述动态转移方程，满足斐波那契额，可以直接使用公式求解。对上述动态转移方程求解，可以写出下述特征方程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x^2=x+1</span><br></pre></td></tr></table></figure><p>求得 <code>$x_1 = \frac{1+\sqrt{5}}{2}$</code>，<code>$x_2 = \frac{1-\sqrt{5}}{2}$</code>，设通解为 <code>$f(n) = c_1 x_1 ^n + c_2 x_2 ^ n$</code>，代入初始条件 <code>f(1) = 1</code>，<code>f(2) = 1</code>，得 <code>$c_1 = \frac{1}{\sqrt{5}}$</code>，<code>$c_2 = -\frac{1}{\sqrt{5}}$</code>，我们得到了这个递推数列的通项公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = \frac&#123;1&#125;&#123;\sqrt&#123;5&#125;&#125;\left[ \left(\frac&#123;1+\sqrt&#123;5&#125;&#125;&#123;2&#125;\right)^&#123;n&#125; - \left(\frac&#123;1-\sqrt&#123;5&#125;&#125;&#123;2&#125;\right)^&#123;n&#125; \right]</span><br></pre></td></tr></table></figure><p>算法复杂度分析</p><ul><li>时间复杂度：<code>$O(\log n)$</code>，<code>pow</code> 方法将会用去 <code>$O(\log n)$</code> 的时间</li><li>空间复杂度：<code>O(1)</code></li></ul><h4 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h4><ul><li>java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt5 = Math.sqrt(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fibn = Math.pow((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>) - Math.pow((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(fibn / sqrt5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h2><h3 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">LeetCode-739. 每日温度</a></li></ul><h3 id="Approach-1-暴力求解-双重for循环"><a href="#Approach-1-暴力求解-双重for循环" class="headerlink" title="Approach 1-暴力求解-双重for循环"></a>Approach 1-暴力求解-双重for循环</h3><h4 id="Analysis-9"><a href="#Analysis-9" class="headerlink" title="Analysis"></a>Analysis</h4><p>暴力求解，使用双重 for 循环。</p><ul><li>外层循环，反向遍历数组，数组最后一个元素对应的值一定是0</li><li>内层循环，遍历数组，对于第 <code>i</code> 个元素，在遇到第一个大于改元素的时候，记录对应的天数，并结束内层循环</li></ul><p>算法复杂度分析</p><ul><li>时间复杂度：<code>$O(n^2)$</code></li><li>空间复杂度：<code>O(n)</code>，创建一个长度为 <code>n</code> 的数组，用于存放结果</li></ul><h4 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h4><ul><li>java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = T.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        res[length-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> day = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            max = T[i];</span><br><span class="line">            day = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;length;j++)&#123;</span><br><span class="line">                day++;</span><br><span class="line">                <span class="keyword">if</span>(T[j] &gt; max)&#123;</span><br><span class="line">                    max = T[j];</span><br><span class="line">                    res[i] = day;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-单调栈"><a href="#Approach-2-单调栈" class="headerlink" title="Approach 2-单调栈"></a>Approach 2-单调栈</h3><h4 id="Analysis-10"><a href="#Analysis-10" class="headerlink" title="Analysis"></a>Analysis</h4><p>参考 <code>leetcode-cn 官方题解</code>。</p><p>可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p><p>正向遍历温度列表。对于温度列表中的每个元素 <code>T[i]</code>，如果栈为空，则直接将 <code>i</code> 进栈，如果栈不为空，则比较栈顶元素 <code>prevIndex</code> 对应的温度 <code>T[prevIndex]</code> 和当前温度 <code>T[i]</code>，如果 <code>T[i]</code> &gt; <code>T[prevIndex]</code>，则将 <code>prevIndex</code> 移除，并将 <code>prevIndex</code> 对应的等待天数赋为 <code>i - prevIndex</code>，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 <code>i</code> 进栈。</p><p><strong>为什么可以在弹栈的时候更新 <code>ans[prevIndex]</code> 呢？因为在这种情况下，即将进栈的 <code>i</code> 对应的 <code>T[i]</code> 一定是 <code>T[prevIndex]</code> 右边第一个比它大的元素</strong>，试想如果 <code>prevIndex</code> 和 <code>i</code> 有比它大的元素，假设下标为 <code>j</code>，那么 <code>prevIndex</code> 一定会在下标 <code>j</code> 的那一轮被弹掉。</p><p><strong>由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。</strong></p><p>以下用一个具体的例子帮助读者理解单调栈。对于温度列表 <code>[73,74,75,71,69,72,76,73]</code>，单调栈 <code>stack</code> 的初始状态为空，答案 <code>ans</code> 的初始状态是 <code>[0,0,0,0,0,0,0,0]</code>，按照以下步骤更新单调栈和答案，其中单调栈内的元素都是下标，括号内的数字表示下标在温度列表中对应的温度。</p><ol><li>当 <code>i=0</code> 时，单调栈为空，因此将 0 进栈。</li></ol><ul><li><code>stack=[0(73)]</code></li><li><code>ans=[0,0,0,0,0,0,0,0]</code></li></ul><ol start="2"><li>当 <code>i=1</code> 时，由于 74 大于 73，因此移除栈顶元素 0，赋值 <code>ans[0]:=1-0</code>，将 1 进栈</li></ol><ul><li><code>stack=[1(74)]</code></li><li><code>ans=[1,0,0,0,0,0,0,0]</code></li></ul><ol start="3"><li>当 <code>i=2</code> 时，由于 75 大于 74，因此移除栈顶元素 1，赋值 <code>ans[1]:=2-1</code>，将 2 进栈</li></ol><ul><li><code>stack=[2(75)]</code></li><li><code>ans=[1,1,0,0,0,0,0,0]</code></li></ul><ol start="4"><li>当 <code>i=3</code> 时，由于 71 小于 75，因此将 3 进栈</li></ol><ul><li><code>stack=[2(75),3(71)]</code></li><li><code>ans=[1,1,0,0,0,0,0,0]</code></li></ul><ol start="5"><li>当 <code>i=4</code> 时，由于 69 小于 71，因此将 4 进栈</li></ol><ul><li><code>stack=[2(75),3(71),4(69)]</code></li><li><code>ans=[1,1,0,0,0,0,0,0]</code></li></ul><ol start="6"><li>当 <code>i=5</code> 时，由于 72 大于 69 和 71，因此依次移除栈顶元素 4 和 3，赋值 <code>ans[4]:=5-4</code> 和 <code>ans[3]:=5-3</code>，将 5 进栈</li></ol><ul><li><code>stack=[2(75),5(72)]</code></li><li><code>ans=[1,1,0,2,1,0,0,0]</code></li></ul><ol start="7"><li>当 <code>i=6</code> 时，由于 76 大于 72 和 75，因此依次移除栈顶元素 5 和 2，赋值 <code>ans[5]:=6-5</code> 和 <code>ans[2]:=6-2</code>，将 6 进栈</li></ol><ul><li><code>stack=[6(76)]</code></li><li><code>ans=[1,1,4,2,1,1,0,0]</code></li></ul><ol start="8"><li>当 <code>i=7</code> 时，由于 73 小于 76，因此将 7 进栈</li></ol><ul><li><code>stack=[6(76),7(73)]</code></li><li><code>ans=[1,1,4,2,1,1,0,0]</code></li></ul><p>算法复杂度分析</p><ul><li>时间复杂度：<code>$O(n)$</code>。<strong>在leetcode-cn平台上测试，方法1中时间复杂度为<code>$O(n^2)$</code>，耗时821ms；方法2的时间复杂度是 <code>O(n)</code>，耗时为 15ms，优化效果十分明显。</strong></li><li>空间复杂度：<code>O(n)</code>，需要维护一个单调栈存储温度列表中的下标</li></ul><h4 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = T.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        Deque&lt;Integer&gt;  stack =  <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temperature = T[i];</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temperature &gt; T[stack.peek()])&#123;</span><br><span class="line">                <span class="keyword">int</span> prevIndex = stack.pop();</span><br><span class="line">                res[prevIndex] = i - prevIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录LeetCode题目笔记，汇总LeetCode解答记录&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://lbs0912.github.io/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-007</title>
    <link href="https://lbs0912.github.io/2020/06/12/leetcode-007/"/>
    <id>https://lbs0912.github.io/2020/06/12/leetcode-007/</id>
    <published>2020-06-12T06:35:26.000Z</published>
    <updated>2020-11-01T03:39:38.111Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录LeetCode题目笔记，汇总LeetCode解答记录</li></ul><a id="more"></a><h2 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h2><ul><li>2020/05/12，撰写</li><li>2020/05/18，添加 <em>滚动数组</em> 方法介绍</li><li>2020/05/19，整理完成</li></ul><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">LeetCode-560. 和为K的子数组</a></li><li><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">LeetCode-25. K 个一组翻转链表</a></li><li><a href="https://leetcode-cn.com/problems/maximum-subarray/submissions/" target="_blank" rel="noopener">LeetCode-53. 最大子序和</a> - DP+滚动数组</li><li><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">LeetCode-152. 乘积最大子数组</a>- DP+滚动数组</li><li><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">LeetCode-680. 验证回文字符串 II</a></li></ul><h2 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a>560. 和为K的子数组</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">LeetCode-560. 和为K的子数组</a></li></ul><h3 id="Approach-1-枚举"><a href="#Approach-1-枚举" class="headerlink" title="Approach 1-枚举"></a>Approach 1-枚举</h3><p>参考 <code>leetcode-cn</code> 官方题解。</p><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><p>考虑以 <code>i</code> 结尾和为 <code>k</code> 的连续子数组个数，我们需要统计符合条件的下标 <code>j</code> 的个数，其中 <code>0 ≤ j ≤i</code> 且 <code>[j..i]</code> 这个子数组的和恰好为 <code>k</code>。</p><p>我们可以枚举 <code>[0..i]</code> 里所有的下标 <code>j</code> 来判断是否符合条件，可能有读者会认为假定我们确定了子数组的开头和结尾，还需要 <code>O(n)</code> 的时间复杂度遍历子数组来求和，那样复杂度就将达到 <code>O(n^3)</code>，从而无法通过所有测试用例。</p><p>但是如果我们知道 <code>[j,i]</code> 子数组的和，就能 <code>O(1)</code> 推出 <code>[j-1,i]</code> 的和，因此这部分的遍历求和是不需要的，我们在枚举下标 <code>j</code> 的时候已经能 <code>O(1)</code> 求出 <code>[j,i]</code> 的子数组之和。</p><p>复杂度分析</p><ul><li>时间复杂度：<code>O(n^2)</code>，其中 <code>n</code> 为数组的长度。枚举子数组开头和结尾需要 <code>O(n^2)</code> 的时间，其中求和需要 <code>O(1)</code> 的时间复杂度，因此总时间复杂度为 <code>O(n^2)</code></li><li>空间复杂度：<code>O(1)</code>，只需要常数空间存放若干变量。</li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum == k)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，针对数组 <code>{3,4,7,2,-3,1,4,2}</code>，<code>k=7</code>的情况，共有4个子数组满足条件</p><ol><li><code>{3,4}</code></li><li><code>{7}</code></li><li><code>{7,2,-3,1}</code></li><li><code>{1,4,2}</code></li></ol><h3 id="Approach-2-前缀和-哈希表"><a href="#Approach-2-前缀和-哈希表" class="headerlink" title="Approach 2-前缀和+哈希表"></a>Approach 2-前缀和+哈希表</h3><p>参考 <code>leetcode-cn</code> 官方题解。</p><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><p>方法一的瓶颈在于对每个 <code>i</code>，我们需要枚举所有的 <code>j</code> 来判断是否符合条件，这一步是否可以优化呢？答案是可以的。</p><p>我们定义 <code>pre[i]</code> 为 <code>[0..i]</code> 里所有数的和，则 <code>pre[i]</code>  可以由 <code>pre[i-1]</code> 递推而来</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre<span class="string">[i]</span>=pre<span class="string">[i−1]</span>+nums<span class="string">[i]</span></span><br></pre></td></tr></table></figure><p>那么 <code>[j..i]</code> 这个子数组和为 <code>k</code> 这个条件，我们可以转化为</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre<span class="string">[i]</span> − pre<span class="string">[j−1]</span> == k</span><br></pre></td></tr></table></figure><p>简单移项可得符合条件的下标 <code>j</code> 需要满足</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre<span class="string">[j−1]</span>==pre<span class="string">[i]</span>−k</span><br></pre></td></tr></table></figure><p>所以我们考虑以 <code>i</code> 结尾的和为 <code>k</code> 的连续子数组个数时，只要统计有多少个前缀和为 <code>pre[i]−k</code> 的 <code>pre[j]</code> 即可。</p><p>我们建立哈希表 <code>mp</code>，以和为键，出现次数为对应的值，记录 <code>pre[i]</code> 出现的次数，从左往右边更新 <code>mp</code> 并计算答案，那么以 <code>i</code> 结尾的答案 <code>mp[pre[i]-k]</code>  即可在 <code>O(1)</code> 时间内得到。最后的答案即为所有下标结尾的和为 <code>k</code> 的子数组个数之和。</p><p>需要注意的是，从左往右边更新边计算的时候已经保证了 <code>mp[pre[i]-k]</code>  里记录的 <code>pre[j]</code> 的下标范围是 <code>0 ≤ j ≤i</code>。同时，由于 <code>pre[i]</code>  的计算只与前一项的答案有关，因此我们可以不用建立 <code>pre</code> 数组，直接用 <code>pre</code> 变量来记录 <code>pre[i-1]</code> 的值即可。</p><p>参考 <code>leetcode-cn</code> 官方题解的辅助演示动画，加深理解。下面针对数组 <code>{3,4,7,2,-3,1,4,2}</code>，<code>k=7</code>的情况，进行逐步分析</p><ol><li><strong><code>mp</code> 初始化时，需要插入 <code>(0,1)</code>，一方面是表示前缀和为0的情况出现了1次（即空数组），另一方面也是为了后续统计 <code>pre[i]−k</code> 等于 0 的情况</strong>，如下图所示</li></ol><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-560-solve2-1.jpg" alt=""></p><ol start="2"><li><code>i=0</code>时，<code>pre</code> 为 3，因此在 map 插入 <code>(3,1)</code></li></ol><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-560-solve2-2.jpg" alt=""></p><ol start="3"><li><code>i=1</code>时，<code>pre</code> 为 7，因此在 map 插入 <code>(7,1)</code>。此时 <code>pre-k = 0</code>，在 map 中已经存在 <code>key=0</code>的 value 值。因此，执行 <code>count += mp.get(pre - k);</code> 后，计数值 <code>count</code> 等于1，表示区间 <code>[0,1]</code> 的子数组 <code>{3,4}</code> 满足和等于 7 的条件</li></ol><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-560-solve2-3.jpg" alt=""></p><ol start="4"><li><code>i=2</code>时，<code>pre</code> 为 14，因此在 map 插入 <code>(14,1)</code>。此时 <code>pre-k = 7</code>，在 map 中已经存在 <code>key=7</code>的 value 值。因此，执行 <code>count += mp.get(pre - k);</code> 后，计数值 <code>count</code> 等于2，表示区间 <code>[2,2]</code> 的子数组 <code>{7}</code> 满足和等于 7 的条件</li></ol><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-560-solve2-4.jpg" alt=""></p><ol start="5"><li><code>i=3</code>时，<code>pre</code> 为 16，因此在 map 插入 <code>(16,1)</code>。此时 <code>pre-k = 9</code>，在 map 中找不到 <code>key=9</code>的 value 值。</li></ol><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-560-solve2-5.jpg" alt=""></p><ol start="6"><li><code>i=4</code>时，<code>pre</code> 为 13，因此在 map 插入 <code>(13,1)</code>。此时 <code>pre-k = 6</code>，在 map 中找不到经存在 <code>key=6</code>的 value 值。</li></ol><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-560-solve2-6.jpg" alt=""></p><ol start="7"><li><code>i=5</code>时，<code>pre</code> 为 14，此时 map 中已经存在 <code>key=14</code> 的值，因此 map 中更新为 <code>(14,2)</code>。此时 <code>pre-k = 7</code>，在 map 中已经存在 <code>key=7</code>的 value 值。因此，执行 <code>count += mp.get(pre - k);</code> 后，计数值 <code>count</code> 等于3，表示区间 <code>[2,5]</code> 的子数组 <code>{7,2-3,1}</code> 满足和等于 7 的条件</li></ol><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-560-solve2-7.jpg" alt=""></p><ol start="8"><li><code>i=6</code>时，<code>pre</code> 为 18，因此在 map 插入 <code>(18,1)</code>。此时 <code>pre-k = 11</code>，在 map 中找不到 <code>key=11</code>的 value 值。</li></ol><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-560-solve2-8.jpg" alt=""></p><ol start="9"><li><code>i=7</code>时，<code>pre</code> 为 20，因此在 map 插入 <code>(20,1)</code>。此时 <code>pre-k = 13</code>，在 map 中已经存在 <code>key=13</code>的 value 值。因此，执行 <code>count += mp.get(pre - k);</code> 后，计数值 <code>count</code> 等于4，表示区间 <code>[5,7]</code> 的子数组 <code>{1,4,2}</code> 满足和等于 7 的条件</li></ol><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-560-solve2-9.jpg" alt=""></p><p>复杂度分析</p><ul><li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 为数组的长度。我们遍历数组的时间复杂度为 <code>O(n)</code>，中间利用哈希表查询删除的复杂度均为 <code>O(1)</code>，因此总时间复杂度为 <code>O(n)</code></li><li>空间复杂度：<code>O(n)</code>，其中 <code>n</code> 为数组的长度。哈希表在最坏情况下可能有 <code>n</code> 个不同的键值，因此需要 <code>O(n)</code> 的空间复杂度。</li></ul><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        HashMap &lt; Integer, Integer &gt; mp = <span class="keyword">new</span> HashMap &lt; &gt; ();</span><br><span class="line">        <span class="comment">//前缀和为0的情况，即空数组</span></span><br><span class="line">        mp.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            pre += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (mp.containsKey(pre - k))&#123;</span><br><span class="line">                 <span class="comment">//统计次数</span></span><br><span class="line">                 count += mp.get(pre - k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记录pre出现的次数</span></span><br><span class="line">            mp.put(pre, mp.getOrDefault(pre, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a>25. K 个一组翻转链表</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">LeetCode-25. K 个一组翻转链表</a></li></ul><h3 id="Approach-1-常规求解"><a href="#Approach-1-常规求解" class="headerlink" title="Approach 1-常规求解"></a>Approach 1-常规求解</h3><h4 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h4><p>常规思路求解，遍历链表，若移动了K个节点，则对这个区间的链表进行翻转，翻转链表的过程并不难，过程可以参考 <a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">LeetCode-206. Reverse Linked List（反转链表）</a> 。</p><p>本题目的难点是在翻转链表后，需要将翻转后的子链表的头部和上一个子链表连接，同时将翻转后的子链表的尾部和下一个子链表连接，如下图所示。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-25-hard-solve-1.png" alt=""></p><p>为了方便表示，引入 <code>prev</code> 和 <code>tail</code> 分别表示翻转链表的上一个节点和下一个节点，使用 <code>startNode</code> 和 <code>endNode</code> 分别表示翻转链表的首尾节点。</p><p>这里需要注意的是，对于链表的前 K 个长度的子链表，这个时候 <code>prev</code> 是不存在的。为了后续处理方便，可以在链表头部插入一个辅助节点 <code>hair</code>，如上图所示。</p><p>下面分析下如何返回最后的链表结果。在程序过程中</p><ul><li>若没有发生链表翻转，则返回 <code>hair.next</code> 即可。</li><li>若发生了链表翻转，则记录第一次链表翻转的情况，并将 <code>hair.next</code> 指向翻转后的链表头部，最后程序结束是，同样返回 <code>hair.next</code>。</li></ul><p>具体细节，可以参考 <code>leetcode-cn</code> 官网题解的动画分析。</p><p>算法复杂度分析如下</p><ul><li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 为链表的长度。head 指针会在 <code>O(floor(n/k))</code> 个结点上停留，每次停留需要进行一次 <code>O(k)</code> 的翻转操作。</li><li>空间复杂度：<code>O(1)</code>，我们只需要建立常数个变量。</li></ul><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || k == <span class="number">0</span> || k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode hair = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        hair.next = head;</span><br><span class="line">        ListNode prev = hair;</span><br><span class="line">        ListNode tail = hair;</span><br><span class="line">        ListNode startNode = head;</span><br><span class="line">        ListNode endNode = head;</span><br><span class="line">        <span class="keyword">int</span> reverseLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> hasReverse = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; head.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            reverseLength ++;</span><br><span class="line">            <span class="keyword">if</span>(reverseLength == k)&#123;</span><br><span class="line">                endNode = head;</span><br><span class="line">                tail = endNode.next;</span><br><span class="line">                startNode = prev.next;</span><br><span class="line">                reverseList(startNode,k);</span><br><span class="line">                <span class="keyword">if</span>(!hasReverse)&#123;</span><br><span class="line">                    hair.next = endNode; </span><br><span class="line">                    hasReverse = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev.next = endNode;</span><br><span class="line">                startNode.next = tail;</span><br><span class="line">                prev = startNode;</span><br><span class="line">                tail = startNode;</span><br><span class="line"></span><br><span class="line">                reverseLength =<span class="number">1</span>;</span><br><span class="line">                head = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hair.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseList</span><span class="params">(ListNode head,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(length &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            length--;</span><br><span class="line">            ListNode nextTemp = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/maximum-subarray/submissions/" target="_blank" rel="noopener">LeetCode-53. 最大子序和</a></li></ul><h3 id="Approach-1-动态规划"><a href="#Approach-1-动态规划" class="headerlink" title="Approach 1-动态规划"></a>Approach 1-动态规划</h3><h4 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h4><p>参考 <code>leetcode-cn</code> 官方题解。</p><p>假设 <code>nums</code> 数组的长度是 <code>n</code>，下标从 0 到 <code>n-1</code>。</p><p>我们用 <code>$a_i$</code> 代表 <code>nums[i]</code>，用 <code>f(i)</code> 代表以第 <code>i</code> 个数结尾的 <strong>「连续子数组的最大和」</strong>，那么很显然我们要求的答案就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\max_&#123;0 \leq i \leq n - 1&#125; \&#123; f(i) \&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要求出每个位置的 <code>f(i)</code>，然后返回 <code>f</code> 数组中的最大值即可。</p><p>那么我们如何求 <code>f(i)</code> 呢？不难列出如下动态转移方程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(i) = \max \&#123; f(i - 1) + a_i, a_i \&#125;</span><br></pre></td></tr></table></figure><p>算法复杂度分析</p><ol><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code>，创建了一个长度为 <code>n</code> 的 <code>f</code> 数组</li></ol><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] pre = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        pre[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            pre[i] = Math.max(pre[i-<span class="number">1</span>]+nums[i],nums[i]);</span><br><span class="line">            res = Math.max(pre[i],res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-动态规划-滚动数组优化空间"><a href="#Approach-2-动态规划-滚动数组优化空间" class="headerlink" title="Approach 2-动态规划+滚动数组优化空间"></a>Approach 2-动态规划+滚动数组优化空间</h3><h4 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h4><p>在 <em>Approach 1</em> 的基础上继续分析，<strong>使用滚动数组的思想对空间复杂度进行优化。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(i) = \max \&#123; f(i - 1) + a_i, a_i \&#125;</span><br></pre></td></tr></table></figure><p>在动态转移方程中，考虑到 <code>f(i)</code> 只和 <code>f(i-1)</code> 相关，于是我们可以只用一个变量 <code>pre</code> 来维护对于当前 <code>f(i)</code> 的 <code>f(i-1)</code> 的值是多少，从而让空间复杂度降低到 <code>O(1)</code>，这有点类似 <strong>「滚动数组」</strong> 的思想。</p><p>算法复杂度分析</p><ol><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ol><h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            pre = Math.max(pre+nums[i],nums[i]);</span><br><span class="line">            res = Math.max(pre,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h2><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul><li><a href="https://blog.csdn.net/weixin_40295575/article/details/80181756?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" rel="noopener">滚动数组算法 - 结合动态规划 | CSDN</a></li><li><a href="https://www.cxyxiaowu.com/7848.html" target="_blank" rel="noopener">动态规划之空间优化与总结回顾</a></li></ul><h3 id="思想介绍"><a href="#思想介绍" class="headerlink" title="思想介绍"></a>思想介绍</h3><p><strong>滚动数组</strong> 是动态规划中的一种编程思想。简单的理解就是让数组滚动起来，每次都使用固定的几个存储空间，来达到压缩，节省存储空间的作用。</p><p>因为动态规划是一个自底向上的扩展过程，我们常常需要用到的是连续的解，前面的解往往可以舍去。所以用滚动数组优化是很有效的。利用滚动数组的话在 N 很大的情况下可以达到压缩存储的作用。</p><h3 id="Demo1-斐波那契数列"><a href="#Demo1-斐波那契数列" class="headerlink" title="Demo1-斐波那契数列"></a>Demo1-斐波那契数列</h3><p>此处以求解斐波那契数列为例进行说明。如下代码示例，求解斐波那契数列的第 80 项。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d[<span class="number">80</span>];</span><br><span class="line">    d[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;<span class="number">80</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i]=d[i<span class="number">-1</span>]+d[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,d[<span class="number">79</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，创建了一个长度为 N=80 的数组。如果 N 的值很大，则会占用很大的存储空间。</p><p><strong>查看状态转移方程 <code>d[i]=d[i-1]+d[i-2]</code>，可以发现，待求解的 <code>d[i]</code>，只和其前面两项 <code>d[i-1]</code> 和 <code>d[i-2]</code> 有关，和其余项无关。</strong></p><p><strong>因此，可以只创建一个长度为 3 的数组，将数组“滚动”起来，将待求解的项存储在 <code>d[2]</code> 中，其依赖的前两项存储在 <code>d[1]</code> 和 <code>d[0]</code> 中。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d[<span class="number">3</span>];</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    d[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;<span class="number">80</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        d[<span class="number">0</span>]=d[<span class="number">1</span>];</span><br><span class="line">        d[<span class="number">1</span>]=d[<span class="number">2</span>];</span><br><span class="line">        d[<span class="number">2</span>]=d[<span class="number">0</span>]+d[<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,d[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Demo2-leetcode-子序问题"><a href="#Demo2-leetcode-子序问题" class="headerlink" title="Demo2-leetcode-子序问题"></a>Demo2-leetcode-子序问题</h3><ul><li>leetcode-53. 最大子序和</li><li>leetcode-152. 乘积最大子数组</li></ul><p>参考上述两道题目中的 <code>Approach 2-动态规划+滚动数组优化空间</code>。</p><h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">LeetCode-152. 乘积最大子数组</a></li></ul><h3 id="Approach-1-动态规划-1"><a href="#Approach-1-动态规划-1" class="headerlink" title="Approach 1-动态规划"></a>Approach 1-动态规划</h3><h4 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h4><p>参考 <code>leetcode-cn</code> 官方题解。</p><p>如果我们用 <code>$f_{\max}(i)$</code> 表示以第 <code>i</code> 个元素结尾的乘积最大子数组的乘积，<code>a</code> 表示输入参数 <code>nums</code>，那么根据 <a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">leetcode-53. 最大子序和</a> 的经验，我们很容易推导出这样的状态转移方程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f_&#123;\max&#125;(i) = \max_&#123;i = 1&#125;^&#123;n&#125; \&#123; f(i - 1) \times a_i, a_i \&#125;</span><br></pre></td></tr></table></figure><p>它表示以第 <code>i</code> 个元素结尾的乘积最大子数组的乘积，可以考虑 <code>$a_i$</code> 加入前面的 <code>$f_{\max}(i - 1)$</code> 对应的一段，或者单独成为一段，这里两种情况下取最大值。</p><p>求出所有的 <code>$f_{\max}(i)$</code> 之后选取最大的一个作为答案。</p><p>可是在这里，这样做是错误的。为什么呢？</p><p>因为这里的定义并不满足 <strong>「最优子结构」</strong>。具体地讲，如果 <code>$a = \{ 5, 6, -3, 4, -3 \}$</code>，那么此时 <code>$f_{\max}$</code> 对应的序列是 <code>$\{ 5, 30, -3, 4, -3 \}$</code>。按照前面的算法我们可以得到答案为 30，即前两个数的乘积，而实际上答案应该是全体数字的乘积。我们来想一想问题出在哪里呢？问题出在最后一个 <code>-3</code> 所对应的 <code>$f_{\max}$</code> 的值既不是 <code>-3</code>，也不是 <code>4 × −3</code>，而是 <code>$5 \times 30 \times (-3) \times 4 \times$</code>。</p><p>所以我们得到了一个结论：<strong>当前位置的最优解未必是由前一个位置的最优解转移得到的。</strong></p><p><strong>我们可以根据正负性进行分类讨论。</strong></p><ol><li>考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能 <em>「负得更多」</em>，即尽可能小。</li><li>如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。</li><li>于是这里我们可以再维护一个 <code>$f_{\min}(i)$</code>，它表示以第 <code>i</code> 个元素结尾的乘积最小子数组的乘积，那么我们可以得到这样的动态规划转移方程</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;aligned&#125; </span><br><span class="line">f_&#123;\max&#125;(i) &amp;= \max_&#123;i = 1&#125;^&#123;n&#125; \&#123; f_&#123;\max&#125;(i - 1) \times a_i, f_&#123;\min&#125;(i - 1) \times a_i, a_i \&#125; \\ f_&#123;\min&#125;(i) &amp;= \min_&#123;i = 1&#125;^&#123;n&#125; \&#123; f_&#123;\max&#125;(i - 1) \times a_i, f_&#123;\min&#125;(i - 1) \times a_i, a_i \&#125; </span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">```</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">它代表第 `i` 个元素结尾的乘积最大子数组的乘积 `$f_&#123;\max&#125;(i)$`，可以考虑把 `$a_i$` 加入第 `i - 1` 个元素结尾的乘积最大或最小的子数组的乘积中，二者加上 `$a_i$`，三者取大，就是第 `i` 个元素结尾的乘积最大子数组的乘积。</span><br><span class="line"></span><br><span class="line">第 `i` 个元素结尾的乘积最小子数组的乘积 `$f_&#123;\min&#125;(i)$` 同理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">算法复杂度分析</span><br><span class="line">1. 时间复杂度： `O(n)`，遍历了数组</span><br><span class="line">2. 空间复杂度： `O(n)`，引入了空间为 `n` 的辅助数组</span><br><span class="line"></span><br><span class="line">#### Solution</span><br><span class="line"></span><br><span class="line">* Java</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProduct(int[] nums) &#123;</span><br><span class="line">        if(nums.length == 1) return nums[0];</span><br><span class="line">        int max = nums[0];</span><br><span class="line">        int[] imax = new int[nums.length];</span><br><span class="line">        int[] imin = new int[nums.length];</span><br><span class="line">        imax[0] = nums[0];</span><br><span class="line">        imin[0]  = nums[0];</span><br><span class="line">        for(int i=1;i&lt;nums.length;i++)&#123;</span><br><span class="line">            //保存临时变量</span><br><span class="line">            int tmpMax = imax[i-1];</span><br><span class="line">            int tmpMin = imin[i-1];</span><br><span class="line">            imax[i] = Math.max(tmpMax*nums[i],tmpMin*nums[i]);</span><br><span class="line">            imax[i] = Math.max(imax[i],nums[i]);</span><br><span class="line">            imin[i] = Math.min(tmpMax*nums[i],tmpMin*nums[i]);</span><br><span class="line">            imin[i] = Math.min(imin[i],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            max = Math.max(max,imax[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-动态规划-滚动数组优化空间-1"><a href="#Approach-2-动态规划-滚动数组优化空间-1" class="headerlink" title="Approach 2-动态规划+滚动数组优化空间"></a>Approach 2-动态规划+滚动数组优化空间</h3><h4 id="Analysis-6"><a href="#Analysis-6" class="headerlink" title="Analysis"></a>Analysis</h4><p>在 <code>Approach 1</code> 的基础上进一步对空间复杂度进行优化。</p><p>由于第 <code>i</code> 个状态只和第 <code>i-1</code> 个状态相关，根据 <strong>「滚动数组」</strong> 思想，我们可以只用两个变量来维护 <code>i−1</code> 时刻的状态，一个维护 <code>$f_{\max}$</code>，一个维护 <code>$f_{\min}$</code>。细节参见代码。</p><p>算法复杂度分析</p><ol><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：优化后只使用常数个临时变量作为辅助空间，与 <code>n</code> 无关，故渐进空间复杂度为 <code>O(1)</code></li></ol><h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> imax = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> imin = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//保存临时变量</span></span><br><span class="line">            <span class="keyword">int</span> tmpMax = imax;</span><br><span class="line">            <span class="keyword">int</span> tmpMin = imin;</span><br><span class="line">            imax = Math.max(tmpMax*nums[i],tmpMin*nums[i]);</span><br><span class="line">            imax = Math.max(imax,nums[i]);</span><br><span class="line">            imin = Math.min(tmpMax*nums[i],tmpMin*nums[i]);</span><br><span class="line">            imin = Math.min(imin,nums[i]);</span><br><span class="line">            max = Math.max(imax,max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="680-验证回文字符串-II"><a href="#680-验证回文字符串-II" class="headerlink" title="680. 验证回文字符串 II"></a>680. 验证回文字符串 II</h2><h3 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">LeetCode-680. 验证回文字符串 II</a></li></ul><h3 id="Approach-1-贪心算法-双指针"><a href="#Approach-1-贪心算法-双指针" class="headerlink" title="Approach 1-贪心算法+双指针"></a>Approach 1-贪心算法+双指针</h3><h4 id="Analysis-7"><a href="#Analysis-7" class="headerlink" title="Analysis"></a>Analysis</h4><p>参考 <code>leetcode-cn</code> 官方题解。 此处仅给出必要的分析。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-680-1.png" alt=""></p><p>如上图所示，使用<strong>贪心算法+双指针</strong>求解。</p><ol><li>如果不考虑 <em>可以最多删除一个字符</em> 的条件，对字符串是否回文进行判断 —— 使用两个指针分别指向字符串的头部和尾部，若指针指向的字符相等，则指针向中间靠拢，继续循环判断。</li><li>现在考虑下 <em>可以最多删除一个字符</em> 的条件 —— 若 <code>s[low] != s[high]</code>，下面需要分两种情况考虑<ul><li>删除 <code>s[low]</code> 字符，考虑 <code>[low+1,high]</code> 子区间</li><li>删除 <code>s[high]</code> 字符，考虑 <code>[low,high-1]</code> 子区间</li><li>上述两个子区间只要有一个满足回文串条件，则可以认为整个字符串是回文串</li></ul></li></ol><p>复杂度分析</p><ol><li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是字符串的长度。判断整个字符串是否是回文字符串的时间复杂度是 <code>O(n)</code>；遇到不同字符时，判断两个子串是否是回文字符串的时间复杂度也都是 <code>O(n)</code>。</li><li>空间复杂度：<code>O(1)</code>，只需要维护有限的常量空间。</li></ol><h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public boolean valid<span class="constructor">Palindrome(String <span class="params">s</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length<span class="literal">()</span><span class="operator"> == </span><span class="number">0</span><span class="operator"> || </span>s.length<span class="literal">()</span><span class="operator"> == </span><span class="number">1</span>) return <span class="literal">true</span>;</span><br><span class="line">        boolean flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">int</span> length = s.length<span class="literal">()</span>;</span><br><span class="line">        <span class="built_in">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> high = length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="built_in">char</span> start = s.<span class="built_in">char</span><span class="constructor">At(<span class="params">low</span>)</span>;</span><br><span class="line">            <span class="built_in">char</span> <span class="keyword">end</span> = s.<span class="built_in">char</span><span class="constructor">At(<span class="params">high</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(start<span class="operator"> == </span><span class="keyword">end</span>)&#123;</span><br><span class="line">                low++;</span><br><span class="line">                high--;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                boolean flag1 = <span class="literal">true</span>;</span><br><span class="line">                boolean flag2 = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//去除start字符</span></span><br><span class="line">                for(<span class="built_in">int</span> i=low+<span class="number">1</span>,j=high;i&lt;j;i++,j--)&#123;</span><br><span class="line">                    <span class="built_in">char</span> start1 = s.<span class="built_in">char</span><span class="constructor">At(<span class="params">i</span>)</span>;</span><br><span class="line">                    <span class="built_in">char</span> end1 = s.<span class="built_in">char</span><span class="constructor">At(<span class="params">j</span>)</span>;</span><br><span class="line">                    <span class="keyword">if</span>(start1 != end1)&#123;</span><br><span class="line">                        flag1 = <span class="literal">false</span>;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//去除end字符</span></span><br><span class="line">                for(<span class="built_in">int</span> i=low,j=high-<span class="number">1</span>;i&lt;j;i++,j--)&#123;</span><br><span class="line">                    <span class="built_in">char</span> start2 = s.<span class="built_in">char</span><span class="constructor">At(<span class="params">i</span>)</span>;</span><br><span class="line">                    <span class="built_in">char</span> end2 = s.<span class="built_in">char</span><span class="constructor">At(<span class="params">j</span>)</span>;</span><br><span class="line">                    <span class="keyword">if</span>(start2 != end2)&#123;</span><br><span class="line">                        flag2 = <span class="literal">false</span>;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">//此处直接返回，不需要再进行后续的while循环了</span></span><br><span class="line">                 <span class="comment">//不然会代码超时</span></span><br><span class="line">                return (flag1<span class="operator"> || </span>flag2); </span><br><span class="line">                <span class="comment">// flag = flag1 || flag2;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明的是，在执行下述代码时，</p><ul><li>需要直接返回 <code>return (flag1 || flag2);</code>，不需要再进行后续的 <code>while</code> 循环了。这样可以保证时间复杂度是 <code>O(n)</code>。</li><li>若使用 <code>flag = flag1 || flag2;</code> ，则时间复杂度会是 <code>O(n^2)</code>，代码会执行超时。</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处直接返回，不需要再进行后续的while循环了</span></span><br><span class="line"><span class="comment">//不然会代码超时</span></span><br><span class="line"><span class="keyword">return</span> (flag1 || flag2); </span><br><span class="line"><span class="comment">// flag = flag1 || flag2;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录LeetCode题目笔记，汇总LeetCode解答记录&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://lbs0912.github.io/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-006</title>
    <link href="https://lbs0912.github.io/2020/05/12/leetcode-006/"/>
    <id>https://lbs0912.github.io/2020/05/12/leetcode-006/</id>
    <published>2020-05-12T06:35:26.000Z</published>
    <updated>2020-05-16T15:11:30.874Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录LeetCode题目笔记，汇总LeetCode解答记录</li></ul><a id="more"></a><h2 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h2><ul><li>2020/02/29，撰写</li><li>2020/05/12，整理完成</li></ul><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">LeetCode-344. 反转字符串</a></li><li><a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">LeetCode-204.Count Primes</a></li><li><a href="https://leetcode-cn.com/problems/relative-ranks/" target="_blank" rel="noopener">LeetCode-506. 相对名次</a></li><li><a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">LeetCode-61. 旋转链表</a></li><li><a href="https://leetcode-cn.com/problems/create-target-array-in-the-given-order/" target="_blank" rel="noopener">LeetCode-1389. 按既定顺序创建目标数组</a></li></ul><h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">LeetCode-344. 反转字符串</a></li></ul><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 <code>O(1)</code> 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1</p><pre><code>输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</code></pre><p>示例 2</p><pre><code>输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</code></pre><h3 id="Approach-1"><a href="#Approach-1" class="headerlink" title="Approach 1"></a>Approach 1</h3><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//国内版leetcode-cn</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> reverseString(char[] s)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> l=<span class="number">0</span>,r=s.length<span class="number">-1</span>;l&lt;r;l++,r--)&#123;</span><br><span class="line">            char temp = s[l];</span><br><span class="line">            s[l] = s[r];</span><br><span class="line">            s[r] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//国外版 leetcode</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuffer s1 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">    s1.append(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s1.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++ 实现1：基本方法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>,r=len<span class="number">-1</span>;l&lt;r;l++,r--)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s[r];</span><br><span class="line">            s[r] = s[l];</span><br><span class="line">            s[l] = temp;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>C++ 实现2：采用STL库中的 <code>reverse()</code> 函数</li></ul><blockquote><p><code>template &lt; BidirectionalIterator&gt; void reverse (BidirectionalIterator first, BidirectionalIterator last);</code> </p><p>Reverses the order of the elements in the range [first,last).<br>The function calls <code>iter_swap</code> to swap the elements to their new locations.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//国内版leetcode-cn</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        reverse(s.begin(), s.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//国外版 leetcode</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        reverse(s.begin(),s.end());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>string.begin()</code>和 <code>string.end()</code>使用了迭代器操作。</p><ul><li>JS： 使用 <code>myString.split(&quot;&quot;).reverse().join(&quot;&quot;)</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseString = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">""</span>).reverse().join(<span class="string">""</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先使用 <code>split()</code> 将字符串转化为数组，再调用数组的 <code>reverse()</code> 方法反转数组，最后使用 <code>join()</code> 方法将数组转化为字符串，使用Demo如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"LiuBaoshuai"</span>;</span><br><span class="line"><span class="keyword">var</span> newStr = str.split(<span class="string">""</span>).reverse().join(<span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);  <span class="comment">// LiuBaoshuai</span></span><br><span class="line"><span class="built_in">console</span>.log(newStr);  <span class="comment">// iauhsoaBuiL</span></span><br></pre></td></tr></table></figure><h2 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">LeetCode-204.Count Primes</a></li></ul><p>统计所有小于非负整数 n 的质数的数量。</p><p>示例</p><pre><code>输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</code></pre><p>提示1</p><ul><li>Let’s start with a <code>isPrime</code> function. To determine if a number is prime, we need to check if it is not divisible by any number less than n. The runtime complexity of isPrime function would be O(n) and hence counting the total prime numbers up to n would be O(n^2). Could we do better?</li><li>判断一个数是否是质数，我们需要判断它是否可以被任意一个比它小的数字整除。因此判断一个数是否是质数的时间复杂度将是 <code>O(n)</code>。因此，计数质数的时间复杂度将是 <code>O(n^2)</code></li></ul><p>提示2</p><ul><li>As we know the number must not be divisible by any number &gt; <code>n/2</code>, we can immediately cut the total iterations half by dividing only up to <code>n/2</code>. Could we still do better? </li><li>考虑一个数 <code>number</code>的最大因数，因为 <code>num=1*num=2*p</code>，因此，如果 <code>num</code> 可以被2整除，则p的最大值为 <code>num/2</code>。因此，我们在判断质数的循环条件，可以从<code>[1,num)</code> 缩减至 <code>[1,num/2)</code>。  </li></ul><p>提示3</p><ul><li>Let’s write down all of 12’s factors（让我们写下数字12的所有因数分解表达式）</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> × <span class="number">6</span> = <span class="number">12</span></span><br><span class="line"><span class="number">3</span> × <span class="number">4</span> = <span class="number">12</span></span><br><span class="line"><span class="number">4</span> × <span class="number">3</span> = <span class="number">12</span></span><br><span class="line"><span class="number">6</span> × <span class="number">2</span> = <span class="number">12</span></span><br></pre></td></tr></table></figure><ul><li>As you can see, calculations of <code>4 × 3</code> and <code>6 × 2</code> are not necessary. Therefore, we only need to consider factors up to <code>√n</code> because, if <code>n</code> is divisible by some number <code>p</code>, then n = p × q and since p ≤ q, we could derive that <code>p ≤ √n</code>.</li><li>可以看到，计算 <code>4 × 3</code> 和 <code>6 × 2</code> 是没有必要的。我们只需要考虑因数小于等于 <code>√n</code> 的情况即可。因此，我们在判断质数的循环条件，可以从<code>[1,num/2)</code> 缩减至 <code>[1,√n]</code>。</li><li>Our total runtime has now improved to <code>O(n^1.5)</code>, which is slightly better. Is there a faster approach?</li><li>综上，我们的时间复杂度可以优化到 <code>O(n^1.5)</code>。那么还能继续提升优化吗？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isPrime(i)) count++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   <span class="comment">// Loop's ending condition is i * i &lt;= num instead of i &lt;= sqrt(num)</span></span><br><span class="line">   <span class="comment">// to avoid repeatedly calling an expensive function sqrt().</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= num; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (num % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示4</p><ul><li>The <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="noopener">Sieve of Eratosthenes</a> is one of the most efficient ways to find all prime numbers up to n. But don’t let that name scare you, I promise that the concept is surprisingly simple.</li><li><a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="noopener">Sieve of Eratosthenes</a> 是目前计算质数最高效的方法之一。不要担心，我保证这个概念和方法时十分简单的。</li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/Sieve_of_Eratosthenes_animation.gif" alt="Sieve_of_Eratosthenes_animation.gif"></p><ul><li>We start off with a table of n numbers. Let’s look at the first number, 2. We know all multiples of 2 must not be primes, so we mark them off as non-primes. Then we look at the next number, 3. Similarly, all multiples of 3 such as 3 × 2 = 6, 3 × 3 = 9, … must not be primes, so we mark them off as well. Now we look at the next number, 4, which was already marked off. What does this tell you? Should you mark off all multiples of 4 as well?</li><li>4 is not a prime because it is divisible by 2, which means all multiples of 4 must also be divisible by 2 and were already marked off. So we can skip 4 immediately and go to the next number, 5. Now, all multiples of 5 such as 5 × 2 = 10, 5 × 3 = 15, 5 × 4 = 20, 5 × 5 = 25, … can be marked off. There is a slight optimization here, we do not need to start from 5 × 2 = 10. Where should we start marking off?</li><li>让我们从一个包含 <code>n</code> 个数字的列表开始。首先看下第1个数字 <code>2</code>，我们知道 <code>2</code> 的倍数肯定不是质数，因此我们可以将它们标记为非质数。</li><li>之后，再看第2个数字 <code>3</code>，同样 <code>3</code> 的倍数也可以被标记为非质数。</li><li>之后，再看第3个数字 <code>4</code>，因为数字 <code>4</code> 是数字 <code>2</code> 的倍数，已经被标记为了非质数。因为 <code>4</code> 的倍数一定是 <code>2</code> 的倍数，即 <code>4</code> 的倍数已经被标记了，所以我们可以跳过数字 <code>4</code>，去看下一个数字 <code>5</code>。</li></ul><p>提示5</p><ul><li>In fact, we can mark off multiples of 5 starting at 5 × 5 = 25, because 5 × 2 = 10 was already marked off by multiple of 2, similarly 5 × 3 = 15 was already marked off by multiple of 3. Therefore, if the current number is p, we can always mark off multiples of p starting at <code>p^2</code>, then in increments of p: p^2 + p, p^2 + 2p, … Now what should be the terminating loop condition?</li><li>对于数字 <code>5</code> 的判断，此处有一个小优化项。我们真的需要从 <code>5</code> 的倍数 <code>10</code>，<code>15</code>，<code>20</code> 开始标记吗？其实是没必要的，因为数字 <code>10=2*5</code>，<code>15=3*5</code>，<code>20=4*5</code>，它们已经被标记处理了。总结可以发现，我们从 <code>25=5*5</code> 开始判断即可。即我们开始判断的起点是 <code>p^2</code>，后续标记为 <code>p^2 + p</code>， <code>p^2 + 2p</code>， <code>...</code></li></ul><p>提示6</p><ul><li>It is easy to say that the terminating loop condition is <code>p &lt; n</code>, which is certainly correct but not efficient. </li><li>Yes, the terminating loop condition can be <code>p &lt; √n</code>, as all <code>non-primes ≥ √n</code> must have already been marked off. When the loop terminates, all the numbers in the table that are non-marked are prime.</li><li>很容易发现，循环终止条件是 <code>p &lt; n</code>，但这个终止条件仅仅是正确的，不是最高效的。</li><li>实际上，循环终止条件应该是是 <code>p &lt;= √n</code>，因为所有大于 <code>√n</code> 的因数已经被标记处理了。</li><li>当上述循环判断结束后，所有没有被标记的数字就是质数。</li></ul><p>提示7</p><ul><li>The Sieve of Eratosthenes uses an extra <code>O(n)</code> memory and its runtime complexity is <code>O(nlogn)</code>. For the more mathematically inclined readers, you can read more about its algorithm complexity on <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_complexity" target="_blank" rel="noopener">Wikipedia</a>.</li><li><code>Sieve of Eratosthenes</code> 方法的空间复杂度是<code>O(n)</code>，时间复杂度是 <code>O(nlogn)</code>，更多数学推导可参考<a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_complexity" target="_blank" rel="noopener">Wikipedia</a>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">      isPrime[i] = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Loop's ending condition is i * i &lt; n instead of i &lt; sqrt(n)</span></span><br><span class="line">   <span class="comment">// to avoid repeatedly calling an expensive function sqrt().</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isPrime[i]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">         isPrime[j] = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isPrime[i]) count++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-1-参考题目提示使用Sieve-of-Eratosthenes"><a href="#Approach-1-参考题目提示使用Sieve-of-Eratosthenes" class="headerlink" title="Approach 1-参考题目提示使用Sieve of Eratosthenes"></a>Approach 1-参考题目提示使用Sieve of Eratosthenes</h3><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><p>参考题目提示，使用 <code>Sieve of Eratosthenes</code> 方法求解。</p><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">          isPrime[i] = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Loop's ending condition is i * i &lt; n instead of i &lt; sqrt(n)</span></span><br><span class="line">       <span class="comment">// to avoid repeatedly calling an expensive function sqrt().</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; n; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!isPrime[i]) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">             isPrime[j] = <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isPrime[i]) count++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="506-相对名次"><a href="#506-相对名次" class="headerlink" title="506. 相对名次"></a>506. 相对名次</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/relative-ranks/" target="_blank" rel="noopener">LeetCode-506. 相对名次</a></li></ul><h3 id="Approach-1-Map映射"><a href="#Approach-1-Map映射" class="headerlink" title="Approach 1-Map映射"></a>Approach 1-Map映射</h3><h4 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h4><p>很自然的会想到对数组进行排序。但直接排序的话，会丢失数组原有的顺序。因此，可以使用 <code>Map</code> 数据结构，维护一个分数和名次的映射关系。</p><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findRelativeRanks(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] numArrCopy = Arrays.copyOf(nums,nums.length);</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=nums.length;i&lt;nums.length;i++,j--)&#123;</span><br><span class="line">            map.put(nums[i],j);</span><br><span class="line">        &#125;</span><br><span class="line">        String [] res = <span class="keyword">new</span> String[map.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numArrCopy.length;i++)&#123;</span><br><span class="line">            Integer j = map.get(numArrCopy[i]);</span><br><span class="line">            <span class="keyword">switch</span>(j)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    res[i] = <span class="string">"Gold Medal"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    res[i] = <span class="string">"Silver Medal"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    res[i] = <span class="string">"Bronze Medal"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    res[i] = j.toString();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><p>C++中，借助 <code>pair&lt;int,int&gt;</code> 数据结构实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRelativeRanks(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res(nums.size());</span><br><span class="line">        <span class="built_in">string</span> ranks[<span class="number">3</span>] = &#123;<span class="string">"Gold Medal"</span>, <span class="string">"Silver Medal"</span>, <span class="string">"Bronze Medal"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            vec.push_back(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(i,nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> comp = [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; p1,<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; p2)&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.second &gt;p2.second;</span><br><span class="line">        &#125;;</span><br><span class="line">        sort(vec.begin(),vec.end(),comp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        res[vec[i].first] = ranks[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        res[vec[i].first] = to_string(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>JS</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findRelativeRanks = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//复制数组</span></span><br><span class="line">    <span class="keyword">var</span> sortedNums = nums.slice(<span class="number">0</span>);</span><br><span class="line">    sortedNums.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;  <span class="comment">//降序</span></span><br><span class="line">        <span class="keyword">return</span> b-a; </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> sortedNumsMapping = &#123;&#125;;</span><br><span class="line">    sortedNums.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">el,index</span>)</span>&#123;</span><br><span class="line">        sortedNumsMapping[el] = (index+<span class="number">1</span>).toString();</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    res = nums.map(<span class="function"><span class="keyword">function</span>(<span class="params">el,index</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(sortedNumsMapping[el] === <span class="string">'1'</span>)        <span class="keyword">return</span> <span class="string">"Gold Medal"</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(sortedNumsMapping[el] === <span class="string">'2'</span> ) <span class="keyword">return</span> <span class="string">"Silver Medal"</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(sortedNumsMapping[el] === <span class="string">'3'</span> ) <span class="keyword">return</span> <span class="string">"Bronze Medal"</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">return</span> (sortedNumsMapping[el]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a>61. 旋转链表</h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">LeetCode-61. 旋转链表</a></li></ul><h3 id="Approach-1-构造环形链表"><a href="#Approach-1-构造环形链表" class="headerlink" title="Approach 1-构造环形链表"></a>Approach 1-构造环形链表</h3><h4 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h4><p>查看 <code>leetcode-cn</code> 官方题解，求解本题。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-61-rotate-list-1.png" alt=""></p><p>结合上图分析</p><ol><li>先将链表闭合成环形链表</li><li>将链表每个节点向右移动 k 个位置，意味着链表头节点的移动</li><li>移动结束后，找到新的链表头节点和尾节点，并断开链表</li></ol><p>不难发现，若移动位置小于一圈时（<code>n&lt;k</code>），新的链表头节点在 <code>n-k</code>处，新的链表尾节点在 <code>n-k-1</code> 处。若移动位置大于一圈（<code>n&lt;k</code>），移动一整圈对结果并无影响。</p><p>因此，可以总结如下</p><ul><li>新的链表头节点在 <code>n - k%n</code> 处</li><li>新的链表尾节点在 <code>n - k%n - 1</code> 处</li></ul><p>算法实现思路如下</p><ol><li>找到旧的尾部，并将其与链表头相连 <code>old_tail.next = head</code>，整个链表闭合成环，同时计算出链表的长度 n</li><li>找到新的尾部，第 (<code>n - k % n - 1</code>) 个节点 ，新的链表头是第 (<code>n - k % n</code>) 个节点</li><li>断开环 <code>new_tail.next = null</code>，并返回新的链表头 <code>new_head</code>。</li></ol><p>复杂度分析</p><ul><li>时间复杂度：<code>O(N)</code>，其中 N 是链表中的元素个数</li><li>空间复杂度：<code>O(1)</code>，因为只需要常数的空间</li></ul><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base cases</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close the linked list into the ring</span></span><br><span class="line">    ListNode old_tail = head;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">for</span>(n = <span class="number">1</span>; old_tail.next != <span class="keyword">null</span>; n++)</span><br><span class="line">      old_tail = old_tail.next;</span><br><span class="line">    old_tail.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find new tail : (n - k % n - 1)th node</span></span><br><span class="line">    <span class="comment">// and new head : (n - k % n)th node</span></span><br><span class="line">    ListNode new_tail = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k % n - <span class="number">1</span>; i++)</span><br><span class="line">      new_tail = new_tail.next;</span><br><span class="line">    ListNode new_head = new_tail.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// break the ring</span></span><br><span class="line">    new_tail.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1389-按既定顺序创建目标数组"><a href="#1389-按既定顺序创建目标数组" class="headerlink" title="1389. 按既定顺序创建目标数组"></a>1389. 按既定顺序创建目标数组</h2><h3 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/create-target-array-in-the-given-order/" target="_blank" rel="noopener">LeetCode-1389. 按既定顺序创建目标数组</a></li></ul><h3 id="Approach-1-链表实现"><a href="#Approach-1-链表实现" class="headerlink" title="Approach 1-链表实现"></a>Approach 1-链表实现</h3><h4 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h4><ol><li>查看题目的限制条件 <code>0 &lt;= index[i] &lt;= i</code>，可知在插入第 <code>i</code> 个元素时，索引最多为最后一个元素。</li><li>分析题目可知，要在当前的下标从 0 开始长度为 n 的顺序表的 <code>i</code> 位置插入元素，就要先把原来表中区间 <code>[i, n]</code> 中的元素从全部向后移动一位，然后在 <code>i</code> 位置插入带插入的元素。</li><li>对于 Java 而言，可以使用 <code>ArrayList</code> 数据结构实现，其 <code>add(int index, E element)</code> 源码如下。</li></ol><p>可以发现，在调用 <code>add(int index, E element)</code>，会先检查是否需要扩容。若需要的话，会将 <code>index</code> 及其之后的元素都向后移动一位，并将新元素插入到 <code>idnex</code> 处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment"> * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment"> * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 1. 检测是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 2. 将 index 及其之后的所有元素都向后移一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">// 3. 将新元素插入至 index 处</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] createTargetArray(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] index) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res.add(index[i],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] target = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            target[i] = res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录LeetCode题目笔记，汇总LeetCode解答记录&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://lbs0912.github.io/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Hive入门篇——Hive安装配置，数据存储，表操作</title>
    <link href="https://lbs0912.github.io/2020/04/22/hive-basic-1/"/>
    <id>https://lbs0912.github.io/2020/04/22/hive-basic-1/</id>
    <published>2020-04-22T00:35:26.000Z</published>
    <updated>2020-04-21T22:52:36.232Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文为Hive入门篇，主要记录Hive安装配置，数据存储和表操作。</li></ul><a id="more"></a><h2 id="学习资料汇总"><a href="#学习资料汇总" class="headerlink" title="学习资料汇总"></a>学习资料汇总</h2><ul><li><a href="http://hive.apache.org/" target="_blank" rel="noopener">Hive官网</a></li><li><a href="https://cwiki.apache.org/confluence/display/Hive#Home-UserDocumentation" target="_blank" rel="noopener">User Documentation - Apache Hive</a></li><li><a href="http://blog.fens.me/hadoop-hive-roadmap/" target="_blank" rel="noopener">Hive学习路线图谱 | 粉丝日志</a></li><li><a href="http://blog.fens.me/hadoop-hive-intro/" target="_blank" rel="noopener">Hive安装及使用攻略 | 粉丝日志</a></li></ul><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><blockquote><p>Hive是建立在 Hadoop 上的数据仓库基础构架。</p></blockquote><p>Hive 是 Hadoop 家族中一款数据仓库产品，Hive 最大的特点就是提供了类 SQL 的语法，封装了底层的 MapReduce 过程，让有 SQL 基础的业务人员，也可以直接利用 Hadoop 进行大数据的操作。就是这一个点，解决了原数据分析人员对于大数据分析的瓶颈。</p><p><strong>Hive 可以将结构化的数据文件映射为一张数据库表，并提供完整的 SQL 查询功能，可以将 SQL 语句转换为 MapReduce 任务运行。Hive 定义了简单的类 SQL 查询语言，称为 HQL</strong>。</p><p>Hive 的知识图谱如下图所示。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/BigData2020/hadoop-hive-roadmap.png" alt=""></p><p>Hive 已经用类 SQL 的语法封装了 MapReduce 过程，这个封装过程就是 MapReduce 的标准化的过程。</p><p>我们在做业务或者工具时，会针对场景用逻辑封装，这里的第2层封装是在Hive之上的封装。在第2层封装时，我们要尽可能多的屏蔽 Hive 的细节，让接口单一化，低少灵活性，再次精简 HQL 的语法结构。只满足我们的系统要求，专用的接口。</p><p>在使用二次封装的接口时，我们已经可以不用知道 Hive 是什么, 更不用知道 Hadoop 是什么。只需要知道，SQL查询(SQL92标准)，怎么写效率高，怎么写可以完成业务需要就可以了。</p><p>当我们完成了 Hive 的二次封装后，我们可以构建标准化的 MapReduce 开发过程。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/BigData2020/hive-architect-2.jpg" alt=""></p><p>Hive 不适合用于联机（<code>online</code>）事务处理，也不提供实时查询功能。它最适合用在基于大量不可变数据的批处理作业。Hive特点是可伸缩（在Hadoop的集群上动态地添加设备），可扩展，容错，输入格式的松散耦合。</p><p>Hive 的最佳使用场合是大数据集的批处理作业，例如，网络日志分析。</p><h3 id="Hive和关系型数据库的区别"><a href="#Hive和关系型数据库的区别" class="headerlink" title="Hive和关系型数据库的区别"></a>Hive和关系型数据库的区别</h3><p>Hive 在很多方面与传统关系数据库类似（例如支持 SQL 接口），但是其底层对 HDFS 和 MapReduce 的依赖意味着它的体系结构有别于传统关系数据库，而这些区别又影响着 Hive 所支持的特性，进而影响着 Hive 的使用。</p><p>下面列举一些简单区别</p><ul><li>Hive 和关系数据库存储文件的系统不同，Hive 使用的是 Hadoop 的HDFS（Hadoop的分布式文件系统），关系数据库则是服务器本地的文件系统</li><li>Hive 使用的计算模型是 MapReduce，而关系数据库则是自己设计的计算模型</li><li>关系数据库都是为实时查询的业务进行设计的，而 Hive 则是为海量数据做数据挖掘设计的，实时性很差；实时性的区别导致 Hive 的应用场景和关系数据库有很大的不同</li><li>Hive 很容易扩展自己的存储能力和计算能力，这个是继承 Hadoop 的，而关系数据库在这个方面要差很多</li></ul><h2 id="Hive-安装配置"><a href="#Hive-安装配置" class="headerlink" title="Hive 安装配置"></a>Hive 安装配置</h2><p>Hive 安装参考资料如下</p><ul><li><a href="https://www.cnblogs.com/micrari/p/7067968.html" target="_blank" rel="noopener">Mac 上 Hive 环境搭建 | blog</a></li><li><a href="https://zhuanlan.zhihu.com/p/70601668" target="_blank" rel="noopener">MacOS 下hive的安装与配置 | 知乎</a></li><li><a href="http://blog.fens.me/hadoop-hive-intro/" target="_blank" rel="noopener">Hive安装及使用攻略 | 粉丝日志</a></li><li><a href="https://jyzhangchn.github.io/hive.html" target="_blank" rel="noopener">mac下Hive+MySql环境配置 | blog</a></li><li><a href="https://www.jianshu.com/p/5c11073d19d3" target="_blank" rel="noopener">Mac Hive 配置和安装 | 简书</a></li></ul><p>此处，简单记录Hive的安装和配置步骤</p><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><ol><li>通过 Homebrew 安装 mysql</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>mysql</span><br></pre></td></tr></table></figure><p>安装结束后，会有如下提示</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">We<span class="comment">'ve installed your MySQL database without a root password. To secure it run:</span></span><br><span class="line">    mysql_secure_installation</span><br><span class="line"></span><br><span class="line">MySQL <span class="keyword">is</span> configured <span class="keyword">to</span> only allow connections <span class="keyword">from</span> localhost <span class="keyword">by</span> <span class="keyword">default</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">To</span> connect run:</span><br><span class="line">    mysql -uroot</span><br><span class="line"></span><br><span class="line"><span class="keyword">To</span> have launchd start mysql now <span class="keyword">and</span> restart at login:</span><br><span class="line">  brew services start mysql</span><br><span class="line"><span class="keyword">Or</span>, <span class="keyword">if</span> you don<span class="comment">'t want/need a background service you can just run:</span></span><br><span class="line">  mysql.server start</span><br></pre></td></tr></table></figure><p>上述信息提示，</p><ul><li>运行 <code>brew services start mysql</code>，可以在后台启动 mysql</li><li>运行 <code>mysql.server start</code>，可以在前台启动 mysql（关闭控制台，服务停止）</li><li>运行 <code>mysql_secure_installation</code>，可以进行密码设置</li></ul><ol start="2"><li>使用 <code>mysql --version</code> 校验 mysql 版本号</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="comment">--version</span></span><br><span class="line"></span><br><span class="line">// mysql  Ver <span class="number">8.0</span><span class="number">.19</span> <span class="keyword">for</span> osx10<span class="number">.15</span> <span class="keyword">on</span> x86_64 (Homebrew)</span><br></pre></td></tr></table></figure><ol start="3"><li>设置mysql秘密，设定密码为 <code>mysql113459</code></li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew services <span class="built_in">start</span> mysql  <span class="comment"> //设定密码前需要先启动mysql</span></span><br><span class="line"></span><br><span class="line">mysql_secure_installation</span><br><span class="line">//密码设定为 mysql113459</span><br></pre></td></tr></table></figure><p>MySQL 新版本中引入了密码安全级别的概念，设置低强度的密码有时会被禁止。为此可以直接指定密码安全强度，执行下述命令。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global validate_password_policy=0;  //设置密码强度级别为low</span><br><span class="line">mysql&gt; set global validate_password_length=1;   //设置密码最小长度为4</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE 'validate_password%';    //查看密码相关参数设置</span><br><span class="line"></span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">|<span class="string"> Variable_name                        </span>|<span class="string"> Value  </span>|</span><br><span class="line">+--------------------------------------+--------+</span><br><span class="line">|<span class="string"> validate_password.check_user_name    </span>|<span class="string"> ON     </span>|</span><br><span class="line">|<span class="string"> validate_password.dictionary_file    </span>|<span class="string">        </span>|</span><br><span class="line">|<span class="string"> validate_password.length             </span>|<span class="string"> 8      </span>|</span><br><span class="line">|<span class="string"> validate_password.mixed_case_count   </span>|<span class="string"> 1      </span>|</span><br><span class="line">|<span class="string"> validate_password.number_count       </span>|<span class="string"> 1      </span>|</span><br><span class="line">|<span class="string"> validate_password.policy             </span>|<span class="string"> MEDIUM </span>|</span><br><span class="line">|<span class="string"> validate_password.special_char_count </span>|<span class="string"> 1      </span>|</span><br><span class="line">|<span class="string"> validate_password_check_user_name    </span>|<span class="string"> ON     </span>|</span><br><span class="line">|<span class="string"> validate_password_dictionary_file    </span>|<span class="string">        </span>|</span><br><span class="line">|<span class="string"> validate_password_length             </span>|<span class="string"> 4      </span>|</span><br><span class="line">|<span class="string"> validate_password_mixed_case_count   </span>|<span class="string"> 1      </span>|</span><br><span class="line">|<span class="string"> validate_password_number_count       </span>|<span class="string"> 1      </span>|</span><br><span class="line">|<span class="string"> validate_password_policy             </span>|<span class="string"> LOW    </span>|</span><br><span class="line">|<span class="string"> validate_password_special_char_count </span>|<span class="string"> 1      </span>|</span><br><span class="line">+--------------------------------------+--------+</span><br></pre></td></tr></table></figure><p>若执行 <code>SHOW VARIABLES LIKE &#39;validate_password%&#39;;</code> 遇到 <code>Unknown system variable &#39;validate_password_policy&#39;</code> 报错信息，可以参考 <a href="https://stackoverflow.com/questions/55237257/mysql-validate-password-policy-unknown-system-variable" target="_blank" rel="noopener">MySQL validate_password_policy unknown system variable | StackOverflow</a> 进行处理。</p><blockquote><p>This problem has happened because validate_password plugin is by default NOT activated. </p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> plugin_name, plugin_status <span class="keyword">from</span> information_schema.plugins <span class="keyword">where</span> plugin_name <span class="keyword">like</span> <span class="string">'validate%'</span>;</span><br><span class="line"></span><br><span class="line">mysql&gt; install plugin validate_password soname <span class="string">'validate_password.so'</span>;</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> plugin_name, plugin_status <span class="keyword">from</span> information_schema.plugins <span class="keyword">where</span> plugin_name <span class="keyword">like</span> <span class="string">'validate%'</span>;</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">'validate_password%'</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>mysql启动</li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">brew services <span class="built_in">start</span> mysql  <span class="comment"> //后台启动</span></span><br><span class="line"></span><br><span class="line">sudo mysql.server <span class="built_in">start</span>    <span class="comment"> //前台启动</span></span><br><span class="line"></span><br><span class="line">//若遇到权限问题，可执行下述命令</span><br><span class="line">sudo chmod -R <span class="keyword">a</span>+rwx /usr/<span class="built_in">local</span>/var/mysql</span><br></pre></td></tr></table></figure><ol start="5"><li>mysql关闭</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql<span class="selector-class">.server</span> stop</span><br></pre></td></tr></table></figure><ol start="6"><li>mysql重启</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql.<span class="keyword">server</span> <span class="keyword">restart</span></span><br></pre></td></tr></table></figure><ol start="7"><li>查看默认数据库</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p    <span class="regexp">//</span>密码  mysql113459</span><br><span class="line"></span><br><span class="line">show databases</span><br><span class="line"></span><br><span class="line"><span class="keyword">exit</span>  <span class="regexp">//</span>退出mysql交互CI</span><br></pre></td></tr></table></figure><h3 id="Hive-安装"><a href="#Hive-安装" class="headerlink" title="Hive 安装"></a>Hive 安装</h3><ol><li>通过 Homebrew 安装 Hive</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>hive</span><br></pre></td></tr></table></figure><p>安装结束后，会有如下提示</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Caveats</span><br><span class="line">Hadoop must be <span class="keyword">in</span> your path <span class="keyword">for</span> hive executable <span class="keyword">to</span> work.</span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> you want <span class="keyword">to</span> use HCatalog with Pig, <span class="builtin-name">set</span> <span class="variable">$HCAT_HOME</span> <span class="keyword">in</span> your profile:</span><br><span class="line">  <span class="builtin-name">export</span> <span class="attribute">HCAT_HOME</span>=/usr/local/opt/hive/libexec/hcatalog</span><br><span class="line">==&gt; Summary</span><br><span class="line">🍺  /usr/local/Cellar/hive/3.1.2: 1,126 files, 231.8MB, built <span class="keyword">in</span> 7 seconds</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>hive --version</code> 校验 hive 版本号</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lbsMacBook-<span class="string">Pro:</span>~ lbs$ hive --version</span><br><span class="line"><span class="string">SLF4J:</span> Class path contains multiple SLF4J bindings.</span><br><span class="line"><span class="string">SLF4J:</span> Found binding <span class="keyword">in</span> [<span class="string">jar:</span><span class="string">file:</span><span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>hive<span class="regexp">/3.1.2/</span>libexec<span class="regexp">/lib/</span>log4j-slf4j-impl<span class="number">-2.10</span><span class="number">.0</span>.jar!<span class="regexp">/org/</span>slf4j<span class="regexp">/impl/</span>StaticLoggerBinder.<span class="keyword">class</span>]</span><br><span class="line"><span class="string">SLF4J:</span> Found binding <span class="keyword">in</span> [<span class="string">jar:</span><span class="string">file:</span><span class="regexp">/Library/</span>hadoop<span class="number">-2.10</span><span class="number">.0</span><span class="regexp">/share/</span>hadoop<span class="regexp">/common/</span>lib<span class="regexp">/slf4j-log4j12-1.7.25.jar!/</span>org<span class="regexp">/slf4j/</span>impl/StaticLoggerBinder.<span class="keyword">class</span>]</span><br><span class="line"><span class="string">SLF4J:</span> See <span class="string">http:</span><span class="comment">//www.slf4j.org/codes.html#multiple_bindings for an explanation.</span></span><br><span class="line"><span class="string">SLF4J:</span> Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]</span><br><span class="line">Hive <span class="number">3.1</span><span class="number">.2</span></span><br><span class="line">Git <span class="string">git:</span><span class="comment">//HW13934/Users/gates/tmp/hive-branch-3.1/hive -r 8190d2be7b7165effa62bd21b7d60ef81fb0e4af</span></span><br><span class="line">Compiled by gates on Thu Aug <span class="number">22</span> <span class="number">15</span>:<span class="number">01</span>:<span class="number">18</span> PDT <span class="number">2019</span></span><br><span class="line">From source with checksum <span class="number">0492</span>c08f784b188c349f6afb1d8d9847</span><br></pre></td></tr></table></figure><ol start="3"><li>hive 环境变量配置</li></ol><p>(1) 打开配置文件</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~<span class="string">/.bash_profile</span></span><br></pre></td></tr></table></figure><p>(2) 更新配置文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HIVE_HOME</span>=/usr/local/Cellar/hive/3.1.2 </span><br><span class="line"><span class="attribute">HCAT_HOME</span>=/usr/local/opt/hive/libexec/hcatalog</span><br><span class="line"><span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$&#123;HIVE_HOME&#125;/bin</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span> HIVE_HOME</span><br><span class="line"><span class="builtin-name">export</span> HCAT_HOME</span><br></pre></td></tr></table></figure><p>(3) 使配置文件生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><h3 id="修改-Hive-默认元数据库"><a href="#修改-Hive-默认元数据库" class="headerlink" title="修改 Hive 默认元数据库"></a>修改 Hive 默认元数据库</h3><blockquote><p>默认情况下，Hive 元数据保存在内嵌的 Derby 数据库中，只能允许一个会话连接，只适合简单的测试。实际生产环境中不使用，为了支持多用户会话，则需要一个独立的元数据库，可以使用 MySQL 作为元数据库，Hive 内部对 MySQL 提供了很好的支持。</p></blockquote><ol><li>Hive 默认元数据库是 derby。为了方便，这里给出用 mysql 储存元数据的配置</li></ol><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//创建数据库metastore</span><br><span class="line">mysql&gt; <span class="keyword">create</span> <span class="keyword">database</span> metastore; </span><br><span class="line"></span><br><span class="line">//创建用户名为hive，登录密码为Hive113459...的账户</span><br><span class="line">mysql&gt; <span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'hive'</span>@<span class="string">'localhost'</span> identified <span class="keyword">by</span> <span class="string">'Hive113459...'</span>; </span><br><span class="line"></span><br><span class="line">//给建好的数据库添加权限</span><br><span class="line">grant <span class="keyword">select</span>,<span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">delete</span>,<span class="keyword">alter</span>,<span class="keyword">create</span>,<span class="keyword">index</span>,references <span class="keyword">on</span> metastore.* <span class="keyword">to</span> <span class="string">'hive'</span>@<span class="string">'localhost'</span>; </span><br><span class="line"></span><br><span class="line">// 刷新权限</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><h3 id="Hive-配置"><a href="#Hive-配置" class="headerlink" title="Hive 配置"></a>Hive 配置</h3><ol><li>进入 Hive 的安装目录，创建 <code>hive-site.xml</code> 文件</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/Cellar/hive/<span class="number">3.1</span>.<span class="number">2</span>/libexec/conf</span><br><span class="line">$ cp hive-default<span class="selector-class">.xml</span><span class="selector-class">.template</span> hive-site<span class="selector-class">.xml</span>    <span class="comment">//复制提供的模板文件</span></span><br></pre></td></tr></table></figure><p>在配置文件中，对以下几个属性进行修改。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">  <span class="params">&lt;name&gt;</span>javax.jdo.option.ConnectionURL<span class="params">&lt;/name&gt;</span></span><br><span class="line">  <span class="params">&lt;value&gt;</span>jdbc:mysql:<span class="comment">//localhost/metastore&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">  <span class="params">&lt;name&gt;</span>javax.jdo.option.ConnectionDriverName<span class="params">&lt;/name&gt;</span></span><br><span class="line">  <span class="params">&lt;value&gt;</span>com.mysql.jdbc.Driver<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">  <span class="params">&lt;name&gt;</span>javax.jdo.option.ConnectionUserName<span class="params">&lt;/name&gt;</span></span><br><span class="line">  <span class="params">&lt;value&gt;</span>hive(上述mysql中创建的用户名)<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">  <span class="params">&lt;name&gt;</span>javax.jdo.option.ConnectionPassword<span class="params">&lt;/name&gt;</span></span><br><span class="line">  <span class="params">&lt;value&gt;</span>Hive113459...(上述mysql中创建的用户密码)<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">  <span class="params">&lt;name&gt;</span>hive.exec.local.scratchdir<span class="params">&lt;/name&gt;</span></span><br><span class="line">  <span class="params">&lt;value&gt;</span><span class="meta-keyword">/tmp/</span>hive<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">  <span class="params">&lt;name&gt;</span>hive.querylog.location<span class="params">&lt;/name&gt;</span></span><br><span class="line">  <span class="params">&lt;value&gt;</span><span class="meta-keyword">/tmp/</span>hive<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">  <span class="params">&lt;name&gt;</span>hive.downloaded.resources.dir<span class="params">&lt;/name&gt;</span></span><br><span class="line">  <span class="params">&lt;value&gt;</span><span class="meta-keyword">/tmp/</span>hive<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">  <span class="params">&lt;name&gt;</span>hive.server2.logging.operation.log.location<span class="params">&lt;/name&gt;</span></span><br><span class="line">  <span class="params">&lt;value&gt;</span><span class="meta-keyword">/tmp/</span>hive/operation_logs<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>拷贝 <code>mysql-connector</code> 到 hive 的安装目录下</li></ol><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L <span class="string">'http://www.mysql.com/get/Downloads/Connector-J/mysql-connector-java-8.0.15.tar.gz/from/http://mysql.he.net/'</span> | tar xz</span><br><span class="line"></span><br><span class="line">$ cp mysql-connector-java-<span class="number">8.0</span>.<span class="number">15</span>/mysql-connector-java-<span class="number">8.0</span>.<span class="number">15</span>-bin.jar /usr/local/Cellar/hive/<span class="number">3.1</span>.<span class="number">2</span>/libexec/<span class="class"><span class="keyword">lib</span>/</span></span><br></pre></td></tr></table></figure><ol start="3"><li>初始化 metastore 数据库</li></ol><p>目前直接查看 <code>metastore</code> 数据库，可以发现数据库是空的。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">show </span>databases<span class="comment">;</span></span><br><span class="line">mysql&gt; use metastore<span class="comment">;</span></span><br><span class="line">mysql&gt; <span class="keyword">show </span>tables<span class="comment">;   // empty</span></span><br></pre></td></tr></table></figure><p>在命令行模式（非mysql CLI）下执行下述命令，初始化 metastore 数据库</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> schematool -initSchema -dbType mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">//Initialization script completed</span></span><br><span class="line"><span class="comment">//schemaTool completed</span></span><br></pre></td></tr></table></figure><p>执行完毕后，再次查看数据库，会发现如下信息</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+-------------------------------+</span><br><span class="line">|<span class="string"> Tables_in_metastore           </span>|</span><br><span class="line">+-------------------------------+</span><br><span class="line">|<span class="string"> AUX_TABLE                     </span>|</span><br><span class="line">|<span class="string"> BUCKETING_COLS                </span>|</span><br><span class="line">|<span class="string"> CDS                           </span>|</span><br><span class="line">|<span class="string"> COLUMNS_V2                    </span>|</span><br><span class="line">|<span class="string"> COMPACTION_QUEUE              </span>|</span><br><span class="line">|<span class="string"> COMPLETED_COMPACTIONS         </span>|</span><br><span class="line">|<span class="string"> COMPLETED_TXN_COMPONENTS      </span>|</span><br><span class="line">|<span class="string"> CTLGS                         </span>|</span><br><span class="line">|<span class="string"> DATABASE_PARAMS               </span>|</span><br><span class="line">|<span class="string"> DB_PRIVS                      </span>|</span><br><span class="line">|<span class="string"> DBS                           </span>|</span><br><span class="line">|<span class="string"> DELEGATION_TOKENS             </span>|</span><br><span class="line">|<span class="string"> FUNC_RU                       </span>|</span><br><span class="line">|<span class="string"> FUNCS                         </span>|</span><br><span class="line">|<span class="string"> GLOBAL_PRIVS                  </span>|</span><br><span class="line">|<span class="string"> HIVE_LOCKS                    </span>|</span><br><span class="line">|<span class="string"> I_SCHEMA                      </span>|</span><br><span class="line">|<span class="string"> IDXS                          </span>|</span><br><span class="line">|<span class="string"> INDEX_PARAMS                  </span>|</span><br><span class="line">|<span class="string"> KEY_CONSTRAINTS               </span>|</span><br><span class="line">|<span class="string"> MASTER_KEYS                   </span>|</span><br><span class="line">|<span class="string"> MATERIALIZATION_REBUILD_LOCKS </span>|</span><br><span class="line">|<span class="string"> METASTORE_DB_PROPERTIES       </span>|</span><br><span class="line">|<span class="string"> MIN_HISTORY_LEVEL             </span>|</span><br><span class="line">|<span class="string"> MV_CREATION_METADATA          </span>|</span><br><span class="line">|<span class="string"> MV_TABLES_USED                </span>|</span><br><span class="line">|<span class="string"> NEXT_COMPACTION_QUEUE_ID      </span>|</span><br><span class="line">|<span class="string"> NEXT_LOCK_ID                  </span>|</span><br><span class="line">|<span class="string"> NEXT_TXN_ID                   </span>|</span><br><span class="line">|<span class="string"> NEXT_WRITE_ID                 </span>|</span><br><span class="line">|<span class="string"> NOTIFICATION_LOG              </span>|</span><br><span class="line">|<span class="string"> NOTIFICATION_SEQUENCE         </span>|</span><br><span class="line">|<span class="string"> NUCLEUS_TABLES                </span>|</span><br><span class="line">|<span class="string"> PART_COL_PRIVS                </span>|</span><br><span class="line">|<span class="string"> PART_COL_STATS                </span>|</span><br><span class="line">|<span class="string"> PART_PRIVS                    </span>|</span><br><span class="line">|<span class="string"> PARTITION_EVENTS              </span>|</span><br><span class="line">|<span class="string"> PARTITION_KEY_VALS            </span>|</span><br><span class="line">|<span class="string"> PARTITION_KEYS                </span>|</span><br><span class="line">|<span class="string"> PARTITION_PARAMS              </span>|</span><br><span class="line">|<span class="string"> PARTITIONS                    </span>|</span><br><span class="line">|<span class="string"> REPL_TXN_MAP                  </span>|</span><br><span class="line">|<span class="string"> ROLE_MAP                      </span>|</span><br><span class="line">|<span class="string"> ROLES                         </span>|</span><br><span class="line">|<span class="string"> RUNTIME_STATS                 </span>|</span><br><span class="line">|<span class="string"> SCHEMA_VERSION                </span>|</span><br><span class="line">|<span class="string"> SD_PARAMS                     </span>|</span><br><span class="line">|<span class="string"> SDS                           </span>|</span><br><span class="line">|<span class="string"> SEQUENCE_TABLE                </span>|</span><br><span class="line">|<span class="string"> SERDE_PARAMS                  </span>|</span><br><span class="line">|<span class="string"> SERDES                        </span>|</span><br><span class="line">|<span class="string"> SKEWED_COL_NAMES              </span>|</span><br><span class="line">|<span class="string"> SKEWED_COL_VALUE_LOC_MAP      </span>|</span><br><span class="line">|<span class="string"> SKEWED_STRING_LIST            </span>|</span><br><span class="line">|<span class="string"> SKEWED_STRING_LIST_VALUES     </span>|</span><br><span class="line">|<span class="string"> SKEWED_VALUES                 </span>|</span><br><span class="line">|<span class="string"> SORT_COLS                     </span>|</span><br><span class="line">|<span class="string"> TAB_COL_STATS                 </span>|</span><br><span class="line">|<span class="string"> TABLE_PARAMS                  </span>|</span><br><span class="line">|<span class="string"> TBL_COL_PRIVS                 </span>|</span><br><span class="line">|<span class="string"> TBL_PRIVS                     </span>|</span><br><span class="line">|<span class="string"> TBLS                          </span>|</span><br><span class="line">|<span class="string"> TXN_COMPONENTS                </span>|</span><br><span class="line">|<span class="string"> TXN_TO_WRITE_ID               </span>|</span><br><span class="line">|<span class="string"> TXNS                          </span>|</span><br><span class="line">|<span class="string"> TYPE_FIELDS                   </span>|</span><br><span class="line">|<span class="string"> TYPES                         </span>|</span><br><span class="line">|<span class="string"> VERSION                       </span>|</span><br><span class="line">|<span class="string"> WM_MAPPING                    </span>|</span><br><span class="line">|<span class="string"> WM_POOL                       </span>|</span><br><span class="line">|<span class="string"> WM_POOL_TO_TRIGGER            </span>|</span><br><span class="line">|<span class="string"> WM_RESOURCEPLAN               </span>|</span><br><span class="line">|<span class="string"> WM_TRIGGER                    </span>|</span><br><span class="line">|<span class="string"> WRITE_SET                     </span>|</span><br><span class="line">+-------------------------------+</span><br><span class="line">74 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><h3 id="启动-Hive"><a href="#启动-Hive" class="headerlink" title="启动 Hive"></a>启动 Hive</h3><p>启动Hive前，需要先运行Hadoop。之后运行 <code>hive</code> 或者 <code>hive shell</code> 可以进入Hive Shell</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hive </span><br><span class="line"></span><br><span class="line">//or</span><br><span class="line"> hive <span class="keyword">shell</span><span class="bash"></span></span><br><span class="line"><span class="bash"> </span></span><br><span class="line"> </span><br><span class="line">hive&gt;</span><br></pre></td></tr></table></figure><h3 id="可视化工具-DbVisualizer"><a href="#可视化工具-DbVisualizer" class="headerlink" title="可视化工具 DbVisualizer"></a>可视化工具 DbVisualizer</h3><ul><li><a href="https://www.dbvis.com/download/11.0" target="_blank" rel="noopener">DbVisualizer Software</a></li><li><a href="http://confluence.dbvis.com/display/UG110/Installing" target="_blank" rel="noopener">DbVisualizer User Guide</a></li><li><a href="http://confluence.dbvis.com/display/UG110/Installing+a+JDBC+Driver" target="_blank" rel="noopener">Installing a JDBC Driver</a></li><li><a href="https://www.dbvis.com/features/database-drivers/" target="_blank" rel="noopener">Supported databases and JDBC drivers Download</a></li><li><a href="https://juejin.im/post/5d04675051882518e845cb8f" target="_blank" rel="noopener">在mac上DbVisualizer图形化客户端配置连接Hive | Blog</a></li><li><a href="https://github.com/timveil/hive-jdbc-uber-jar/releases" target="_blank" rel="noopener">hive-jdbc-uber-jar | github</a></li></ul><ol><li><p>下载 <code>dbvis_macos_11_0_jre.dmg</code> 并执行安装</p></li><li><p>也可以下载 <code>.tar.gz</code> 包进行安装 </p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gunzip</span> <span class="selector-tag">dbvis_unix_11_0</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">xf</span> <span class="selector-tag">dbvis_unix_11_0</span><span class="selector-class">.tar</span></span><br></pre></td></tr></table></figure><ol start="3"><li>点击 Docker 中 DbVisualizer图标启动，或使用如下脚本启动</li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DbVisualizer/dbvis.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><ol start="4"><li>从 <a href="https://github.com/timveil/hive-jdbc-uber-jar/releases" target="_blank" rel="noopener">hive-jdbc-uber-jar | github</a> 下载 <code>hive-jdbc-uber-jar</code>，放置到 <code>/Users/lbs/.dbvis/jdbc</code> 路径下，并导入到 DbVisualizer 配置中</li></ol><ol start="5"><li>在 DbVisualizer 的偏好设置中的 <code>Specify overridden Java VM Prperties here</code> 中添加如下设置</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Dsun<span class="selector-class">.security</span><span class="selector-class">.krb5</span><span class="selector-class">.debug</span>=true</span><br><span class="line">-Djavax<span class="selector-class">.security</span><span class="selector-class">.auth</span><span class="selector-class">.useSubjectCredsOnly</span>=false</span><br></pre></td></tr></table></figure><h2 id="Hive交互式模式-CLI"><a href="#Hive交互式模式-CLI" class="headerlink" title="Hive交互式模式 CLI"></a>Hive交互式模式 CLI</h2><p>运行 <code>hive</code> 或者 <code>hive shell</code> 可以进入Hive Shell。Hive的交互模式遵循下述规则。</p><ol><li><code>quit</code>,<code>exit</code>:  退出交互式shell</li><li><code>reset</code>: 重置配置为默认值</li><li><code>set &lt;key&gt;=&lt;value&gt;</code> : 修改特定变量的值(如果变量名拼写错误，不会报错)</li><li><code>set</code> :  输出用户覆盖的 hive配置变量</li><li><code>set -v</code> : 输出所有Hadoop和Hive的配置变量</li><li><code>add FILE[S] *</code>, <code>add JAR[S] *</code>, <code>add ARCHIVE[S] *</code> : 添加 一个或多个 file, jar, archives到分布式缓存</li><li><code>list FILE[S]</code>, <code>list JAR[S]</code>, <code>list ARCHIVE[S]</code> : 输出已经添加到分布式缓存的资源</li><li><code>list FILE[S] *</code>, <code>list JAR[S] *</code>,<code>list ARCHIVE[S] *</code> : 检查给定的资源是否添加到分布式缓存</li><li><code>delete FILE[S] *</code>, <code>delete JAR[S] *</code>, <code>delete ARCHIVE[S] *</code> : 从分布式缓存删除指定的资源</li><li><code>! &lt;command&gt;</code> :  从 Hive shell 执行一个 shell 命令</li><li><code>dfs &lt;dfs command&gt;</code> :  从 Hive shell 执行一个 dfs 命令</li><li><code>&lt;query string&gt;</code> : 执行一个 Hive 查询，然后输出结果到标准输出</li><li><code>source FILE &lt;filepath&gt;</code>:  在 CLI 里执行一个 hive 脚本文件</li><li><code>!clear;</code>: 清除命令行</li><li><code>show tables;</code>： 展示数据表</li><li><code>desc tableName</code>：展示一个数据表的结构</li></ol><p>和SQL类似，HiveQL一般是大小写不敏感的（除了字符串比较以外），因此 <code>show tables;</code> 等同于 <code>SHOW TABLES;</code>。制表符（Tab）会自动补全 Hive 的关键字和函数。</p><p>下面给出一个简单的 Hive Shell 操作 Demo，详情参考 <a href="http://blog.fens.me/hadoop-hive-intro/" target="_blank" rel="noopener">Hive安装及使用攻略 | 粉丝日志</a>。</p><ul><li>创建本地数据文件(文本以tab分隔)</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~ vi /home/cos/demo/t_hive.txt</span><br><span class="line"></span><br><span class="line"><span class="number">16</span>      <span class="number">2</span>       <span class="number">3</span></span><br><span class="line"><span class="number">61</span>      <span class="number">12</span>      <span class="number">13</span></span><br><span class="line"><span class="number">41</span>      <span class="number">2</span>       <span class="number">31</span></span><br><span class="line"><span class="number">17</span>      <span class="number">21</span>      <span class="number">3</span></span><br><span class="line"><span class="number">71</span>      <span class="number">2</span>       <span class="number">31</span></span><br><span class="line"><span class="number">1</span>       <span class="number">12</span>      <span class="number">34</span></span><br><span class="line"><span class="number">11</span>      <span class="number">2</span>       <span class="number">34</span></span><br></pre></td></tr></table></figure><ul><li>进入Hive Shell，创建新表</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#创建新表</span><br><span class="line">hive&gt; <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_hive (a <span class="type">int</span>, b <span class="type">int</span>, c <span class="type">int</span>) <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">'\t'</span>;</span><br><span class="line">OK</span><br><span class="line"><span class="type">Time</span> taken: <span class="number">0.489</span> seconds</span><br></pre></td></tr></table></figure><ul><li>查看表</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; <span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line">OK</span><br><span class="line">t_hive</span><br><span class="line"><span class="type">Time</span> taken: <span class="number">0.099</span> seconds</span><br></pre></td></tr></table></figure><ul><li>正则匹配表名</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;<span class="keyword">show</span> <span class="keyword">tables</span> <span class="string">'*t*'</span>;</span><br><span class="line">OK</span><br><span class="line">t_hive</span><br><span class="line"><span class="type">Time</span> taken: <span class="number">0.065</span> seconds</span><br></pre></td></tr></table></figure><ul><li>查看表数据</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; select * <span class="keyword">from</span> t_hive;</span><br><span class="line">OK</span><br><span class="line"><span class="number">16</span>      <span class="number">2</span>       <span class="number">3</span></span><br><span class="line"><span class="number">61</span>      <span class="number">12</span>      <span class="number">13</span></span><br><span class="line"><span class="number">41</span>      <span class="number">2</span>       <span class="number">31</span></span><br><span class="line"><span class="number">17</span>      <span class="number">21</span>      <span class="number">3</span></span><br><span class="line"><span class="number">71</span>      <span class="number">2</span>       <span class="number">31</span></span><br><span class="line"><span class="number">1</span>       <span class="number">12</span>      <span class="number">34</span></span><br><span class="line"><span class="number">11</span>      <span class="number">2</span>       <span class="number">34</span></span><br><span class="line">Time taken: <span class="number">0.264</span> seconds</span><br></pre></td></tr></table></figure><ul><li>查看表结构</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; <span class="keyword">desc</span> t_hive;</span><br><span class="line">OK</span><br><span class="line">a       <span class="type">int</span></span><br><span class="line">b       <span class="type">int</span></span><br><span class="line">c       <span class="type">int</span></span><br><span class="line"><span class="type">Time</span> taken: <span class="number">0.1</span> seconds</span><br></pre></td></tr></table></figure><ul><li>修改表，增加一个字段</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t_hive <span class="keyword">ADD</span> <span class="keyword">COLUMNS</span> (new_col String);</span><br><span class="line">OK</span><br><span class="line"><span class="type">Time</span> taken: <span class="number">0.186</span> seconds</span><br><span class="line">hive&gt; <span class="keyword">desc</span> t_hive;</span><br><span class="line">OK</span><br><span class="line">a       <span class="type">int</span></span><br><span class="line">b       <span class="type">int</span></span><br><span class="line">c       <span class="type">int</span></span><br><span class="line">new_col string</span><br><span class="line"><span class="type">Time</span> taken: <span class="number">0.086</span> seconds</span><br></pre></td></tr></table></figure><ul><li>删除表</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; <span class="keyword">DROP</span> <span class="keyword">TABLE</span> t_hadoop;</span><br><span class="line">OK</span><br><span class="line"><span class="type">Time</span> taken: <span class="number">0.767</span> seconds</span><br><span class="line"></span><br><span class="line">hive&gt; <span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line">OK</span><br><span class="line"><span class="type">Time</span> taken: <span class="number">0.064</span> seconds</span><br></pre></td></tr></table></figure><h2 id="Beeline"><a href="#Beeline" class="headerlink" title="Beeline"></a>Beeline</h2><h3 id="HiveServer2"><a href="#HiveServer2" class="headerlink" title="HiveServer2"></a>HiveServer2</h3><p>Hive 内置了 <code>HiveServer</code> 和 <code>HiveServer2</code> 服务，两者都允许客户端使用多种编程语言进行连接，但是 HiveServer 不能处理多个客户端的并发请求，所以产生了 <code>HiveServer2</code>。</p><p><code>HiveServer2</code>（<code>HS2</code>）允许远程客户端可以使用各种编程语言向 Hive 提交请求并检索结果，支持多客户端并发访问和身份验证。HS2 是由多个服务组成的单个进程，其包括基于 Thrift 的 Hive 服务（TCP 或 HTTP）和用于 Web UI 的 Jetty Web 服务器。</p><p>HiveServer2 拥有自己的 CLI(<code>Beeline</code>)，Beeline 是一个基于 SQLLine 的 JDBC 客户端。由于 HiveServer2 是 Hive 开发维护的重点 (Hive0.15 后就不再支持 hiveserver)，所以 Hive CLI 已经不推荐使用了，官方更加推荐使用 Beeline。</p><ul><li><a href="https://juejin.im/post/5d8593905188254009777049" target="_blank" rel="noopener">Hive CLI 和 Beeline 命令行的基本使用</a></li></ul><h3 id="Beeline-参数"><a href="#Beeline-参数" class="headerlink" title="Beeline 参数"></a>Beeline 参数</h3><p>Beeline 拥有更多可使用参数，可以使用 <code>beeline --help</code> 查看，完整参数如下</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"> // ...</span></span><br><span class="line"><span class="comment"> // ...</span></span><br><span class="line"> </span><br><span class="line">Example:</span><br><span class="line"> <span class="number">1.</span> Connect <span class="keyword">using</span> simple authentication <span class="built_in">to</span> HiveServer2 <span class="keyword">on</span> <span class="title">localhost</span>:<span class="title">10000</span></span><br><span class="line"> $ beeline -u jdbc:hive2://localhost:<span class="number">10000</span> username password</span><br><span class="line"></span><br><span class="line"> <span class="number">2.</span> Connect <span class="keyword">using</span> simple authentication <span class="built_in">to</span> HiveServer2 <span class="keyword">on</span> <span class="title">hs</span>.<span class="title">local</span>:<span class="title">10000</span> <span class="title">using</span> -<span class="title">n</span> <span class="title">for</span> <span class="title">username</span> <span class="title">and</span> -<span class="title">p</span> <span class="title">for</span> <span class="title">password</span></span><br><span class="line"> $ beeline -n username -p password -u jdbc:hive2://hs2.<span class="built_in">local</span>:<span class="number">10012</span></span><br><span class="line"></span><br><span class="line"> <span class="number">3.</span> Connect <span class="keyword">using</span> Kerberos authentication <span class="keyword">with</span> hive/localhost@mydomain.com <span class="keyword">as</span> HiveServer2 principal</span><br><span class="line"> $ beeline -u <span class="string">"jdbc:hive2://hs2.local:10013/default;principal=hive/localhost@mydomain.com"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">4.</span> Connect <span class="keyword">using</span> SSL connection <span class="built_in">to</span> HiveServer2 <span class="keyword">on</span> <span class="title">localhost</span> <span class="title">at</span> <span class="title">10000</span></span><br><span class="line"> $ beeline <span class="string">"jdbc:hive2://localhost:10000/default;ssl=true;sslTrustStore=/usr/local/truststore;trustStorePassword=mytruststorepassword"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">5.</span> Connect <span class="keyword">using</span> LDAP authentication</span><br><span class="line"> $ beeline -u jdbc:hive2://hs2.<span class="built_in">local</span>:<span class="number">10013</span>/default &lt;ldap-username&gt; &lt;ldap-password&gt;</span><br></pre></td></tr></table></figure><p>在 Hive CLI 中支持的参数，Beeline 都支持，常用的参数如下。更多参数说明可以参见官方文档 <a href="https://cwiki.apache.org/confluence/display/Hive/HiveServer2+Clients#HiveServer2Clients-Beeline%E2%80%93NewCommandLineShell" target="_blank" rel="noopener">Beeline Command Options</a>。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-u <database URL></td><td>数据库地址</td></tr><tr><td>-n <username></td><td>用户名</td></tr><tr><td>-p <password></td><td>密码</td></tr><tr><td>-d <driver class></td><td>驱动 (可选)</td></tr><tr><td>-e <query></td><td>执行 SQL 命令</td></tr><tr><td>-f <file></td><td>执行 SQL 脚本</td></tr></tbody></table><p>例如，使用用户名和密码连接 Hive</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $ beeline -u jdbc:hive2://localhost:10000  -n username -p password </span></span><br><span class="line">$ beeline -u <span class="string">jdbc:</span><span class="string">hive2:</span><span class="comment">//localhost:10000  -n hive -p Hive113459...</span></span><br></pre></td></tr></table></figure><h2 id="Ambari"><a href="#Ambari" class="headerlink" title="Ambari"></a>Ambari</h2><ul><li><a href="http://ambari.apache.org/1.2.2/installing-hadoop-using-ambari/content/index.html" target="_blank" rel="noopener">Ambari User Guide</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-bigdata-ambari/index.html" target="_blank" rel="noopener">Ambari——大数据平台的搭建利器</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-bigdata-ambari2/" target="_blank" rel="noopener">Ambari——大数据平台的搭建利器之进阶篇</a></li></ul><p>和Hive进行交互的方式主要有2种：命令行和Ambari视图。</p><p>就 Ambari 的作用来说，就是创建、管理、监视 Hadoop 的集群，但是这里的 Hadoop 是广义，指的是 Hadoop 整个生态圈（例如 Hive，Hbase，Sqoop，Zookeeper 等），而并不仅是特指 Hadoop。用一句话来说，Ambari 就是为了让 Hadoop 以及相关的大数据软件更容易使用的一个工具。</p><p>Ambari 自身也是一个分布式架构的软件，主要由两部分组成：<code>Ambari Server</code> 和 <code>Ambari Agent</code>。简单来说，</p><ul><li>用户通过 Ambari Server 通知 Ambari Agent 安装对应的软件</li><li>Agent 会定时地发送各个机器每个软件模块的状态给 Ambari Server</li><li>最终这些状态信息会呈现在 Ambari 的 GUI，方便用户了解到集群的各种状态，并进行相应的维护</li></ul><h2 id="Hive实战Demo"><a href="#Hive实战Demo" class="headerlink" title="Hive实战Demo"></a>Hive实战Demo</h2><ul><li><a href="http://blog.fens.me/hadoop-hive-10g/" target="_blank" rel="noopener">Hive导入10G数据的测试 | 粉丝日志</a></li><li><a href="http://blog.fens.me/finance-rhive-repurchase/" target="_blank" rel="noopener">用RHive从历史数据中提取逆回购信息 | 粉丝日志</a></li></ul><h2 id="Hive架构"><a href="#Hive架构" class="headerlink" title="Hive架构"></a>Hive架构</h2><p>尽管Hive使用起来类似SQL，但它仍然不是SQL，尤其体现在处理速度方面。底层的Hive查询仍然是以 MapReduce 作业的形式运行。MapReduce是批处理，而SQL则是一种交互式处理语音。</p><h3 id="HCatalog"><a href="#HCatalog" class="headerlink" title="HCatalog"></a>HCatalog</h3><p>HCatalog 提供了一个统一的元数据服务，允许不同的工具如 Pig、MapReduce 等通过 HCatalog 直接访问存储在 HDFS 上的底层文件。</p><p>HCatalog 本质上是数据访问工具（如Hive或Pig）和底层文件之间的抽象层。</p><h2 id="Hive-数据类型"><a href="#Hive-数据类型" class="headerlink" title="Hive 数据类型"></a>Hive 数据类型</h2><ul><li><a href="https://cwiki.apache.org/confluence/display/Hive#Home-UserDocumentation" target="_blank" rel="noopener">User Documentation - Apache Hive</a></li></ul><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>tinyint/smallint/int/bigint：整数类型</li><li>float/double：浮点数类型</li><li>boolean：布尔类型</li><li>string：字符串类型</li></ul><p><code>string</code> 类型下又包括 变长字符串 <code>VARCHAR</code> 和 定长字符串 <code>CHAR</code>。下面给出例子，说明两者区别</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive &gt; <span class="keyword">create</span> <span class="keyword">table</span> test1</span><br><span class="line">     &gt; (vname <span class="type">varchar</span>(<span class="number">20</span>), cname <span class="type">char</span>(<span class="number">20</span>));</span><br><span class="line">     &gt; <span class="keyword">desc</span> test1;</span><br><span class="line">     </span><br><span class="line">vname   <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">cname   <span class="type">char</span>(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>上述例子中，<code>varchar(20)</code> 表示最大长度为20，实际长度可能不足20。<code>char(20)</code> 表示长度固定为20。</p><h3 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h3><ul><li>Array：数组，由一系列相同数据类型的元素组成</li><li>Map：集合，包含 <code>key-&gt;value</code> 键值对，可以通过 <code>key</code> 来访问元素</li><li>Struct：结构类型，可以包含不同数据类型的元素，这些元素可以通过 “点语法” 的方式访问</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; create table student</span><br><span class="line">    &gt; (sid <span class="built_in">int</span>,</span><br><span class="line">    &gt; sname <span class="built_in">string</span>,</span><br><span class="line">    &gt; grade1 <span class="built_in">array<span class="keyword">&lt;<span class="built_in">float</span>&gt;</span></span>,</span><br><span class="line">    &gt; grade2 map&lt;<span class="built_in">string</span>,<span class="built_in">float</span>&gt;</span><br><span class="line">    &gt; info struct&lt;name:<span class="built_in">string</span>, age:<span class="built_in">int</span>&gt;);</span><br><span class="line">OK</span><br><span class="line">Time taken: <span class="number">0.246</span> seconds</span><br><span class="line"></span><br><span class="line">hive&gt; desc student;</span><br><span class="line">OK</span><br><span class="line">sid                 <span class="built_in">int</span></span><br><span class="line">sname               <span class="built_in">string</span></span><br><span class="line">grade1               <span class="built_in">array<span class="keyword">&lt;<span class="built_in">float</span>&gt;</span></span></span><br><span class="line">grade2                  map&lt;<span class="built_in">string</span>,<span class="built_in">float</span>&gt;</span><br><span class="line">info                    struct&lt;name:<span class="built_in">string</span>, age:<span class="built_in">int</span>&gt;</span><br><span class="line">Time taken: <span class="number">0.077</span> seconds, Fetched: <span class="number">5</span> row(s)</span><br></pre></td></tr></table></figure><h3 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h3><ul><li>Date：从 Hive 0.12.0 开始支持</li><li>Timestamp：从 Hive 0.8.0 开始支持</li></ul><h2 id="Hive-文件格式"><a href="#Hive-文件格式" class="headerlink" title="Hive 文件格式"></a>Hive 文件格式</h2><p>Hive 支持4种文件格式</p><ol><li><code>TextFile</code> （默认格式）：基于行列混合的思想</li><li><code>SequenceFile</code> ：基于行存储</li><li><code>RCFile</code> ：基于行存储</li><li>自定义</li></ol><p>基于 HDFS 的行存储具备快速数据加载和动态负载的高适应能力，因为行存储保证了相同记录的所有域都在同一个集群节点。但是它不能满足快速的查询响应时间的要求，因为当查询仅仅针对所有列中的少数几列时，他就不能跳过不需要的列，直接定位到所需的列。此外，行存储也不易获得一个较高的压缩比。</p><h3 id="TextFile"><a href="#TextFile" class="headerlink" title="TextFile"></a>TextFile</h3><p>TextFile 是默认格式，数据不做压缩，磁盘开销大，数据解析开销大。可结合 Gzip，Bzip2使用。但使用这方式，Hive 不会对数据进行切分，从而无法对数据进行并行操作。</p><h3 id="SequenceFile"><a href="#SequenceFile" class="headerlink" title="SequenceFile"></a>SequenceFile</h3><p>SequenceFile 是Hadoop API 提供的一种二进制文件支持，其具有使用方便，可分割，可压缩的特点。 SequenceFile 支持三种压缩选择：<code>NONE</code>, <code>RECORD</code>, <code>BLOCK</code>。<code>RECORD</code> 压缩率较低，一般建议使用 <code>BLOCK</code> 压缩。</p><h3 id="RCFile"><a href="#RCFile" class="headerlink" title="RCFile"></a>RCFile</h3><p>RCFile 是 Facebook 开发的一个集行存储和列存储的优点于一身，压缩比更高，读取列更快。</p><p>RCFile 存储结构遵循“先水平划分，再垂直划分”的设计理念。RCFile保证同一行的数据位于同一节点，因此元组重构的开销很低。其次，像列存储一样，RCFile 能够利用列维度的数据压缩，并且能跳过不必要的列读取。</p><blockquote><p>在 RC File 的基础上，进一步改进，引入了 ORC （<code>Optimized Record Columnar</code>），ORC 主要在压缩编码、查询性能上进行了升级。</p></blockquote><h3 id="自定义文件格式"><a href="#自定义文件格式" class="headerlink" title="自定义文件格式"></a>自定义文件格式</h3><p>当用户的数据文件格式不能被当前Hive识别的时候，可以自定义文件格式，通过实现 <code>InputFormat</code> 和 <code>OutputFormat</code> 自定义输入/输出格式。</p><h2 id="Hive的数据存储"><a href="#Hive的数据存储" class="headerlink" title="Hive的数据存储"></a>Hive的数据存储</h2><p>Hive 的存储是建立在 Hadoop 文件系统之上的。Hive 本身没有专门的数据存储格式，也不能为数据建立索引，因此用户可以非常自由地组织 Hive 中的表，只需要在创建表的时候告诉 Hive 数据中的列分隔符就可以解析数据了。</p><p>例如，打开 <code>http://localhost:50070/</code>，选择顶部分类栏中的 <code>Utilities -&gt; Browse the file system</code>，可以查看到 Hive 中创建的数据库表对应的文件（存储在 <code>/user/hive/warehouse</code> 路径下）。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/BigData2020/hadoop-hive-hdfs-1.png" alt=""></p><h3 id="Hive的数据模型"><a href="#Hive的数据模型" class="headerlink" title="Hive的数据模型"></a>Hive的数据模型</h3><p>Hive 中主要包括 4 种数据模型</p><ol><li>表（Table）</li><li>外部表（External Table）</li><li>分区（Partition）</li><li>桶（Bucket）</li></ol><p>Hive 的表和数据库中的表在概念上没有什么本质区别，在 Hive 中每个表都有一个对应的存储目录。而外部表指向已经在 HDFS 中存在的数据，也可以创建分区。</p><p>Hive 中的每个分区都对应数据库中相应分区列的一个索引，但是其对分区的组织方式和传统关系数据库不同。</p><p>桶在指定列进行 Hash 计算时，会根据哈希值切分数据，使每个桶对应一个文件。</p><h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><p>表可以细分为</p><ol><li>Table 内部表</li><li>Partition 分区表</li><li>External Table 外部表</li><li>Bucket Table 桶表</li></ol><h4 id="视图-View"><a href="#视图-View" class="headerlink" title="视图 View"></a>视图 View</h4><ul><li>视图是一种虚表，是一个逻辑概念，Hive 暂不支持物化视图</li><li>视图可以跨越多张表</li><li>视图建立在已有表的基础上，视图赖以建立的这些表称为基表</li><li>视图可以简化复杂的查询</li><li>视图 VIEW 是只读的，不支持 <code>LOAD/INSERT/ALTER</code>。可以使用 <code>ALTER VIEW</code> 改变 VIEW 定义</li><li>Hive 支持迭代视图</li></ul><h2 id="Hive-数据操作"><a href="#Hive-数据操作" class="headerlink" title="Hive 数据操作"></a>Hive 数据操作</h2><blockquote><p>在执行操作前，请确保 <code>localhost:50070</code> 页面访问到的 <code>Live Node</code> 个数大于0。</p></blockquote><h3 id="向表中装载数据"><a href="#向表中装载数据" class="headerlink" title="向表中装载数据"></a>向表中装载数据</h3><ul><li><a href="https://blog.csdn.net/jclian91/article/details/78481673" target="_blank" rel="noopener">Hive之导入外部数据 | CSDN</a></li><li><a href="http://www.tracefact.net/tech/067.html" target="_blank" rel="noopener">Hive 写入数据到Hive表(命令行)</a></li></ul><h4 id="Demo-Insert插入数据"><a href="#Demo-Insert插入数据" class="headerlink" title="Demo-Insert插入数据"></a>Demo-Insert插入数据</h4><ol><li>创建 <code>hiveDemo</code> 数据库并使用该数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> datbase <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> hiveDemo;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"><span class="keyword">use</span> hiveDemo;</span><br></pre></td></tr></table></figure><ol start="2"><li>建表/查看/删除 数据表</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; Create Table golds<span class="constructor">_log(<span class="params">user_id</span> <span class="params">bigint</span>, <span class="params">accounts</span> <span class="params">string</span>, <span class="params">change_type</span> <span class="params">string</span>, <span class="params">golds</span> <span class="params">bigint</span>, <span class="params">log_time</span> <span class="params">int</span>)</span>;</span><br><span class="line"></span><br><span class="line">hive&gt; show tables;</span><br><span class="line"></span><br><span class="line">hive&gt; drop table golds_log;</span><br><span class="line"></span><br><span class="line">hive&gt; desc golds_log;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 <code>Insert...Values</code> 语句写入数据</li></ol><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; Insert into table golds_log values</span><br><span class="line">(<span class="number">3645356</span>,'wds<span class="number">765432</span>1(<span class="number">417175</span>2)','新人注册奖励',<span class="number">1700</span>,<span class="number">1526027152</span>),</span><br><span class="line">(<span class="number">2016869</span>,'dqyx<span class="number">12345678</span>9(<span class="number">237669</span>9)','参加一场比赛',<span class="number">1140</span>,<span class="number">1526027152</span>),</span><br><span class="line">(<span class="number">3630468</span>,'dke<span class="number">377661</span>1(<span class="number">415606</span>4)','大转盘奖励',<span class="number">1200</span>,<span class="number">1526027152</span>),</span><br><span class="line">(<span class="number">995267</span>,'a<span class="number">25441318</span>9(<span class="number">122941</span>7)','妞妞拼十翻牌',<span class="number">200</span>,<span class="number">1526027152</span>),</span><br><span class="line">(<span class="number">795276</span>,'li<span class="number">876286</span>6(<span class="number">971402</span>)','妞妞拼十翻牌',<span class="number">1200</span>,<span class="number">1526027152</span>);</span><br></pre></td></tr></table></figure><p>正常情况下可以看到下面的结果输出，说明在执行 <code>Insert...values</code> 语句时，底层是在执行 MapReduce 作业。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Query ID = lbs_20200422053833_55b98d5a-ba4c<span class="number">-470</span>d<span class="number">-909</span>a<span class="number">-098213</span>d1d937</span><br><span class="line">Total jobs = <span class="number">3</span></span><br><span class="line">Launching Job <span class="number">1</span> <span class="keyword">out</span> of <span class="number">3</span></span><br><span class="line">Number of reduce tasks determined at compile time: <span class="number">1</span></span><br><span class="line">In order to change the average load <span class="keyword">for</span> a reducer (<span class="keyword">in</span> bytes):</span><br><span class="line">  <span class="keyword">set</span> hive.exec.reducers.bytes.per.reducer=&lt;number&gt;</span><br><span class="line">In order to limit the maximum number of reducers:</span><br><span class="line">  <span class="keyword">set</span> hive.exec.reducers.max=&lt;number&gt;</span><br><span class="line">In order to <span class="keyword">set</span> a constant number of reducers:</span><br><span class="line">  <span class="keyword">set</span> mapreduce.job.reduces=&lt;number&gt;</span><br><span class="line">Starting Job = job_1587504428431_0001, Tracking URL = http:<span class="comment">//localhost:8088/proxy/application_1587504428431_0001/</span></span><br><span class="line">Kill Command = /Library/hadoop<span class="number">-2.10</span><span class="number">.0</span>/bin/mapred job  -kill job_1587504428431_0001</span><br><span class="line">Hadoop job information <span class="keyword">for</span> Stage<span class="number">-1</span>: number of mappers: <span class="number">1</span>; number of reducers: <span class="number">1</span></span><br><span class="line"><span class="number">2020</span><span class="number">-04</span><span class="number">-22</span> <span class="number">05</span>:<span class="number">39</span>:<span class="number">14</span>,<span class="number">966</span> Stage<span class="number">-1</span> map = <span class="number">0</span>%,  reduce = <span class="number">0</span>%</span><br><span class="line"><span class="number">2020</span><span class="number">-04</span><span class="number">-22</span> <span class="number">05</span>:<span class="number">39</span>:<span class="number">21</span>,<span class="number">154</span> Stage<span class="number">-1</span> map = <span class="number">100</span>%,  reduce = <span class="number">0</span>%</span><br><span class="line"><span class="number">2020</span><span class="number">-04</span><span class="number">-22</span> <span class="number">05</span>:<span class="number">39</span>:<span class="number">27</span>,<span class="number">296</span> Stage<span class="number">-1</span> map = <span class="number">100</span>%,  reduce = <span class="number">100</span>%</span><br><span class="line">Ended Job = job_1587504428431_0001</span><br><span class="line">Stage<span class="number">-4</span> <span class="keyword">is</span> selected by condition resolver.</span><br><span class="line">Stage<span class="number">-3</span> <span class="keyword">is</span> filtered <span class="keyword">out</span> by condition resolver.</span><br><span class="line">Stage<span class="number">-5</span> <span class="keyword">is</span> filtered <span class="keyword">out</span> by condition resolver.</span><br><span class="line">Moving data to directory hdfs:<span class="comment">//localhost:9000/user/hive/warehouse/hivedemo.db/golds_log/.hive-staging_hive_2020-04-22_05-38-33_916_330193107719508203-1/-ext-10000</span></span><br><span class="line">Loading data to table hivedemo.golds_log</span><br><span class="line">MapReduce Jobs Launched: </span><br><span class="line">Stage-Stage<span class="number">-1</span>: Map: <span class="number">1</span>  Reduce: <span class="number">1</span>   HDFS Read: <span class="number">20647</span> HDFS Write: <span class="number">764</span> SUCCESS</span><br><span class="line">Total MapReduce CPU Time Spent: <span class="number">0</span> msec</span><br><span class="line">OK</span><br><span class="line">Time taken: <span class="number">54.82</span> seconds</span><br></pre></td></tr></table></figure><p>此时在 <code>http://localhost:50070/</code> 页面查看 <code>Utillities -&gt; Browser the file system</code>，在 <code>/user/hive/warehouse/hivedemo.db/golds_log</code> 路径下可以看到一个 <code>000000_0</code> 的文件，下载到本地，查看其内容为</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/BigData2020/hadoop-namenode-manage-web-1.png" alt=""></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3645356 </span>wds7654321(<span class="number">4171752</span>) 新人注册奖励 <span class="number">1700</span> <span class="number">1526027152</span></span><br><span class="line"><span class="symbol">2016869 </span>dqyx123456789(<span class="number">2376699</span>) 参加一场比赛 <span class="number">1140</span> <span class="number">1526027152</span></span><br><span class="line"><span class="symbol">3630468 </span>dke3776611(<span class="number">4156064</span>) 大转盘奖励 <span class="number">1200</span> <span class="number">1526027152</span></span><br><span class="line"><span class="symbol">995267 </span>a254413189(<span class="number">1229417</span>) 妞妞拼十翻牌 <span class="number">200</span> <span class="number">1526027152</span></span><br><span class="line"><span class="symbol">795276 </span>li8762866(<span class="number">971402</span>) 妞妞拼十翻牌 <span class="number">1200</span> <span class="number">1526027152</span></span><br></pre></td></tr></table></figure><blockquote><p><code>000000_0</code> 文件是一个普通的文本文件（Hive中默认的文件存储格式），可以用 VSCode 打开。</p></blockquote><ol start="4"><li>继续执行2次 <code>Insert...values</code> 命令，再次访问 <code>http://localhost:50070/explorer.html#/user/hive/warehouse/hivedemo.db/golds_log</code> 页面，可以发现有3个文件，即<strong>每次任务都生成了单独的数据文件。</strong></li></ol><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/BigData2020/hadoop-namenode-manage-web-2.png" alt=""></p><p><strong>Hive中，每次执行 <code>Insert</code> 语句（底层执行 MapReduce 任务）都会生成独立的数据文件。对于 HDFS 来说，优势是存储少量大文件，不是存储大量小文件。</strong></p><p>而对于我们的应用而言，每 10 分钟就会同步一次数据到 Hive 仓库，如此一来会生成无数的小文件，系统的运行速度会越来越慢。所以第一个问题就是：如何合并小文件？</p><h4 id="Demo-合并数据库小文件"><a href="#Demo-合并数据库小文件" class="headerlink" title="Demo-合并数据库小文件"></a>Demo-合并数据库小文件</h4><p>在建表的时候，我们没有指定表存储的文件类型（<code>file format</code>），默认的文件类型是 <code>Textfile</code>，所以，当我们下载生成的 <code>000000_0</code> 文件后，使用编辑器可以直接查看其内容。</p><p>Hive 提供了一个 <code>ALTER TABLE table_name CONCATENATE</code> 语句，用于合并小文件。但是只支持 <code>RCFILE</code> 和 <code>ORC</code>文件类型。</p><p>因此，如果想合并小文件，可以删除表，然后再使用下面的命令重建</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; drop <span class="keyword">table</span> golds_log;</span><br></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; Create Table golds<span class="constructor">_log(<span class="params">user_id</span> <span class="params">bigint</span>, <span class="params">accounts</span> <span class="params">string</span>, <span class="params">change_type</span> <span class="params">string</span>, <span class="params">golds</span> <span class="params">bigint</span>, <span class="params">log_time</span> <span class="params">int</span>)</span></span><br><span class="line">STORED AS RCFile;</span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; Insert into table golds_log values</span><br><span class="line">(<span class="number">3645356</span>,'wds<span class="number">765432</span>1(<span class="number">417175</span>2)','新人注册奖励',<span class="number">1700</span>,<span class="number">1526027152</span>),</span><br><span class="line">(<span class="number">2016869</span>,'dqyx<span class="number">12345678</span>9(<span class="number">237669</span>9)','参加一场比赛',<span class="number">1140</span>,<span class="number">1526027152</span>),</span><br><span class="line">(<span class="number">3630468</span>,'dke<span class="number">377661</span>1(<span class="number">415606</span>4)','大转盘奖励',<span class="number">1200</span>,<span class="number">1526027152</span>),</span><br><span class="line">(<span class="number">995267</span>,'a<span class="number">25441318</span>9(<span class="number">122941</span>7)','妞妞拼十翻牌',<span class="number">200</span>,<span class="number">1526027152</span>),</span><br><span class="line">(<span class="number">795276</span>,'li<span class="number">876286</span>6(<span class="number">971402</span>)','妞妞拼十翻牌',<span class="number">1200</span>,<span class="number">1526027152</span>);</span><br></pre></td></tr></table></figure><p>重复上面的过程，执行 3 次 <code>insert</code> 语句，每次插入 5 条数据。刷新 WebUI，会看到和前面一样产生 3 个文件。</p><blockquote><p>Tip: 如果此时再将 <code>000000_0</code> 文件下载下来，用文本编辑器或者 VSCode 打开查看，发现已经是乱码了。因为它已经不再是文本文件了。</p></blockquote><p>接下来，执行下面的语句，对文件进行合并</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; alter <span class="keyword">table</span> golds_log <span class="comment">concatenate</span>;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Starting Job = job_1587504428431_0006, Tracking URL = http:<span class="comment">//localhost:8088/proxy/application_1587504428431_0006/</span></span><br><span class="line">Kill Command = /Library/hadoop<span class="number">-2.10</span><span class="number">.0</span>/bin/mapred job  -kill job_1587504428431_0006</span><br><span class="line">Hadoop job information <span class="keyword">for</span> <span class="literal">null</span>: number of mappers: <span class="number">1</span>; number of reducers: <span class="number">0</span></span><br><span class="line"><span class="number">2020</span><span class="number">-04</span><span class="number">-22</span> <span class="number">06</span>:<span class="number">10</span>:<span class="number">40</span>,<span class="number">875</span> <span class="literal">null</span> map = <span class="number">0</span>%,  reduce = <span class="number">0</span>%</span><br><span class="line"><span class="number">2020</span><span class="number">-04</span><span class="number">-22</span> <span class="number">06</span>:<span class="number">10</span>:<span class="number">47</span>,<span class="number">012</span> <span class="literal">null</span> map = <span class="number">100</span>%,  reduce = <span class="number">0</span>%</span><br><span class="line">Ended Job = job_1587504428431_0006</span><br><span class="line">Loading data to table hivedemo.golds_log</span><br><span class="line">MapReduce Jobs Launched: </span><br><span class="line">Stage-<span class="literal">null</span>: Map: <span class="number">1</span>   HDFS Read: <span class="number">3137</span> HDFS Write: <span class="number">632</span> SUCCESS</span><br><span class="line">Total MapReduce CPU Time Spent: <span class="number">0</span> msec</span><br><span class="line">OK</span><br><span class="line">Time taken: <span class="number">43.978</span> seconds</span><br></pre></td></tr></table></figure><p>刷新WebUI，会发现文件已经合并了，只有一个文件存在。</p><p>最后，使用 <code>SELECT</code> 语句查看数据表的内容。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; select * <span class="keyword">from</span>  golds_log;</span><br><span class="line"></span><br><span class="line">OK</span><br><span class="line"><span class="number">3645356</span>wds7654321(<span class="number">4171752</span>)新人注册奖励<span class="number">1700</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">2016869</span>dqyx123456789(<span class="number">2376699</span>)参加一场比赛<span class="number">1140</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">3630468</span>dke3776611(<span class="number">4156064</span>)大转盘奖励<span class="number">1200</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">995267</span>a254413189(<span class="number">1229417</span>)妞妞拼十翻牌<span class="number">200</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">795276</span>li8762866(<span class="number">971402</span>)妞妞拼十翻牌<span class="number">1200</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">3645356</span>wds7654321(<span class="number">4171752</span>)新人注册奖励<span class="number">1700</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">2016869</span>dqyx123456789(<span class="number">2376699</span>)参加一场比赛<span class="number">1140</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">3630468</span>dke3776611(<span class="number">4156064</span>)大转盘奖励<span class="number">1200</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">995267</span>a254413189(<span class="number">1229417</span>)妞妞拼十翻牌<span class="number">200</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">795276</span>li8762866(<span class="number">971402</span>)妞妞拼十翻牌<span class="number">1200</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">3645356</span>wds7654321(<span class="number">4171752</span>)新人注册奖励<span class="number">1700</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">2016869</span>dqyx123456789(<span class="number">2376699</span>)参加一场比赛<span class="number">1140</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">3630468</span>dke3776611(<span class="number">4156064</span>)大转盘奖励<span class="number">1200</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">995267</span>a254413189(<span class="number">1229417</span>)妞妞拼十翻牌<span class="number">200</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">795276</span>li8762866(<span class="number">971402</span>)妞妞拼十翻牌<span class="number">1200</span><span class="number">1526027152</span></span><br><span class="line">Time taken: <span class="number">0.133</span> seconds, Fetched: <span class="number">15</span> row(s)</span><br></pre></td></tr></table></figure><h4 id="Demo-Load-导入外部数据"><a href="#Demo-Load-导入外部数据" class="headerlink" title="Demo-Load 导入外部数据"></a>Demo-Load 导入外部数据</h4><p>下面给出一个实例，如何将本地数据文件 <code>test.txt</code> 导入到 Hive 数据表中。</p><ol><li>本地数据文件 <code>test.txt</code> 内容如下</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3645356</span>|wds7654321(<span class="number">4171752</span>)|新人注册奖励|<span class="number">1700</span>|<span class="number">1526027152</span></span><br><span class="line"><span class="number">2016869</span>|dqyx123456789(<span class="number">2376699</span>)|参加一场比赛|<span class="number">1140</span>|<span class="number">1526027152</span></span><br><span class="line"><span class="number">3630468</span>|dke3776611(<span class="number">4156064</span>)|大转盘奖励|<span class="number">1200</span>|<span class="number">1526027152</span></span><br><span class="line"><span class="number">3642022</span>|黑娃<span class="number">123456</span>(<span class="number">4168266</span>)|新人注册奖励|<span class="number">500</span>|<span class="number">1526027152</span></span><br><span class="line"><span class="number">2016869</span>|dqyx123456789(<span class="number">2376699</span>)|大转盘奖励|<span class="number">1500</span>|<span class="number">1526027152</span></span><br></pre></td></tr></table></figure><ol start="2"><li>创建数据表，与本地 <code>test.txt</code> 的数据类型一致</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; Create Table golds<span class="constructor">_log(<span class="params">user_id</span> <span class="params">bigint</span>, <span class="params">accounts</span> <span class="params">string</span>, <span class="params">change_type</span> <span class="params">string</span>, <span class="params">golds</span> <span class="params">bigint</span>, <span class="params">log_time</span> <span class="params">int</span>)</span></span><br><span class="line">ROW FORMAT DELIMITED FIELDS TERMINATED BY <span class="character">'|'</span>;</span><br></pre></td></tr></table></figure><p>上面最重要的一句就是 <code>ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;|&#39;</code>，说明表的字段由符号 <code>&quot;|&quot;</code> 进行分隔。</p><blockquote><p>Tip: <code>test.txt</code> 中包含有中文，确保文件格式是 <code>utf-8</code>（<code>GB2312</code> 导入后会有乱码）</p></blockquote><ol start="3"><li>查看数据表的结构</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">describe</span> golds_log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">describe</span> formatted student1;</span><br></pre></td></tr></table></figure><ol start="4"><li>查看数据表内容（此时为空）</li></ol><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student1;</span><br></pre></td></tr></table></figure><ol start="5"><li>导入本地数据</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; <span class="keyword">load</span> data <span class="keyword">local</span> inpath <span class="string">'/Users/lbs/Downloads/test.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> golds_log;</span><br><span class="line"></span><br><span class="line">Loading data <span class="keyword">to</span> <span class="keyword">table</span> hivedemo.golds_log</span><br><span class="line">OK</span><br><span class="line"><span class="type">Time</span> taken: <span class="number">0.139</span> seconds</span><br></pre></td></tr></table></figure><p>你会发现使用 <code>load</code> 语句写入数据比 <code>insert</code> 语句要快许多倍，因为 HIVE 并不对 <code>scheme</code> 进行校验，仅仅是将数据文件挪到 HDFS 系统上，也没有执行 MapReduce 作业。所以从导入数据的角度而言，使用 load 要优于使用 insert…values。</p><ol start="6"><li>再次数据表内容</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; select * <span class="keyword">from</span> golds_log;</span><br><span class="line">OK</span><br><span class="line"><span class="number">3645356</span>wds7654321(<span class="number">4171752</span>)新人注册奖励<span class="number">1700</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">2016869</span>dqyx123456789(<span class="number">2376699</span>)参加一场比赛<span class="number">1140</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">3630468</span>dke3776611(<span class="number">4156064</span>)大转盘奖励<span class="number">1200</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">3642022</span>黑娃<span class="number">123456</span>(<span class="number">4168266</span>)新人注册奖励<span class="number">500</span><span class="number">1526027152</span></span><br><span class="line"><span class="number">2016869</span>dqyx123456789(<span class="number">2376699</span>)大转盘奖励<span class="number">1500</span><span class="number">1526027152</span></span><br><span class="line">Time taken: <span class="number">0.087</span> seconds, Fetched: <span class="number">5</span> row(s)</span><br></pre></td></tr></table></figure><ol start="7"><li>反复导入 3 次后，打开 Web UI，刷新后，发现和使用 Insert 语句时一样，每次 load 语句都会生成一个数据文件，同样存在小文件的问题。</li></ol><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/BigData2020/hadoop-namenode-manage-web-3.png" alt=""></p><p>和前面的方法一样，我们可以将表的存储类型改为 RCFile，然后再进行合并，但是因为使用 load 语句的时候，要导入的文件类型是 txt，和表的存储类型不一致，所以会报错。</p><p>这时候，只能曲线救国了：将主表创建为 RCFile 类型，再创建一张临时表，类型是 Textfile，然后 load 时导入到临时表，然后再使用下一节要介绍的 <code>Insert...select</code> 语句，将数据从临时表导入到主表。</p><h4 id="Demo-使用-Insert…Select-语句写入数据"><a href="#Demo-使用-Insert…Select-语句写入数据" class="headerlink" title="Demo-使用 Insert…Select 语句写入数据"></a>Demo-使用 Insert…Select 语句写入数据</h4><ol><li>使用下面的语句创建一张临时表，临时表的名称为 <code>golds_log_tmp</code>。临时表在当前会话(<code>session</code>)结束后会被 HIVE 自动删除，临时表可以保存在SSD、内存或者是文件系统上。</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; Create TEMPORARY Table golds<span class="constructor">_log_tmp(<span class="params">user_id</span> <span class="params">bigint</span>, <span class="params">accounts</span> <span class="params">string</span>, <span class="params">change_type</span> <span class="params">string</span>, <span class="params">golds</span> <span class="params">bigint</span>, <span class="params">log_time</span> <span class="params">int</span>)</span></span><br><span class="line">ROW FORMAT DELIMITED  FIELDS TERMINATED BY <span class="character">'|'</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用下面的语句创建主表</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; drop <span class="keyword">table</span> golds_log;</span><br></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; Create Table golds<span class="constructor">_log(<span class="params">user_id</span> <span class="params">bigint</span>, <span class="params">accounts</span> <span class="params">string</span>, <span class="params">change_type</span> <span class="params">string</span>, <span class="params">golds</span> <span class="params">bigint</span>, <span class="params">log_time</span> <span class="params">int</span>)</span></span><br><span class="line">STORED AS RCFile;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用下面的语句将数据导入到临时表</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; <span class="keyword">load</span> data <span class="keyword">local</span> inpath <span class="string">'/Users/lbs/Downloads/test.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> golds_log_tmp;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用insert…select语句将数据从临时表转移到主表</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; Insert <span class="built_in">int</span>o table golds_log select * <span class="keyword">from</span> golds_log_tmp;</span><br><span class="line"></span><br><span class="line">Query ID = lbs_20200422063734_475e168a<span class="number">-5016</span><span class="number">-4</span>ba7-a67f<span class="number">-9</span>c7f76373f98</span><br><span class="line">Total jobs = <span class="number">1</span></span><br><span class="line">Launching Job <span class="number">1</span> <span class="keyword">out</span> of <span class="number">1</span></span><br><span class="line">Number of reduce tasks determined at compile time: <span class="number">1</span></span><br><span class="line">In order to change the average load <span class="keyword">for</span> a reducer (<span class="keyword">in</span> bytes):</span><br><span class="line">  <span class="keyword">set</span> hive.exec.reducers.bytes.per.reducer=&lt;number&gt;</span><br><span class="line">In order to limit the maximum number of reducers:</span><br><span class="line">  <span class="keyword">set</span> hive.exec.reducers.max=&lt;number&gt;</span><br><span class="line">In order to <span class="keyword">set</span> a constant number of reducers:</span><br><span class="line">  <span class="keyword">set</span> mapreduce.job.reduces=&lt;number&gt;</span><br><span class="line">Starting Job = job_1587504428431_0007, Tracking URL = http:<span class="comment">//localhost:8088/proxy/application_1587504428431_0007/</span></span><br><span class="line">Kill Command = /Library/hadoop<span class="number">-2.10</span><span class="number">.0</span>/bin/mapred job  -kill job_1587504428431_0007</span><br><span class="line">Hadoop job information <span class="keyword">for</span> Stage<span class="number">-1</span>: number of mappers: <span class="number">1</span>; number of reducers: <span class="number">1</span></span><br><span class="line"><span class="number">2020</span><span class="number">-04</span><span class="number">-22</span> <span class="number">06</span>:<span class="number">38</span>:<span class="number">10</span>,<span class="number">330</span> Stage<span class="number">-1</span> map = <span class="number">0</span>%,  reduce = <span class="number">0</span>%</span><br><span class="line"><span class="number">2020</span><span class="number">-04</span><span class="number">-22</span> <span class="number">06</span>:<span class="number">38</span>:<span class="number">16</span>,<span class="number">479</span> Stage<span class="number">-1</span> map = <span class="number">100</span>%,  reduce = <span class="number">0</span>%</span><br><span class="line"><span class="number">2020</span><span class="number">-04</span><span class="number">-22</span> <span class="number">06</span>:<span class="number">38</span>:<span class="number">21</span>,<span class="number">572</span> Stage<span class="number">-1</span> map = <span class="number">100</span>%,  reduce = <span class="number">100</span>%</span><br><span class="line">Ended Job = job_1587504428431_0007</span><br><span class="line">Stage<span class="number">-4</span> <span class="keyword">is</span> selected by condition resolver.</span><br><span class="line">Stage<span class="number">-3</span> <span class="keyword">is</span> filtered <span class="keyword">out</span> by condition resolver.</span><br><span class="line">Stage<span class="number">-5</span> <span class="keyword">is</span> filtered <span class="keyword">out</span> by condition resolver.</span><br><span class="line">Moving data to directory hdfs:<span class="comment">//localhost:9000/user/hive/warehouse/hivedemo.db/golds_log/.hive-staging_hive_2020-04-22_06-37-34_112_939503175258871139-1/-ext-10000</span></span><br><span class="line">Loading data to table hivedemo.golds_log</span><br><span class="line">MapReduce Jobs Launched: </span><br><span class="line">Stage-Stage<span class="number">-1</span>: Map: <span class="number">1</span>  Reduce: <span class="number">1</span>   HDFS Read: <span class="number">18494</span> HDFS Write: <span class="number">794</span> SUCCESS</span><br><span class="line">Total MapReduce CPU Time Spent: <span class="number">0</span> msec</span><br><span class="line">OK</span><br><span class="line">Time taken: <span class="number">48.647</span> seconds</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>insert...select</code> 语句底层也会执行一个 MapReduce 作业，速度会比较慢。</p><ol start="5"><li>在多次执行 <code>insert...select</code> 后，<code>golds_log</code> 下仍然会生成多个小文件，此时，只要执行一下合并小文件的语句就可以了</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; alter <span class="keyword">table</span> golds_log <span class="comment">concatenate</span>;</span><br></pre></td></tr></table></figure><h2 id="Hive-数据查询"><a href="#Hive-数据查询" class="headerlink" title="Hive 数据查询"></a>Hive 数据查询</h2><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><p>Hive的数据表分为2种：内部表和外部表</p><ol><li>内部表：Hive创建并通过 LOAD DATA INPATH 进数据库的表，这种表可以理解为数据和表结构都保存在一起的数据表。当通过 <code>DROP TABLE table_name</code> 删除元数据中表结构的同时，表中的数据也同样会从 HDFS 中被删除。</li><li>外部表：在表结构创建以前，数据已经保存在HDFS中，通过创建表结构，将数据格式化到表的结构里。当通过 <code>DROP TABLE table_name</code> 操作的时候，Hive 仅仅删除元数据的表结构，而不删除HDFS上的文件。所以，相比内部表，外部表可以更放心地大胆使用。</li></ol><ul><li>创建表时，<code>LIKE</code> 允许用户复制现有的表结构，但不是复制数据</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">LIKE</span> existing_table_name</span><br></pre></td></tr></table></figure><ul><li>创建表时，使用 <code>EXTERNAL</code> 声明外部表</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> tablename <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> tablename</span><br></pre></td></tr></table></figure><ul><li>数据表在删除时候，内部表会连数据一起删除，而外部表只删除表结构，数据还是保留的。</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="built_in">table_name</span></span><br></pre></td></tr></table></figure><ul><li>在表查询时候，使用 <code>ALL</code> 和 <code>DISTINCT</code> 选项区分对重复记录的处理。默认是 <code>ALL</code>,表示查询所有记录，<code>DISTINCT</code> 表示去掉重复的记录。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age, grade <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ALL</span> age, grade <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> age, grade <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure><ul><li>Hive 不支持 <code>HAVING</code> 子句，可以将 HAVING 子句转化为一个子查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Hive 不支持 HAVING 子句</span><br><span class="line"><span class="keyword">SELECT</span>  col1 <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> col1 <span class="keyword">HAVING</span> <span class="keyword">SUM</span>(col2) &gt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//可以改为下述子查询格式  Hive支持下述命名</span><br><span class="line"><span class="keyword">SELECT</span>  col1 <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> col1, <span class="keyword">SUM</span>(col2) <span class="keyword">AS</span> col2 <span class="keyword">sum</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">GROUP</span> BU col1) table2 <span class="keyword">WHERE</span> table2.col2sum &gt; <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="视图操作"><a href="#视图操作" class="headerlink" title="视图操作"></a>视图操作</h3><p>视图 VIEW 是只读的，不支持 <code>LOAD/INSERT/ALTER</code>。可以使用 <code>ALTER VIEW</code> 改变 VIEW 定义</p><p>下面介绍下视图VIEW常见的操作语句</p><ul><li>创建 VIEW </li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">VIEW</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] view_name</span><br></pre></td></tr></table></figure><ul><li>删除 VIEW </li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] view_name</span><br></pre></td></tr></table></figure><h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><p>索引是标准的数据库技术。Hive 0.7 版本之后支持索引。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文为Hive入门篇，主要记录Hive安装配置，数据存储和表操作。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Hadoop" scheme="https://lbs0912.github.io/categories/Hadoop/"/>
    
    
      <category term="BigData" scheme="https://lbs0912.github.io/tags/BigData/"/>
    
      <category term="Hadoop" scheme="https://lbs0912.github.io/tags/Hadoop/"/>
    
      <category term="Hive" scheme="https://lbs0912.github.io/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop入门篇——伪分布模式安装 &amp; WordCount词频统计</title>
    <link href="https://lbs0912.github.io/2020/04/21/hadoop-basic-1/"/>
    <id>https://lbs0912.github.io/2020/04/21/hadoop-basic-1/</id>
    <published>2020-04-21T06:35:26.000Z</published>
    <updated>2020-04-21T17:13:23.954Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文主要记录Mac下如何进行Hadoop伪分布模式安装，并通过词频统计Demo程序(WordCount)理解MapReduce的原理。</li></ul><a id="more"></a><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><ul><li>2020/03/23，撰写</li><li>2020/03/28，添加《Hadoop 权威指南》阅读笔记</li><li>2020/03/29，添加《Hadoop 应用开发技术详解》阅读笔记</li><li>2020/04/21，添加 Hadoop 伪分布式配置</li></ul><h2 id="学习资料汇总"><a href="#学习资料汇总" class="headerlink" title="学习资料汇总"></a>学习资料汇总</h2><ul><li><a href="https://hadoop.apache.org/" target="_blank" rel="noopener">Hadoop官网</a></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.zhihu.com/question/19795366" target="_blank" rel="noopener">零基础学习 Hadoop 该如何下手？ | 知乎</a></li><li><a href="http://blog.fens.me/hadoop-family-roadmap/" target="_blank" rel="noopener">Hadoop家族学习路线图 | Blog</a></li><li><a href="https://fuhailin.github.io/Hadoop-on-MacOS/" target="_blank" rel="noopener">在Mac上配置Hadoop娱乐环境 | Blog</a></li></ul><h3 id="《Hadoop权威指南》随书资料"><a href="#《Hadoop权威指南》随书资料" class="headerlink" title="《Hadoop权威指南》随书资料"></a>《Hadoop权威指南》随书资料</h3><ul><li>随书源码：<a href="http://www.hadoopbook.com/code.html" target="_blank" rel="noopener">Source Code</a></li><li>随书数据集：<a href="http://www.hadoopbook.com/code.html" target="_blank" rel="noopener">Full Dataset</a></li></ul><h2 id="Hadoop基础"><a href="#Hadoop基础" class="headerlink" title="Hadoop基础"></a>Hadoop基础</h2><h3 id="Hadoop和Spark"><a href="#Hadoop和Spark" class="headerlink" title="Hadoop和Spark"></a>Hadoop和Spark</h3><p>Hadoop和Spark是两种不同的大数据处理框架，如下图所示。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/BigData2020/bigdata-basic-0.png" alt=""></p><ul><li>上图中的蓝色部分是Hadoop生态系统组件，黄色部分是Spark生态组件。</li><li>虽然它们是两种不同的大数据处理框架，但它们不是互斥的。Spark与Hadoop 中的 MapReduce 是一种相互共生的关系。</li><li>Hadoop 提供了 Spark 许多没有的功能，比如分布式文件系统，而 Spark 提供了实时内存计算，速度非常快。</li></ul><p>Hadoop 通常包括2个部分：存储和处理。存储部分就是Hadoop的分布式文件系统（HDFS），处理指的是MapReduce（MP）。</p><h3 id="Hadoop-安装和配置"><a href="#Hadoop-安装和配置" class="headerlink" title="Hadoop 安装和配置"></a>Hadoop 安装和配置</h3><ul><li>ref-1：<a href="https://fuhailin.github.io/Hadoop-on-MacOS/" target="_blank" rel="noopener">在Mac上配置Hadoop娱乐环境 | Blog</a></li><li>ref-2：<a href="https://zhuanlan.zhihu.com/p/33117305" target="_blank" rel="noopener">Mac OS X 上搭建 Hadoop 开发环境指南 | 知乎</a></li><li>ref-3: <a href="https://segmentfault.com/a/1190000009103629" target="_blank" rel="noopener">Mac环境下Hadoop的安装与配置 | Segmentfault</a></li></ul><h4 id="Hadoop-安装模式"><a href="#Hadoop-安装模式" class="headerlink" title="Hadoop 安装模式"></a>Hadoop 安装模式</h4><p>Hadoop 安装模式分为3种，分别是单机模式，伪分布模式和全分布模式。默认安装是单机模式。可以通过配置文件 <code>core-site.xml</code>，将默认的单机模式更改为伪分布模式。</p><blockquote><p>关于Hadoop 3种安装模式和如何使用虚拟机进行分布式安装，可以参考《Hadoop应用技术详解》书籍的第2章节——Hadoop安装。</p></blockquote><blockquote><p>Hadoop 的运行方式是由配置文件决定的，因此如果需要从伪分布式模式切换回非分布式模式，需要删除 <code>core-site.xml</code> 中的配置项。</p></blockquote><p>下面简单记录，如何通过修改配置文件，在 Mac 上搭建伪分布模式 Hadoop 环境。</p><h4 id="Hadoop-安装步骤"><a href="#Hadoop-安装步骤" class="headerlink" title="Hadoop 安装步骤"></a>Hadoop 安装步骤</h4><p>Hadoop的安装和配置步骤如下（具体细节参考上述参考链接）</p><ol><li>安装Java。</li><li>Mac设置中，进入“共享”设置页面，允许远程登录，使用 <code>ssh localhost</code> 进行验证。</li><li>下载Hadoop源码，在 <a href="https://hadoop.apache.org/" target="_blank" rel="noopener">Hadoop官网</a> 可下载，此处选择下载 <code>hadoop 2.10.0</code>。将下载的 <code>.tar.gz</code> 压缩包解压并放置到 <code>/Library/hadoop-2.10.0</code> 路径。</li><li>设置Hadoop环境变量</li></ol><p>(1) 打开配置文件</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~<span class="string">/.bash_profile</span></span><br></pre></td></tr></table></figure><p>(2) 设置环境变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HADOOP_HOME</span>=/Library/hadoop-2.10.0</span><br><span class="line"><span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$&#123;HADOOP_HOME&#125;/bin</span><br><span class="line"></span><br><span class="line"><span class="attribute">HADOOP_CONF_DIR</span>=/Library/hadoop-2.10.0/etc/hadoop</span><br><span class="line"></span><br><span class="line"><span class="attribute">HADOOP_COMMON_LIB_NATIVE_DIR</span>=/Library/hadoop-2.10.0/lib/native</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span> HADOOP_HOME</span><br><span class="line"><span class="builtin-name">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span> HADOOP_CONF_DIR</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span> HADOOP_COMMON_LIB_NATIVE_DIR</span><br></pre></td></tr></table></figure><p>(3) 使配置文件生效，并验证Hadoop版本号</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source ~<span class="string">/.bash_profile</span></span><br><span class="line"></span><br><span class="line">hadoop <span class="keyword">version</span></span><br></pre></td></tr></table></figure><ol start="5"><li>修改 Hadoop 的配置文件</li></ol><p>需要修改的 Hadoop 配置文件都在目录 <code>etc/hadoop</code> 下，包括</p><ul><li><code>hadoop-env.sh</code></li><li><code>core-site.xml</code></li><li><code>hdfs-site.xml</code></li><li><code>mapred-site.xml</code></li><li><code>yarn-site.xml</code></li></ul><p>下面逐步进行修改</p><p>(1) 修改 <code>hadoop-env.sh</code> 文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_HOME</span>=/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">HADOOP_HOME</span>=/Library/hadoop-2.10.0</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">HADOOP_CONF_DIR</span>=/Library/hadoop-2.10.0/etc/hadoop</span><br></pre></td></tr></table></figure><p>(2) 修改 <code>core-site.xml</code> 文件</p><p>设置 Hadoop 的临时目录和文件系统，<code>localhost:9000</code> 表示本地主机。如果使用远程主机，要用相应的 IP 地址来代替，填写远程主机的域名，则需要到 <code>/etc/hosts</code> 文件中做 DNS 映射。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--localhost:9000 表示本地主机--&gt;</span>&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--用来指定hadoop运行时产生文件的存放目录  自己创建--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/Users/lbs/devfiles/hadoop/hadoop-2.10.0/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Directories for software develop and save temporary files.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(3) 修改 <code>hdfs-site.xml</code> 文件</p><p><code>hdfs-site.xml</code> 指定了 HDFS 的默认参数副本数，因为仅运行在一个节点上（伪分布模式），所以这里的副本数为1。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--不是root用户也可以写文件到hdfs--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    <span class="comment">&lt;!--关闭防火墙--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!--把路径换成本地的name位置--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/Users/lbs/devfiles/hadoop/hadoop-2.10.0/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">  <span class="comment">&lt;!--在本地新建一个存放hadoop数据的文件夹，然后将路径在这里配置一下--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/Users/lbs/devfiles/hadoop/hadoop-2.10.0/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(4) 修改 <code>mapred-site.xml</code> 文件</p><p>复制 <code>mapred-site.xml.template</code> 模板文件，并修改为 <code>mapred-site.xml</code> 文件，然后将 <code>yarn</code> 设置成数据处理框架，并设置 JobTracker 的主机名与端口。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定mapreduce运行在yarn上--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(5) 修改 <code>yarn-site.xml</code> 文件</p><p>配置数据的处理框架 <code>yarn</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="启动Hadoop"><a href="#启动Hadoop" class="headerlink" title="启动Hadoop"></a>启动Hadoop</h4><p>(1) 第一次启动Hadoop，需要对 NameNode 进行格式化，后续启动不再需要执行此步骤。</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop namenode -<span class="built_in">format</span></span><br></pre></td></tr></table></figure><p>(2) 启动 HDFS：进入Hadoop 安装目录下的 <code>sbin</code> 目录，并启动HDFS（需要设置Mac允许远程登录，过程中共需要3次输入密码）</p><blockquote><p>Tip: 初次安装和启动时，可以执行 <code>./start-all.sh</code>，进行必要的初始化安装</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/Library/hadoop-2.10.0/sbin</span></span><br><span class="line"></span><br><span class="line"><span class="string">./start-dfs.sh</span></span><br></pre></td></tr></table></figure><p>若出现下述信息，表示启动成功</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lbsMacBook-Pro:sbin lbs$ ./start-dfs.sh</span><br><span class="line">Starting namenodes on [localhost]</span><br><span class="line">Password:</span><br><span class="line">localhost: namenode running as process 12993. Stop it first.</span><br><span class="line">Password:</span><br><span class="line">localhost: datanode running as process 32400. Stop it first.</span><br><span class="line">Starting secondary namenodes [0.0.0.0]</span><br><span class="line">Password:</span><br><span class="line">0.0.0.0:<span class="built_in"> Connection </span>closed by 127.0.0.1<span class="built_in"> port </span>22</span><br></pre></td></tr></table></figure><p>需要注意的是，在<code>log</code>中会显示警告</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN util.NativeCodeLoader: Unable to <span class="keyword">load</span> <span class="keyword">native</span>-hadoop <span class="keyword">library</span> <span class="keyword">for</span> your platform... <span class="keyword">using</span> builtin-<span class="keyword">java</span> classes <span class="keyword">where</span> applicabled的</span><br></pre></td></tr></table></figure><p>上述提醒是关于 Hadoop 本地库的——Hadoop本地库是为了提高效率或者某些不能用Java实现的功能组件库。可以参考 <a href="http://rockyfeng.me/hadoop_native_library_mac.html" target="_blank" rel="noopener">Mac OSX 下 Hadoop 使用本地库提高效率</a> 了解详情。</p><p>停止 Hadoop 方法如下</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/Library/hadoop-2.10.0/sbin</span></span><br><span class="line"></span><br><span class="line"><span class="string">./sbin/stop-dfs.sh</span></span><br></pre></td></tr></table></figure><p>(3) 在终端执行 <code>jps</code>，若看到如下信息，证明 Hadoop 可以成功启动。<strong>看到 <code>DataNode</code>，<code>NameNode</code> 和 <code>SecondaryNameNode</code> 信息，表明启动的是一个伪分布模式Hadoop。</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lbsMacBook-Pro:sbin lbs$ jps</span><br><span class="line"></span><br><span class="line"><span class="number">32400</span> DataNode</span><br><span class="line"><span class="number">12993</span> NameNode</span><br><span class="line"><span class="number">30065</span> BootLanguagServerBootApp</span><br><span class="line"><span class="number">13266</span> SecondaryNameNode</span><br><span class="line"><span class="number">30039</span> org.eclipse.equinox.launcher_1<span class="number">.5</span><span class="number">.700</span>.v20200207<span class="number">-2156.</span>jar</span><br><span class="line"><span class="number">35019</span> ResourceManager</span><br><span class="line"><span class="number">35117</span> NodeManager</span><br><span class="line"><span class="number">32926</span> RunJar</span><br><span class="line"><span class="number">35199</span> Jps</span><br></pre></td></tr></table></figure><p>也可以访问 <code>http://localhost:50070/dfshealth.html#tab-overview</code> 来查看 Hadoop的启动情况。<strong>看到 <code>Live Node</code> 参数，证明伪分布模式 Hadoop 启动成功。</strong></p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/BigData2020/hadoop-jps-live-node-1.png" alt=""></p><p>(4) 启动 yarn：进入Hadoop 安装目录下的 <code>sbin</code> 目录，并启动 yarn</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/Library/hadoop-2.10.0/sbin</span></span><br><span class="line"></span><br><span class="line"><span class="string">./start-yarn.sh</span></span><br></pre></td></tr></table></figure><p>至此，Hadoop的安装，配置和启动就完成啦！接下来可以通过一些 shell 命令来操作 Hadoop 下的文件了，例如</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hadoop <span class="built_in">fs</span> -ls /　　　　　　　 查看根目录下的文件及文件夹</span><br><span class="line">hadoop <span class="built_in">fs</span> -<span class="built_in">mkdir</span> /test      在根目录下创建一个文件夹 testdata</span><br><span class="line">hadoop <span class="built_in">fs</span> -rm /.../...      移除某个文件</span><br><span class="line">hadoop <span class="built_in">fs</span> -rmr /...         移除某个空的文件夹</span><br></pre></td></tr></table></figure><h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><h5 id="Unable-to-load-native-hadoop-library-for-your-platform"><a href="#Unable-to-load-native-hadoop-library-for-your-platform" class="headerlink" title="Unable to load native-hadoop library for your platform"></a>Unable to load native-hadoop library for your platform</h5><p>在启动 HDFS时，若看到如下警告</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./<span class="literal">start</span>-dfs.sh</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lbsMacBook-Pro:~ lbs$ cd /Library/hadoop-2.10.0/sbin</span><br><span class="line"></span><br><span class="line">lbsMacBook-Pro:sbin lbs$ ./<span class="keyword">start</span>-dfs.sh</span><br><span class="line"></span><br><span class="line"><span class="number">20</span>/<span class="number">03</span>/<span class="number">23</span> <span class="number">08</span>:<span class="number">46</span>:<span class="number">43</span> WARN util.NativeCodeLoader: Unable <span class="keyword">to</span> <span class="keyword">load</span> <span class="keyword">native</span>-hadoop <span class="keyword">library</span> <span class="keyword">for</span> your platform... <span class="keyword">using</span> builtin-<span class="keyword">java</span> classes <span class="keyword">where</span> applicable</span><br><span class="line"><span class="keyword">Starting</span> namenodes <span class="keyword">on</span> [localhost]</span><br><span class="line"><span class="keyword">Password</span>:</span><br><span class="line">localhost: namenode running <span class="keyword">as</span> process <span class="number">93155.</span> <span class="keyword">Stop</span> it first.</span><br><span class="line"><span class="keyword">Password</span>:</span><br><span class="line">localhost: datanode running <span class="keyword">as</span> process <span class="number">93262.</span> <span class="keyword">Stop</span> it first.</span><br><span class="line"><span class="keyword">Starting</span> secondary namenodes [<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>]</span><br><span class="line"><span class="keyword">Password</span>:</span><br><span class="line"><span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>: secondarynamenode running <span class="keyword">as</span> process <span class="number">93404.</span> <span class="keyword">Stop</span> it first.</span><br></pre></td></tr></table></figure><p>上述提醒是关于 Hadoop 本地库的——Hadoop本地库是为了提高效率或者某些不能用Java实现的功能组件库。可以参考 <a href="http://rockyfeng.me/hadoop_native_library_mac.html" target="_blank" rel="noopener">Mac OSX 下 Hadoop 使用本地库提高效率</a> 了解详情。</p><h2 id="《Hadoop-应用开发技术详解》-学习笔记"><a href="#《Hadoop-应用开发技术详解》-学习笔记" class="headerlink" title="《Hadoop 应用开发技术详解》 学习笔记"></a>《Hadoop 应用开发技术详解》 学习笔记</h2><h3 id="MapReduce快速入门-WordCount"><a href="#MapReduce快速入门-WordCount" class="headerlink" title="MapReduce快速入门-WordCount"></a>MapReduce快速入门-WordCount</h3><ul><li><a href="https://www.jianshu.com/p/35ef70dfb651" target="_blank" rel="noopener">Intellij 开发Hadoop环境搭建 - WordCount | 简书</a></li><li><a href="https://www.cnblogs.com/airnew/p/9540982.html" target="_blank" rel="noopener">使用IDEA编写第一个MapReduce程序</a></li><li><a href="https://www.polarxiong.com/archives/Hadoop-Intellij%E7%BB%93%E5%90%88Maven%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95MapReduce%E7%A8%8B%E5%BA%8F-%E6%97%A0%E9%9C%80%E6%90%AD%E8%BD%BDHadoop%E5%92%8CHDFS%E7%8E%AF%E5%A2%83.html" target="_blank" rel="noopener">Intellij结合Maven本地运行和调试MapReduce程序</a></li><li><a href="https://zhuanlan.zhihu.com/p/43042078" target="_blank" rel="noopener">一起学Hadoop——第一个MapReduce程序</a></li></ul><h4 id="工程创建"><a href="#工程创建" class="headerlink" title="工程创建"></a>工程创建</h4><ol><li>使用IDEA创建一个基于Maven的工程——WordCount</li><li>在 <code>pom.xml</code> 中添加如下依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lbs0912<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wordcount<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--添加 apache 镜像源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>apache<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--添加如下依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建 <code>WordMapper</code> 类</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package wordcount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> WordMapper extends Mapper&lt;<span class="keyword">Object</span>, <span class="type">Text</span>, <span class="type">Text</span>, IntWritable&gt; &#123;</span><br><span class="line">    IntWritable one = <span class="built_in">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">    <span class="type">Text</span> word = <span class="built_in">new</span> Text();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> map(<span class="keyword">Object</span> key, <span class="type">Text</span> <span class="keyword">value</span>, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        StringTokenizer itr = <span class="built_in">new</span> StringTokenizer(<span class="keyword">value</span>.toString());</span><br><span class="line">        <span class="keyword">while</span> (itr.hasMoreTokens()) &#123;</span><br><span class="line">            word.<span class="keyword">set</span>(itr.nextToken());</span><br><span class="line">            context.<span class="keyword">write</span>(word, one);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建 <code>WordReducer</code> 类</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> wordcount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.<span class="type">IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.<span class="type">IntWritable</span>;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.<span class="type">Text</span>;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.<span class="type">Reducer</span>;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">WordReducer</span> <span class="keyword">extends</span> <span class="title">Reducer&lt;Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable&gt;</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">IntWritable</span> result = <span class="keyword">new</span> <span class="type">IntWritable</span>();</span><br><span class="line"></span><br><span class="line">    public void reduce(<span class="type">Text</span>key, <span class="type">Iterable</span>&lt;<span class="type">IntWritable</span>&gt; values, <span class="type">Context</span> context) <span class="keyword">throws</span> <span class="type">IOException</span>,<span class="type">InterruptedException</span> &#123;</span><br><span class="line">        int sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">IntWritable</span> <span class="keyword">val</span>:values) &#123;</span><br><span class="line">            sum += <span class="keyword">val</span>.get();</span><br><span class="line">        &#125;</span><br><span class="line">        result.set(sum);</span><br><span class="line">        context.write(key,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>创建 <code>WordMain</code> 驱动类</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package wordcount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Job;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line">import org.apache.hadoop.util.GenericOptionsParser;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> WordMain &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) throws Exception &#123;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> <span class="constructor">Configuration()</span>;</span><br><span class="line">        String<span class="literal">[]</span> otherArgs = <span class="keyword">new</span> <span class="constructor">GenericOptionsParser(<span class="params">conf</span>, <span class="params">args</span>)</span>.get<span class="constructor">RemainingArgs()</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里必须有输入/输出</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (otherArgs.length != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>err.println(<span class="string">"Usage: WordCount &lt;in&gt; &lt;out&gt;"</span>);</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>exit(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Job job = <span class="keyword">new</span> <span class="constructor">Job(<span class="params">conf</span>, <span class="string">"wordcount"</span>)</span>;</span><br><span class="line">        job.set<span class="constructor">JarByClass(WordMain.<span class="params">class</span>)</span>;       <span class="comment">//主类</span></span><br><span class="line">        job.set<span class="constructor">MapperClass(WordMapper.<span class="params">class</span>)</span>;     <span class="comment">//Mapper</span></span><br><span class="line">        job.set<span class="constructor">CombinerClass(WordReducer.<span class="params">class</span>)</span>;  <span class="comment">//作业合成类</span></span><br><span class="line">        job.set<span class="constructor">ReducerClass(WordReducer.<span class="params">class</span>)</span>;    <span class="comment">//Reducer</span></span><br><span class="line">        job.set<span class="constructor">OutputKeyClass(Text.<span class="params">class</span>)</span>;       <span class="comment">//设置作业输出数据的关键类</span></span><br><span class="line">        job.set<span class="constructor">OutputValueClass(IntWritable.<span class="params">class</span>)</span>;  <span class="comment">//设置作业输出值类</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">FileInputFormat</span>.</span></span>add<span class="constructor">InputPath(<span class="params">job</span>, <span class="params">new</span> Path(<span class="params">otherArgs</span>[0])</span>);   <span class="comment">//文件输入</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">FileOutputFormat</span>.</span></span>set<span class="constructor">OutputPath(<span class="params">job</span>, <span class="params">new</span> Path(<span class="params">otherArgs</span>[1])</span>);  <span class="comment">//文件输出</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>exit(job.wait<span class="constructor">ForCompletion(<span class="params">true</span>)</span> ? <span class="number">0</span> : <span class="number">1</span>);   <span class="comment">//等待完成退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IDEA中直接运行程序"><a href="#IDEA中直接运行程序" class="headerlink" title="IDEA中直接运行程序"></a>IDEA中直接运行程序</h4><ul><li><a href="https://www.jianshu.com/p/35ef70dfb651" target="_blank" rel="noopener">Intellij 开发Hadoop环境搭建 - WordCount | 简书</a></li></ul><p>选择 <code>Run -&gt; Edit Configurations</code>, 在程序参数栏目中输入 <code>input/ output</code>，如下图所示</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/BigData2020/hadoop-wordcount-2.png" alt=""></p><p>在 <code>input</code> 目录中添加统计单词个数的测试的文件 <code>wordcount1.txt</code></p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello，i love coding</span><br><span class="line">are you ok?</span><br><span class="line">Hello, i love hadoop</span><br><span class="line">are you ok?</span><br></pre></td></tr></table></figure><p>再次运行程序，会看到如下的 <code>output</code> 目录结构</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- input</span><br><span class="line">- output</span><br><span class="line">    <span class="string">| - ._SUCCESS.crc</span></span><br><span class="line">    <span class="string">| - .part-r-00000.crc</span></span><br><span class="line">    <span class="string">| - ._SUCCESS</span></span><br><span class="line">    <span class="string">| - part-r-00000</span></span><br></pre></td></tr></table></figure><p>打开 <code>part-r-00000</code> 文件，即可看到单词出现次数的统计结果</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Hello,<span class="number">1</span></span><br><span class="line">Hello，i<span class="number">1</span></span><br><span class="line">are<span class="number">2</span></span><br><span class="line">coding<span class="number">1</span></span><br><span class="line">hadoop<span class="number">1</span></span><br><span class="line">i<span class="number">1</span></span><br><span class="line">love<span class="number">2</span></span><br><span class="line">ok?<span class="number">2</span></span><br><span class="line">you<span class="number">2</span></span><br></pre></td></tr></table></figure><p>需要注意的是，由于Hadoop的设定，下次运行程序前，需要先删除output文件目录。</p><h4 id="导出jar包运行程序"><a href="#导出jar包运行程序" class="headerlink" title="导出jar包运行程序"></a>导出jar包运行程序</h4><ol><li>在 <code>File -&gt; Project Structure</code> 选项中，为工程添加 <code>Artifacts</code>，选择 <code>WordMain</code> 类</li></ol><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/BigData2020/hadoop-wordcount-0.png" alt=""></p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/BigData2020/hadoop-wordcount-1.png" alt=""></p><ol start="2"><li>选择 <code>Build -&gt; Build Artifacts...</code>，生成 <code>.jar</code> 文件</li></ol><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/BigData2020/hadoop-wordcount-3.png" alt=""></p><ol start="3"><li>进入HDFS系统目录(不是其余文件系统目录)，执行下述命令</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar WordCount.jar <span class="keyword">input</span>/ <span class="keyword">out</span>/</span><br></pre></td></tr></table></figure><h3 id="HDFS分布式文件系统详解"><a href="#HDFS分布式文件系统详解" class="headerlink" title="HDFS分布式文件系统详解"></a>HDFS分布式文件系统详解</h3><h4 id="认识HDFS"><a href="#认识HDFS" class="headerlink" title="认识HDFS"></a>认识HDFS</h4><p>HDFS（<code>Hadoop Distributed File System</code>）是一个用在普通硬件设备上的分布式文件系统。 HDFS 具有高容错性（<code>fault-tolerant</code>）和高吞吐量（<code>high throughput</code>），适合有超大数据集的应用程序，可以实现通过流的形式访问文件系统中的数据。</p><p>运行在HDFS之上的应用程序必须流式地访问它们的数据集，它不是典型的运行在常规的文件系统之上的常规程序。HDFS的设计适合批量处理，而不是用户交互式的，重点是数据吞吐量，而不是数据访问的反应时间。</p><p>HDFS以块序列的形式存储每一个文件，文件中除了最后一个块的其他块都是相同的大小。</p><h4 id="HDFS架构"><a href="#HDFS架构" class="headerlink" title="HDFS架构"></a>HDFS架构</h4><p>HDFS 为Hadoop 这个分布式计算框架一共高性能，高可靠，高可扩展的存储服务。HDFS是一个典型的主从架构，一个HDFS集群是由一个主节点（<code>Namenode</code>）和一定数目的从节点（<code>Datanodes</code>）组成。</p><ul><li>Namenode 是一个中心服务器，负责管理文件系统的名字空间（<code>namespace</code>）以及客户端对文件的访问。同时确定块和数据节点的映射。<ul><li>提供名称查询服务，它是一个 Jetty 服务器</li><li>保存 <code>metadata</code> 信息，包括文件 <code>owership</code> 和 <code>permissions</code>，文件包含有哪些块，<code>Block</code> 保存在哪个 <code>DataNode</code> 等</li><li>NameNode 的 <code>metadata</code> 信息在启动后会加载到内存中</li></ul></li><li>Datanode一般是一个节点一个，负责管理它所在节点上的存储。<strong>DataNode 通常以机架的形式组织，机架通过一个交换机将所有系统连接起来。</strong> DataNode的功能包括<ul><li>保存Block，每个块对应一个元数据信息文件</li><li>启动DataNode线程的时候会向NameNode汇报Block信息</li><li>通过向NameNode发送心跳保持与其联系（3秒一次）</li></ul></li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/BigData2020/hadoop-hdfs-architecture-1.png" alt=""></p><ul><li>机架（<code>Rack</code>）：一个 Block 的三个副本通常会保存到两个或者两个以上的机架中，进行防灾容错</li><li>数据块（<code>Block</code>）是 HDFS 文件系统基本的存储单位，Hadoop 1.X 默认大小是 64MB，Hadoop 2.X 默认大小是 128MB。HDFS上的文件系统被划分为块大小的多个分块（<code>Chunk</code>）作为独立的存储单元。和其他文件系统不同的是，HDFS上小于一个块大小的文件不会占据整个块的空间。使用块抽象而非整个文件作为存储单元，大大简化了存储子系统的设计。</li><li>辅助元数据节点（<code>SecondaryNameNode</code>）负责镜像备份，日志和镜像的定期合并。</li></ul><blockquote><p>使用 <code>hadoop fsk / -files -blocks</code> 可以显示块的信息。</p></blockquote><p>Block 数据块大小设置的考虑因素包括</p><ol><li>减少文件寻址时间</li><li>减少管理快的数据开销，因每个快都需要在 NameNode 上有对应的记录</li><li>对数据块进行读写，减少建立网络的连接成本</li></ol><h4 id="块备份原理"><a href="#块备份原理" class="headerlink" title="块备份原理"></a>块备份原理</h4><p>Block 是 HDFS 文件系统的最小组成单元，它通过一个 <code>Long</code> 整数被唯一标识。每个 Block 会有多个副本，默认有3个副本。为了数据的安全和高效，Hadoop 默认对3个副本的存放策略如下图所示</p><ul><li>第1块：在本地机器的HDFS目录下存储一个 Block</li><li>第2块：不同 Rack 的某个 DataNode 上存储一个 Block</li><li>第3块：在该机器的同一个 Rack 下的某台机器上存储一个Block</li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/BigData2020/hadoop-hdfs-architecture-block-1.png" alt=""></p><p>这样的策略可以保证对该 Block 所属文件的访问能够优先在本 Rack 下找到。如果整个 Rack 发生了异常，也可以在另外的 Rack 找到该 Block 的副本。这样足够高效，并且同时做到了数据的容错。</p><h4 id="Hadoop的RPC机制"><a href="#Hadoop的RPC机制" class="headerlink" title="Hadoop的RPC机制"></a>Hadoop的RPC机制</h4><p>RPC（<code>Remote Procedure Call</code>）即远程过程调用机制会面临2个问题</p><ol><li>对象调用方式</li><li>序列/反序列化机制</li></ol><p>RPC 架构如下图所示。Hadoop 自己实现了简单的 RPC 组件，依赖于 <code>Hadoop Writable</code> 类型的支持。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/BigData2020/hadoop-hdfs-architecture-rpc-1.png" alt=""></p><p><code>Hadoop Writable</code> 接口要求每个实现类多要确保将本类的对象正确序列化（<code>writeObject</code>）和反序列化（<code>readObject</code>）。因此，Hadoop RPC 使用 Java 动态代理和反射实现对象调用方式，客户端到服务器数据的序列化和反序列化由 Hadoop框架或用户自己来实现，也就是数据组装定制的。</p><blockquote><p>Hadoop RPC = 动态代理 + 定制的二进制流</p></blockquote><h3 id="开源数据库HBase"><a href="#开源数据库HBase" class="headerlink" title="开源数据库HBase"></a>开源数据库HBase</h3><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><ul><li>HBase 是一个可伸缩的分布式的，面向列的开源数据库，是一个适合于非结构化数据存储的数据库。需要注意的是，HBase 是基于列的而不是基于行的模式。</li><li>利用 HBase 技术可以在廉价 PC Server上搭建大规模结构化存储集群。</li><li>HBase 是 Google Bigtable 的开源实现，与 Google Bigtable 利用GFS作为其文件存储系统类似， HBase 利用 Hadoop HDFS 作为其文件存储系统。Google 运行 MapReduce 来处理 Bigtable 中的海量数据，HBase 同样利用 Hadoop MapReduce 来处理海量数据。Google Bigtable 利用 Chubby 作为协同服务，HBase 利用 Zookeeper 作为对应。</li></ul><p>HBase 的特点如下</p><ol><li>大：一个表可以有上亿行，上百万列</li><li>面向列：面向列（族）的存储和权限控制，列（族）独立检索</li><li>稀疏：对于为空（NULL）的列，并不占用存储空间，因此，表可以设计的非常稀疏。</li><li></li></ol><h2 id="Hadoop-实战Demo"><a href="#Hadoop-实战Demo" class="headerlink" title="Hadoop 实战Demo"></a>Hadoop 实战Demo</h2><blockquote><p>有句话说得好，“大数据胜于算法”，意思是说对于某些应用（例如根据以往的偏好来推荐电影和音乐），不论算法有多牛，基于小数据的推荐效果往往都不如基于大量可用数据的一般算法的推荐效果。 —— 《Hadoop 权威指南》</p></blockquote><ul><li><a href="http://blog.fens.me/hadoop-mapreduce-recommend/" target="_blank" rel="noopener">用Hadoop构建电影推荐系统 | 粉丝日志</a></li><li><a href="http://blog.fens.me/hadoop-mahout-recommend-job/" target="_blank" rel="noopener">用Mahout构建职位推荐引擎 | 粉丝日志</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文主要记录Mac下如何进行Hadoop伪分布模式安装，并通过词频统计Demo程序(WordCount)理解MapReduce的原理。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Hadoop" scheme="https://lbs0912.github.io/categories/Hadoop/"/>
    
    
      <category term="BigData" scheme="https://lbs0912.github.io/tags/BigData/"/>
    
      <category term="Hadoop" scheme="https://lbs0912.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-005</title>
    <link href="https://lbs0912.github.io/2020/02/28/leetcode-005/"/>
    <id>https://lbs0912.github.io/2020/02/28/leetcode-005/</id>
    <published>2020-02-28T06:35:26.000Z</published>
    <updated>2020-05-16T15:11:34.418Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录LeetCode题目笔记，汇总LeetCode解答记录</li></ul><a id="more"></a><h2 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h2><ul><li>2020/02/23，撰写</li><li>2020/02/28，整理完成</li></ul><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li><a href="https://leetcode-cn.com/problems/sum-of-two-integers/" target="_blank" rel="noopener">LeetCode-371. 两整数之和</a></li><li><a href="https://leetcode-cn.com/problems/detect-capital/" target="_blank" rel="noopener">LeetCode-520. 检测大写字母</a></li><li><a href="https://leetcode-cn.com/problems/nim-game/" target="_blank" rel="noopener">LeetCode-292. Nim 游戏</a></li><li><a href="https://leetcode-cn.com/problems/rising-temperature/" target="_blank" rel="noopener">LeetCode-197. 上升的温度</a></li><li><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">LeetCode-136. 只出现一次的数字</a></li></ul><h2 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371. 两整数之和"></a>371. 两整数之和</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/sum-of-two-integers/" target="_blank" rel="noopener">LeetCode-371. 两整数之和</a></li></ul><h3 id="Approach-1-位运算"><a href="#Approach-1-位运算" class="headerlink" title="Approach 1-位运算"></a>Approach 1-位运算</h3><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><p>利用位运算求解。</p><ul><li>情况1：无进位的加法</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>+<span class="number">2</span>=<span class="number">7</span></span><br><span class="line"> 加法            情况<span class="number">1</span>：无进位加法</span><br><span class="line">  <span class="number">0101</span>               <span class="number">0101</span>                      </span><br><span class="line">+ <span class="number">0010</span>          XOR  <span class="number">0010</span></span><br><span class="line">--------         ----------</span><br><span class="line">  <span class="number">0111</span>               <span class="number">0111</span></span><br></pre></td></tr></table></figure><p>如上所示，在无进位的情况下，加法可以使用异或运算 <code>XOR</code> 替代。</p><p>情况2：有进位的加法</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>+<span class="number">7</span>=<span class="number">12</span></span><br><span class="line"></span><br><span class="line"> 加法        情况<span class="number">2</span>           情况<span class="number">2</span>           情况<span class="number">1</span>：无进位加法</span><br><span class="line">  <span class="number">0101</span>         <span class="number">0101</span>   进位carry <span class="number">1010</span>      进位carry <span class="number">0100</span>    </span><br><span class="line">+ <span class="number">0111</span>     XOR <span class="number">0111</span>  |--&gt; XOR   <span class="number">0010</span>    |--&gt; XOR   <span class="number">1000</span></span><br><span class="line">--------   --------  |       --------   |        --------</span><br><span class="line">  <span class="number">1100</span>         <span class="number">0010</span> --          <span class="number">1000</span> ----           <span class="number">1100</span></span><br></pre></td></tr></table></figure><p>在有进位的情况下，若发生进位，则对应的位上a和b的二进制值均为1。利用与运算可以求解到进位的数值。由于要进位，因此再将与操作的结果向左移动一位即可。即 <code>carry = (a&amp;b)&lt;&lt;1</code>。</p><p>得到进位数值，就可以转换为 <code>情况1：无进位的加法</code> 求解。</p><p>综上，求解思路可以总结为</p><ul><li>异或求解无进位情况下的和，<code>sum = a^b</code>（情况1）</li><li>判断进位 <code>carry</code>，若不为0，则为情况2，<code>carry = (a&amp;b)&lt;&lt;1</code>，问题转化为了求解 <code>carry</code> 和 <code>sum</code>的和</li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ul><li>C++：</li></ul><p>递归函数实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> sum = a^b;</span><br><span class="line">        <span class="keyword">int</span> carry = (a&amp;b)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//or</span></span><br><span class="line">        <span class="comment">//leetcode 中文版不支持负值左移动，需要改为无符号数</span></span><br><span class="line">        <span class="comment">//int carry = (unsigned int)(a&amp;b)&lt;&lt;1;</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> getSum(sum,carry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者将其简写为1行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (b==<span class="number">0</span>)? a: getSum(a^b,(a&amp;b)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry;</span><br><span class="line">        <span class="keyword">while</span>(b)&#123;</span><br><span class="line">            carry = a &amp; b; </span><br><span class="line">            a = a ^ b;   <span class="comment">//sum</span></span><br><span class="line">            b = carry &lt;&lt;<span class="number">1</span>;  <span class="comment">//carry</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//or</span></span><br><span class="line">            <span class="comment">//leetcode 中文版不支持负值左移动，需要改为无符号数</span></span><br><span class="line">            <span class="comment">// b = (unsigned int)carry&lt;&lt;1;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="520-检测大写字母"><a href="#520-检测大写字母" class="headerlink" title="520. 检测大写字母"></a>520. 检测大写字母</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/detect-capital/" target="_blank" rel="noopener">LeetCode-520. 检测大写字母</a></li></ul><p>给定一个单词，你需要判断单词的大写使用是否正确。</p><p>我们定义，在以下情况时，单词的大写用法是正确的</p><pre><code>1. 全部字母都是大写，比如&quot;USA&quot;。2. 单词中所有字母都不是大写，比如&quot;leetcode&quot;。3. 如果单词不只含有一个字母，只有首字母大写，比如 &quot;Google&quot;。</code></pre><p>否则，我们定义这个单词没有正确使用大写字母。</p><p>示例 1</p><pre><code>输入: &quot;USA&quot;输出: True</code></pre><p>示例 2</p><pre><code>输入: &quot;FlaG&quot;输出: False</code></pre><p>注意: 输入是由大写和小写拉丁字母组成的非空单词。</p><h3 id="Approach-1-ASCII码值"><a href="#Approach-1-ASCII码值" class="headerlink" title="Approach 1-ASCII码值"></a>Approach 1-ASCII码值</h3><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><p>使用字母的ASCII值进行判断。</p><p>大写字母的ASCII值范围是<code>65~90</code>，小写字母的ASCII值范围是<code>97~122</code>。</p><p>总结判断逻辑如下</p><ol><li>若字母长度为1，直接返回 true</li><li>如果（第一个字母小写） 或者 （第一个字母大写且第2个字母小写），若后续字母全部小写，则符合条件，大写使用正确</li><li>如果前2个字母大写，若后续字母全部大写，则符合条件，大写使用正确</li></ol><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java 实现1： 使用 <code>charAt(index)</code> 实现</li></ul><p>Java中，<code>charAt(index)</code> 函数可以返回字符串中指定索引值处（<code>index</code>）的字母，函数返回类型是 <code>char</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">detectCapitalUse</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wordLength = word.length();</span><br><span class="line">        <span class="comment">//由于后续for循环中使用到了word[i]且i初始值为1，因此要先对wordLength=1的情况进行判断</span></span><br><span class="line">        <span class="keyword">if</span>(wordLength == <span class="number">1</span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(word.charAt(<span class="number">0</span>) &gt;= <span class="number">97</span> || (word.charAt(<span class="number">0</span>) &lt;= <span class="number">90</span> &amp;&amp; word.charAt(<span class="number">1</span>) &gt;= <span class="number">97</span>))&#123;</span><br><span class="line">            <span class="comment">//第1个字母小写 或者第1个字母大写并且第2个字母小写</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;wordLength;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word.charAt(i) &lt;= <span class="number">90</span>)&#123;  <span class="comment">//后续字母中出现大写字母</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//前两个字母均大写</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;wordLength;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word.charAt(i) &gt;= <span class="number">97</span>)&#123;  <span class="comment">//后续字母中出现小写字母</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Java 实现2： 使用 <code>codePointAt(index)</code> 实现</li></ul><p>Java中，<code>codePointAt(index)</code> 函数可以返回字符串中指定索引值处（<code>index</code>）字母的ASCII值，函数返回类型是 <code>int</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"> String word = <span class="string">"LiuBaoshuai"</span>;</span><br><span class="line"> <span class="keyword">char</span> myChar = charAt(word[<span class="number">3</span>]);   <span class="comment">// B</span></span><br><span class="line"> Character.codePointAt(word,<span class="number">3</span>);   <span class="comment">// 66</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">detectCapitalUse</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wordLength = word.length();</span><br><span class="line">        <span class="keyword">if</span>(wordLength == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Character.codePointAt(word,<span class="number">0</span>) &gt;= <span class="number">97</span> || (Character.codePointAt(word,<span class="number">0</span>) &lt;= <span class="number">90</span> &amp;&amp; Character.codePointAt(word,<span class="number">1</span>) &gt;= <span class="number">97</span>))&#123;</span><br><span class="line">            <span class="comment">//第1个字母小写 或者第1个字母大写并且第2个字母消息</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;wordLength;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Character.codePointAt(word,i) &lt;= <span class="number">90</span>)&#123;  <span class="comment">//后续字母中出现大写字母</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//前两个字母均大写</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;wordLength;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Character.codePointAt(word,i) &gt;= <span class="number">97</span>)&#123;  <span class="comment">//后续字母中出现小写字母</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">detectCapitalUse</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> wordLength = word.length();   <span class="comment">//.length()</span></span><br><span class="line">    <span class="keyword">int</span> codeFirst = (<span class="keyword">int</span>)word[<span class="number">0</span>];</span><br><span class="line">     <span class="comment">//由于后续for循环中使用到了word[i]且i初始值为1，因此要先对wordLength=1的情况进行判断</span></span><br><span class="line">        <span class="keyword">if</span>(wordLength == <span class="number">1</span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;       </span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">if</span>(codeFirst &lt;= <span class="number">90</span>)&#123;   <span class="comment">//首字母大写   </span></span><br><span class="line"><span class="keyword">if</span>((<span class="keyword">int</span>)word[<span class="number">1</span>] &lt;= <span class="number">90</span>)&#123;  <span class="comment">//第2个字母大写</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;wordLength;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> code = (<span class="keyword">int</span>)word[i];</span><br><span class="line"><span class="keyword">if</span>(code &gt;= <span class="number">97</span>)&#123;    <span class="comment">//后续字母中有小写</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//TESt</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;  <span class="comment">//第2个字母小写</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;wordLength;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> code = (<span class="keyword">int</span>)word[i];</span><br><span class="line"><span class="keyword">if</span>(code &lt;= <span class="number">90</span>)&#123;   <span class="comment">//后续字母中出现大写</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//TesT</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;  <span class="comment">//首字母小写  </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;wordLength;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> code = (<span class="keyword">int</span>)word[i];</span><br><span class="line"><span class="keyword">if</span>(code &lt;= <span class="number">90</span>)&#123;  <span class="comment">//检测到大写字母</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-直接使用内置大小写判断函数"><a href="#Approach-2-直接使用内置大小写判断函数" class="headerlink" title="Approach 2-直接使用内置大小写判断函数"></a>Approach 2-直接使用内置大小写判断函数</h3><h4 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h4><p>也可以直接使用语音内置的大小写判断函数实现。</p><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">detectCapitalUse</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wordLength = word.length();</span><br><span class="line">        <span class="keyword">if</span>(wordLength == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(Character.isLowerCase(word.charAt(<span class="number">0</span>)) || (Character.isUpperCase(word.charAt(<span class="number">0</span>)) &amp;&amp; Character.isLowerCase(word.charAt(<span class="number">1</span>))))&#123;</span><br><span class="line">            <span class="comment">//首字母小写 或者第1个字母大写并且第2个字母小写 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;wordLength;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Character.isUpperCase(word.charAt(i))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;wordLength;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Character.isLowerCase(word.charAt(i))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">detectCapitalUse</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wordLength = word.length();</span><br><span class="line">        <span class="keyword">if</span>(wordLength &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">islower</span>(word[<span class="number">0</span>]) || (<span class="built_in">isupper</span>(word[<span class="number">0</span>]) &amp;&amp; <span class="built_in">islower</span>(word[<span class="number">1</span>])))&#123;  </span><br><span class="line">         <span class="comment">//首字母小写 或者第1个字母大写并且第2个字母小写    </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;wordLength;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isupper</span>(word[i]))&#123;  <span class="comment">//后续出现大写字母</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// gooGle   GooGle</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>&#123;   <span class="comment">//前两个字母均大写</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;wordLength;i++)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(<span class="built_in">islower</span>(word[i]))&#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//GOOgle</span></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Approach-3-正则匹配实现"><a href="#Approach-3-正则匹配实现" class="headerlink" title="Approach 3-正则匹配实现"></a>Approach 3-正则匹配实现</h3><h4 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h4><p>总结判断逻辑如下</p><ol><li>若字母长度为1，直接返回 true</li><li>如果（第一个字母小写） 或者 （第一个字母大写且第2个字母小写），若后续字母全部小写，则符合条件，大写使用正确</li><li>如果前2个字母大写，若后续字母全部大写，则符合条件，大写使用正确</li></ol><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java 实现1： 正则匹配</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">detectCapitalUse</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> word.matches(<span class="string">"[A-Z]+|[a-z]+|[A-Z][a-z]+"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Java 实现2： 正则匹配</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">detectCapitalUse</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> word.equals(word.toUpperCase()) || </span><br><span class="line">               word.equals(word.toLowerCase()) ||</span><br><span class="line">               Character.isUpperCase(word.charAt(<span class="number">0</span>)) &amp;&amp; </span><br><span class="line">               word.substring(<span class="number">1</span>).equals(word.substring(<span class="number">1</span>).toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="292-Nim-游戏"><a href="#292-Nim-游戏" class="headerlink" title="292. Nim 游戏"></a>292. Nim 游戏</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/nim-game/" target="_blank" rel="noopener">LeetCode-292. Nim 游戏</a></li></ul><p>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 <code>1-3</code> 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p><p>你们是聪明人，每一步都是最优解。 </p><p>编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p><p>示例</p><pre><code>输入: 4输出: false 解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛； 因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</code></pre><h3 id="Approach-1-数值分析"><a href="#Approach-1-数值分析" class="headerlink" title="Approach 1-数值分析"></a>Approach 1-数值分析</h3><h4 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h4><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-292-nim-game.png" alt="leetcode-292-nim-game.png"></p><p>如上图所示</p><ol><li>当石头总数为4时，A（先取者）一定是会输的；</li><li>当石头总数为5/6/7时，如果A首先拿走1/2/3个石头，那么B将面对剩下4个石头的情况，转化为了情况1，此时B一定是会输的；</li><li>当石头总数为8个时，无论A首先拿走几个，B都可以留下4个石头给A，转化为情况1，因此A一定是会输的；</li><li>当石头总数为9/10/11个时，A可以首先拿走1/2/3个，给B留下8个石头，转化为情况3，此时B一定是会输的</li></ol><p>从上述分析可以看到，当有一方面对的石头数目是4个或者4的倍数，那么他一定是会输的。</p><h4 id="Solutiuon"><a href="#Solutiuon" class="headerlink" title="Solutiuon"></a>Solutiuon</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (n%<span class="number">4</span> != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n%<span class="number">4</span> != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="197-上升的温度-SQL"><a href="#197-上升的温度-SQL" class="headerlink" title="197. 上升的温度(SQL)"></a>197. 上升的温度(SQL)</h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/rising-temperature/" target="_blank" rel="noopener">LeetCode-197. 上升的温度</a></li></ul><p>给定一个 Weather 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">---------+------------------+------------------+</span></span><br><span class="line">| Id(INT) | RecordDate(DATE) | Temperature(INT) |</span><br><span class="line">+<span class="comment">---------+------------------+------------------+</span></span><br><span class="line">|       1 |       2015-01-01 |               10 |</span><br><span class="line">|       2 |       2015-01-02 |               25 |</span><br><span class="line">|       3 |       2015-01-03 |               20 |</span><br><span class="line">|       4 |       2015-01-04 |               30 |</span><br><span class="line">+<span class="comment">---------+------------------+------------------+</span></span><br></pre></td></tr></table></figure><p>例如，根据上述给定的 Weather 表格，返回如下 Id:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+</span></span><br><span class="line">| Id |</span><br><span class="line">+<span class="comment">----+</span></span><br><span class="line">|  2 |</span><br><span class="line">|  4 |</span><br><span class="line">+<span class="comment">----+</span></span><br></pre></td></tr></table></figure><h3 id="Approach-1-DATEDIFF实现"><a href="#Approach-1-DATEDIFF实现" class="headerlink" title="Approach 1-DATEDIFF实现"></a>Approach 1-DATEDIFF实现</h3><h4 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h4><p><code>DATEDIFF(A,B)</code> 函数可以返回 A 和 B 之间的天数</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DATEDIFF('<span class="number">2007</span><span class="number">-12</span><span class="number">-31</span>','<span class="number">2007</span><span class="number">-12</span><span class="number">-30</span>');   # <span class="number">1</span></span><br><span class="line">DATEDIFF('<span class="number">2010</span><span class="number">-12</span><span class="number">-30</span>','<span class="number">2010</span><span class="number">-12</span><span class="number">-31</span>');   # <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>本题中，查询的条件有2个</p><ol><li>与之前的日期相差为 1</li><li>比之前的温度高</li></ol><h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.Id</span><br><span class="line"><span class="keyword">FROM</span> Weather <span class="keyword">as</span> a,Weather <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.Temperature &lt; b.Temperature <span class="keyword">and</span> <span class="keyword">DATEDIFF</span>(a.RecordDate,b.RecordDate) = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-TO-DAYS实现"><a href="#Approach-2-TO-DAYS实现" class="headerlink" title="Approach 2-TO_DAYS实现"></a>Approach 2-TO_DAYS实现</h3><h4 id="Analysis-6"><a href="#Analysis-6" class="headerlink" title="Analysis"></a>Analysis</h4><p><code>TO_DAYS(A)</code> 函数返回了第0年和第A年之间的天数</p><h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.Id</span><br><span class="line"><span class="keyword">FROM</span> Weather <span class="keyword">as</span> a,Weather <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.Temperature &lt; b.Temperature <span class="keyword">and</span> <span class="keyword">TO_DAYS</span>(b.RecordDate) - <span class="keyword">TO_DAYS</span>(a.RecordDate) = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h2><h3 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">LeetCode-136. 只出现一次的数字</a></li></ul><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明</p><pre><code>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</code></pre><p>示例 1</p><pre><code>输入: [2,2,1]   输出: 1</code></pre><p>示例 2</p><pre><code>输入: [4,1,2,1,2]输出: 4</code></pre><h3 id="Approach-1-异或实现"><a href="#Approach-1-异或实现" class="headerlink" title="Approach 1-异或实现"></a>Approach 1-异或实现</h3><h4 id="Analysis-7"><a href="#Analysis-7" class="headerlink" title="Analysis"></a>Analysis</h4><p>使用异或XOR实现。将数组中所有的数值进行XOR操作，出现2次的数进行异或返回值是0，不会影响最后的结果。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ^ N = N</span><br><span class="line">N ^ N = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>因此，如果 N 是只出现一次的数字的话</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">N1 ^ N1 ^ N2 ^ N2 ^..............^ Nx ^ Nx ^ N</span><br><span class="line">= (N1^N1) ^ (N2^N2) ^..............^ (Nx^Nx) ^ N</span><br><span class="line">= <span class="number">0</span> ^ <span class="number">0</span> ^ ..........^ <span class="number">0</span> ^ N</span><br><span class="line">= N</span><br></pre></td></tr></table></figure><h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">                nums[<span class="number">0</span>] = nums[<span class="number">0</span>] ^ nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            result = result ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录LeetCode题目笔记，汇总LeetCode解答记录&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://lbs0912.github.io/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-003</title>
    <link href="https://lbs0912.github.io/2020/02/23/leetcode-003/"/>
    <id>https://lbs0912.github.io/2020/02/23/leetcode-003/</id>
    <published>2020-02-23T06:35:26.000Z</published>
    <updated>2020-02-23T08:48:04.365Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录LeetCode题目笔记，汇总LeetCode解答记录</li></ul><a id="more"></a><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li><a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="noopener">LeetCode-191. Number of 1 Bits （位1的个数）</a></li><li><a href="https://leetcode.com/problems/counting-bits/" target="_blank" rel="noopener">LeetCode-338. Counting Bits（比特位计数）</a></li><li><a href="https://leetcode.com/problems/longest-palindrome/" target="_blank" rel="noopener">LeetCode-409. Longest Palindrome （最长回文串）</a></li><li><a href="https://leetcode.com/problems/rectangle-area/?tab=Description" target="_blank" rel="noopener">LeetCode-223. Rectangle Area（矩形面积）</a></li><li><a href="https://leetcode.com/problems/number-complement/" target="_blank" rel="noopener">LeetCode-476. Number Complement（数字的补数）</a></li></ul><h2 id="191-Number-of-1-Bits（位1的个数）"><a href="#191-Number-of-1-Bits（位1的个数）" class="headerlink" title="191. Number of 1 Bits（位1的个数）"></a>191. Number of 1 Bits（位1的个数）</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="noopener">LeetCode-191. Number of 1 Bits（位1的个数）</a></li></ul><p>本问题中，计数了一个无符号整数的位，结果称为 <code>pop count</code>，或 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F/7110799?fr=aladdin" target="_blank" rel="noopener">汉明权重</a>。</p><h3 id="Approach-1：除K取余法"><a href="#Approach-1：除K取余法" class="headerlink" title="Approach 1：除K取余法"></a>Approach 1：除K取余法</h3><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>除K取余法，利用 <code>num%2</code> 和 <code>num/2</code> 不断取出数字的二进制数值。</li><li>需要注意的是，在如Java语言中，不能使用 <code>while(num&gt;0)</code> 进行判断。因为Java编译器使用二进制补码记法来表示有符号整数。例如输入 <code>11111111111111111111111111111101</code>， 会被作为 <code>-3</code> 处理。</li><li>因此，在Java中应该避免取模和除法操作，使用 <code>(num&amp;1) == 1</code> 代替 <code>num%2</code>；使用无符号右移 <code>num &gt;&gt;&gt; 1</code> 代替 <code>num/2</code>。</li><li>在C++中，若使用无符号类型 <code>uint32_t</code> 作为输入类型，可以直接使用 <code>while(num&gt;0)</code> 作为循环判断。</li></ul><blockquote><p>Java 中，<code>&gt;&gt;&gt;</code> 为无符号右移，<code>&gt;&gt;</code> 为有符号右移。</p></blockquote><ul><li>时间复杂度：<code>O(1)</code>。运行时间依赖于数字 <code>n</code> 的位数。本题中是一个32位数字，因此时间复杂度位为 <code>O(1)</code>。</li><li>空间复杂度：<code>O(1)</code>，没有使用额外的空间。</li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123; <span class="comment">//输入类型为无符号类型，因此可以直接使用n&gt;0进行判断</span></span><br><span class="line">            total += n%<span class="number">2</span>;</span><br><span class="line">            n /=<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//  n = n &gt;&gt;1; //也可使用移位操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Java</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hammingWeight(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                total++; <span class="comment">//不要使用取模操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//会有负数情况，因此应该使用无符号右移</span></span><br><span class="line">            <span class="comment">//Java 中，`&gt;&gt;&gt;` 为无符号右移，`&gt;&gt;` 为有符号右移。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者采用如下实现</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> hammingWeight(<span class="built_in">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">int</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123; <span class="comment">//最大32位</span></span><br><span class="line">        <span class="keyword">if</span> ((n &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">            bits++;</span><br><span class="line">        &#125;</span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2：位操作小技巧-n-amp-n-1"><a href="#Approach-2：位操作小技巧-n-amp-n-1" class="headerlink" title="Approach 2：位操作小技巧 - n&amp;(n-1)"></a>Approach 2：位操作小技巧 - n&amp;(n-1)</h3><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><p>对前面的算法进行优化。</p><p>不再检查数字的每一个位，而是不断把数字最后一个 <code>1</code> 反转，并把计数加1。当数字变成 <code>0</code> 的时候偶，我们就知道它没有 <code>1</code> 的位了，此时返回计数。</p><p>这里关键的想法是<strong>对于任意数字 <code>n</code> ，将 <code>n</code> 和 <code>n - 1</code> 做与运算，不断循环，最后一定会把 <code>1</code> 的位变成 <code>0</code>。</strong></p><p>为什么？考虑 <code>n</code> 和 <code>n - 1</code> 的二进制表示。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/leetcode-191-method-1.png" alt=""></p><p><strong>在二进制表示中，数字 <code>n</code> 中最低位的 <code>1</code> 总是对应 <code>n - 1</code> 中的 <code>0</code>。因此，将 <code>n</code> 和 <code>n - 1</code> 与运算总是能把 <code>n</code> 中最低位的 <code>1</code> 变成 <code>0</code> ，并保持其他位不变。</strong></p><p>使用这个小技巧，代码变得非常简单。</p><ul><li>时间复杂度：<code>O(1)</code>。运行时间依赖于数字 <code>n</code> 的位数。本题中是一个32位数字，因此时间复杂度位为 <code>O(1)</code>。</li><li>空间复杂度：<code>O(1)</code>，没有使用额外的空间。</li></ul><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><ul><li>Java</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> hammingWeight(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">            n = n&amp;(n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-3：字符串长度-正则匹配"><a href="#Approach-3：字符串长度-正则匹配" class="headerlink" title="Approach 3：字符串长度+正则匹配"></a>Approach 3：字符串长度+正则匹配</h3><h4 id="Analysic"><a href="#Analysic" class="headerlink" title="Analysic"></a>Analysic</h4><blockquote><p>JS中，<code>toString(radix)</code> 方法可以将数字转换为基于 <code>radix</code> 的进制数（若 <code>radix</code> 缺省，则默认转换为 10 进制数）。</p></blockquote><ul><li>首先，使用 <code>toString(2)</code> 方法，将数字转换为 2 进制字符串</li><li>然后，使用正则匹配，滤除字符串中的 <code>0</code>，得到新的字符串</li><li>最后，新字符串的长度即数字中 <code>1</code> 的个数</li></ul><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><ul><li>JS</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;number&#125; n - a positive integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n.toString(<span class="number">2</span>).replace(/<span class="number">0</span>/g,<span class="string">''</span>).length; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Approach-4：使用内置函数"><a href="#Approach-4：使用内置函数" class="headerlink" title="Approach 4：使用内置函数"></a>Approach 4：使用内置函数</h3><h4 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li><p>Java中，函数 <a href="https://www.tutorialspoint.com/java/lang/integer_bitcount.htm" target="_blank" rel="noopener">Integer.bitCount()</a> 可以返回数字中2进制格式下 <code>1</code> 的个数。</p><blockquote><p>The <code>java.lang.Integer.bitCount()</code> method returns the number of one-bits in the two’s complement binary representation of the specified int value i. This is sometimes referred to as the <code>population count</code>.</p></blockquote></li><li><p>类似的，C++内置的 <code>__builtin_popcount()</code> 函数也可以返回数字中2进制格式下 <code>1</code> 的个数。</p></li></ul><h4 id="Method-1"><a href="#Method-1" class="headerlink" title="Method"></a>Method</h4><ul><li>C++</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">Solution</span> &#123;</span><br><span class="line"><span class="attribute">public</span>:</span><br><span class="line">    int <span class="built_in">hammingWeight</span>(uint32_t n) &#123;</span><br><span class="line">       return <span class="built_in">__builtin_popcount</span>(n);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Java</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    public <span class="built_in">int</span> hamming<span class="constructor">Weight(<span class="params">int</span> <span class="params">n</span>)</span> &#123;</span><br><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>bit<span class="constructor">Count(<span class="params">n</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="338-Counting-Bits（比特位计数）"><a href="#338-Counting-Bits（比特位计数）" class="headerlink" title="338. Counting Bits（比特位计数）"></a>338. Counting Bits（比特位计数）</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode.com/problems/counting-bits/" target="_blank" rel="noopener">LeetCode-338. Counting Bits（比特位计数）</a></li></ul><h3 id="Approach-1-Pop-count"><a href="#Approach-1-Pop-count" class="headerlink" title="Approach 1-Pop count"></a>Approach 1-Pop count</h3><h4 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h4><p>本问题可以看做 <a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="noopener">LeetCode- 191. Number of 1 Bits</a> 的后续。</p><p><code>191. Number of 1 Bits</code> 问题中，计数了一个无符号整数的位，结果称为 <code>pop count</code>，或 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F/7110799?fr=aladdin" target="_blank" rel="noopener">汉明权重</a>。</p><p>现在，我们先默认这个概念。假设我们有函数 <code>int popcount(int x)</code>，可以返回一个给定非负整数的位计数。我们只需要在 <code>[0, num]</code> 范围内循环并将结果存到一个列表中。</p><ul><li>时间复杂度：<code>O(nk)</code>。对于每个整数 <code>x</code>，我们需要 <code>O(k)</code> 次操作，其中 <code>k</code> 是 <code>x</code> 的位数。</li><li>空间复杂度：<code>O(n)</code>。 </li></ul><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] countBits(<span class="built_in">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">int</span>[] ans = new <span class="built_in">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;= num;i++)&#123;</span><br><span class="line">            ans[i] = popCount(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> popCount(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            x = x&amp;(x<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; countBits(<span class="built_in">int</span> num) &#123;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; res(num+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;=num;i++)&#123;</span><br><span class="line">            res[i] = popCount(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> popCount(<span class="built_in">int</span> num)&#123;</span><br><span class="line">        <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            count ++;</span><br><span class="line">            num &amp;= num<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-动态规划-最高有效位"><a href="#Approach-2-动态规划-最高有效位" class="headerlink" title="Approach 2-动态规划+最高有效位"></a>Approach 2-动态规划+最高有效位</h3><h4 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h4><p>利用已有的计数结果来生成新的计数结果。</p><p>假设有一个整数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (1001011101)_2 = (605)_&#123;10&#125;</span><br></pre></td></tr></table></figure><p>我们已经计算了从 <code>0</code> 到 <code>x - 1</code> 的全部结果。</p><p>我们知道，<code>x</code> 与 我们计算过的一个数只有一位之差</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&apos; = (1011101)_2 = (93)_&#123;10&#125;</span><br></pre></td></tr></table></figure><p>它们只在最高有效位上不同。</p><p>让我们以二进制形式检查 <code>[0, 3]</code> 的范围</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(0) = (0)_2</span><br><span class="line"></span><br><span class="line">(1) = (1)_2</span><br><span class="line"></span><br><span class="line">(2) = (10)_2</span><br><span class="line"></span><br><span class="line">(3) = (11)_2</span><br><span class="line"></span><br><span class="line">(4) = (100)_2</span><br><span class="line"></span><br><span class="line">(5) = (101)_2</span><br></pre></td></tr></table></figure><p>可以看出， <code>2</code> 和 <code>3</code> 的二进制形式可以通过给 <code>0</code> 和 <code>1</code> 的二进制形式在前面加上 <code>1</code> 来得到。因此，它们的 <code>pop count</code> 只相差 1。</p><p>类似的，我们可以使用 <code>[0, 3]</code> 作为蓝本来得到 <code>[4, 7]</code>，使用 <code>[0, 7]</code> 作为蓝本来得到 <code>[8, 15]</code>，即根据区间 <code>[0, b)</code> 的结果去产生区间 <code>[b, 2b)</code> 的结果，其中 <code>b</code> 为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = 2^m &gt; x （m=0,1,2...）</span><br></pre></td></tr></table></figure><p>总之，对于 <code>pop count P(x)</code>，我们有以下的状态转移函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(x + b) = P(x) + 1, b = 2^m &gt; x （m=0,1,2...）</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：<code>O(n)</code>。对每个整数 <code>x</code>，只需要常数时间。</li><li>空间复杂度：<code>O(n)</code>。需要 <code>O(n)</code> 的空间来存储结果。</li></ul><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] countBits(<span class="built_in">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">int</span>[] res = new <span class="built_in">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">int</span> i=<span class="number">0</span>,b=<span class="number">1</span>; <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">while</span>(b&lt;=num)&#123;</span><br><span class="line">            <span class="comment">// generate [b, 2b) or [b, num) from [0, b)</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;b &amp;&amp; i+b &lt;= num)&#123;</span><br><span class="line">                res[i+b] = res[i]+<span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i = <span class="number">0</span>;   <span class="comment">// reset i</span></span><br><span class="line">            b &lt;&lt;= <span class="number">1</span>; <span class="comment">// b = 2b</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-3-动态规划-最低有效位"><a href="#Approach-3-动态规划-最低有效位" class="headerlink" title="Approach 3-动态规划+最低有效位"></a>Approach 3-动态规划+最低有效位</h3><h4 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h4><p>只要 <code>x&#39;</code> 小于 <code>x</code>，且它们的 <code>pop count</code> 之间存在函数关系，就可以写出状态转移函数。</p><p>遵循上一方法的相同原则，我们还可以通过最低有效位来获得状态转移函数。</p><p>观察 <code>x</code> 和 <code>x&#39; = x / 2</code> 的关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=(1001011101)_2=(605)_&#123;10&#125;</span><br><span class="line"></span><br><span class="line">x&apos; = (100101110)_2 = (302)_&#123;10&#125;</span><br></pre></td></tr></table></figure><p>可以发现 <code>x&#39;</code> 与 <code>x</code> 只有一位不同，这是因为 <code>x&#39;</code> 可以看做 <code>x</code> 移除最低有效位的结果。</p><p>这样，我们就有了下面的状态转移函数</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(<span class="name">x</span>) = P(<span class="name">x/2</span>) + (<span class="name">x</span> mod <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P(<span class="number">0</span>) = <span class="number">0</span>;            <span class="comment">//00   边界条件</span></span><br><span class="line">P(<span class="number">1</span>) = P(<span class="number">0</span>) + <span class="number">1</span>;     <span class="comment">//001   000</span></span><br><span class="line">P(<span class="number">2</span>) = P(<span class="number">1</span>) + <span class="number">0</span>;     <span class="comment">//010   001</span></span><br><span class="line">P(<span class="number">3</span>) = P(<span class="number">1</span>) + <span class="number">1</span>;     <span class="comment">//011   001</span></span><br><span class="line">P(<span class="number">4</span>) = P(<span class="number">2</span>) + <span class="number">0</span>;     <span class="comment">//100   010 </span></span><br><span class="line">P(<span class="number">5</span>) = P(<span class="number">2</span>) + <span class="number">1</span>;     <span class="comment">//101   010</span></span><br><span class="line">P(<span class="number">6</span>) = P(<span class="number">3</span>) + <span class="number">1</span>;     <span class="comment">//110   011</span></span><br></pre></td></tr></table></figure><h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] countBits(<span class="built_in">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">int</span>[] res = new <span class="built_in">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;=num;i++)&#123;</span><br><span class="line">            res[i] = res[i/<span class="number">2</span>] + (i%<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="409-Longest-Palindrome（最长回文串）"><a href="#409-Longest-Palindrome（最长回文串）" class="headerlink" title="409. Longest Palindrome（最长回文串）"></a>409. Longest Palindrome（最长回文串）</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode.com/problems/longest-palindrome/" target="_blank" rel="noopener">LeetCode-409. Longest Palindrome （最长回文串）</a></li></ul><h3 id="Approach-1-Map计数"><a href="#Approach-1-Map计数" class="headerlink" title="Approach 1-Map计数"></a>Approach 1-Map计数</h3><h4 id="Analysis-6"><a href="#Analysis-6" class="headerlink" title="Analysis"></a>Analysis</h4><p>使用 <code>Map</code> 数据结构统计每个字符串出现的次数。遍历 <code>Map</code> 字典，回文串长度增加 <code>2*(map[i]/2)</code>。同时，对出现次数对2取模，若为1，表示回文串中有出现单次的字符，设置标志位 <code>hasSingle = true</code>，最后记得对出现次数加1。</p><ul><li>时间复杂度： <code>O(n)</code>，<code>n</code>为字符串的长度，至少遍历每个字符一次。</li><li>空间复杂度： <code>O(1)</code>，需要开辟额外空间来计数，字母最多为26个。</li></ul><h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><ul><li>C++</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> longestPalindrome(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        map&lt;char,<span class="built_in">int</span>&gt; dataInfo;</span><br><span class="line">        <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">bool</span> hasSingel = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            dataInfo[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;dataInfo.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dataInfo[i]%<span class="number">2</span> !=<span class="number">0</span>)&#123;</span><br><span class="line">                hasSingel = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count += <span class="number">2</span>*(dataInfo[i]/<span class="number">2</span>);   <span class="comment">//处理 'CCC'情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        count = hasSingel? count+<span class="number">1</span>:count;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Java</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> longestPalindrome(String s) &#123;</span><br><span class="line">        char[] chas = s.toCharArray();</span><br><span class="line">        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; chas.length; i++) &#123;</span><br><span class="line">            map.put(chas[i], map.getOrDefault(chas[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> cnt : map.values()) &#123;</span><br><span class="line">            result += cnt / <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; result % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="223-Rectangle-Area（矩形面积）"><a href="#223-Rectangle-Area（矩形面积）" class="headerlink" title="223. Rectangle Area（矩形面积）"></a>223. Rectangle Area（矩形面积）</h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode.com/problems/rectangle-area/?tab=Description" target="_blank" rel="noopener">LeetCode-223. Rectangle Area（矩形面积）</a></li></ul><h3 id="Approach-1-面积拆分求解"><a href="#Approach-1-面积拆分求解" class="headerlink" title="Approach 1-面积拆分求解"></a>Approach 1-面积拆分求解</h3><h4 id="Analysis-7"><a href="#Analysis-7" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>根据上图，可以确定计算的面积值为两个矩形面积的和再减去重合部分的面积，即 <code>resultArea = recArea1 + recArea2 - repetitionArea</code></li><li>重合部分定点坐标的确定<ul><li>Bottom Left Point Coordinate: <code>(max(A,E), max(B,F))</code></li><li>Top Right Point Coordinate: <code>(min(C,G), min(D,H))</code></li></ul></li><li>易忽略点<blockquote><p>Due to the total bits of “int” is 32, we prefer to use “w2&lt;=w1” to “(int) w2-w1” to judge the return value. The data of ”(int) w2-w1” may overflow the range of integer.(For example, w2&gt;0 and w1&lt;0)</p></blockquote></li></ul><h4 id="Slove"><a href="#Slove" class="headerlink" title="Slove"></a>Slove</h4><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">computeArea</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> D, <span class="keyword">int</span> E, <span class="keyword">int</span> F, <span class="keyword">int</span> G, <span class="keyword">int</span> H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> area_1 = (C - A)*(D - B);</span><br><span class="line"><span class="keyword">int</span> area_2 = (G - E)*(H - F);</span><br><span class="line"><span class="comment">//Calculate the overlap area</span></span><br><span class="line"><span class="keyword">int</span> w1 = max(A, E);</span><br><span class="line"><span class="keyword">int</span> h1 = max(B, F);</span><br><span class="line"><span class="keyword">int</span> w2 = min(C, G);</span><br><span class="line"><span class="keyword">int</span> h2 = min(D, H);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((w2&lt;=w1) || (h2&lt;=h1)) <span class="comment">//没有重合部分</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> area_1 + area_2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> area_1 + area_2 - ((h2-h1)*(w2-w1));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在计算过程上进行优化，有如下代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">computeArea</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> D, <span class="keyword">int</span> E, <span class="keyword">int</span> F, <span class="keyword">int</span> G, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = max(A,E), right = max(min(C,G), left);</span><br><span class="line">        <span class="keyword">int</span> bottom = max(B,F), top = max(min(D,H), bottom);</span><br><span class="line">        <span class="keyword">return</span> (C-A)*(D-B) - (right-left)*(top-bottom) + (G-E)*(H-F);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>JS</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> computeArea = <span class="function"><span class="keyword">function</span>(<span class="params">A, B, C, D, E, F, G, H</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="built_in">Math</span>.max(A,E), right = <span class="built_in">Math</span>.max(<span class="built_in">Math</span>.min(C,G), left);</span><br><span class="line">    <span class="keyword">var</span> bottom = <span class="built_in">Math</span>.max(B,F), top = <span class="built_in">Math</span>.max(<span class="built_in">Math</span>.min(D,H), bottom);</span><br><span class="line">    <span class="keyword">return</span> (C-A)*(D-B) - (right-left)*(top-bottom) + (G-E)*(H-F);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeArea</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> D, <span class="keyword">int</span> E, <span class="keyword">int</span> F, <span class="keyword">int</span> G, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = Math.max(A,E), right = Math.max(Math.min(C,G), left);</span><br><span class="line">        <span class="keyword">int</span> bottom = Math.max(B,F), top = Math.max(Math.min(D,H), bottom);</span><br><span class="line">        <span class="keyword">return</span> (C-A)*(D-B) - (right-left)*(top-bottom) + (G-E)*(H-F);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="476-Number-Complement-数字的补数"><a href="#476-Number-Complement-数字的补数" class="headerlink" title="476. Number Complement (数字的补数)"></a>476. Number Complement (数字的补数)</h2><h3 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode.com/problems/number-complement/" target="_blank" rel="noopener">LeetCode-476. Number Complement (数字的补数)</a></li></ul><p>给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。</p><p>注意</p><pre><code>1. 给定的整数保证在32位带符号整数的范围内。2. 你可以假定二进制数不包含前导零位。</code></pre><p>示例 1</p><pre><code>输入: 5输出: 2解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。</code></pre><p>示例 2</p><pre><code>输入: 1输出: 0解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。</code></pre><h3 id="Approach-1-寻找最高位为1的位置"><a href="#Approach-1-寻找最高位为1的位置" class="headerlink" title="Approach 1-寻找最高位为1的位置"></a>Approach 1-寻找最高位为1的位置</h3><h4 id="Analysis-8"><a href="#Analysis-8" class="headerlink" title="Analysis"></a>Analysis</h4><p>分析题目可知，只需对每个位的二进制数值（没有前导零位时）进行翻转即可。</p><p>但数值实际存储中，是包含前导零位的。如果直接对 num 进行取反操作，会把符号位取反，并且把最高位为 1 之前的所有位数都取反。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不含前导零位时，<span class="number">5</span> = <span class="number">101</span>，取反操作得到<span class="number">010</span>，即十进制数值<span class="number">2</span></span><br><span class="line">含有前导零位时（次数以<span class="number">8</span>位为例），<span class="number">5</span> = <span class="number">0000</span>,<span class="number">0101</span>，取反操作得到<span class="number">1111</span>,<span class="number">1010</span></span><br></pre></td></tr></table></figure><p>因此，对每位翻转（或取反，或和1进行异或）的起始位置是从最高位的1开始的，前面的 0 是不能被翻转的。可以考虑从高位往低位遍历，当遇到第1个1后，记录最高位为1的位置，之后再进行翻转操作（异或实现）。</p><h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">0</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">int</span> highestOneBit = <span class="number">0</span>; <span class="comment">//最高位1的位数</span></span><br><span class="line">        <span class="keyword">int</span> tmp = num;</span><br><span class="line">        <span class="keyword">while</span>(tmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            highestOneBit += <span class="number">1</span>;</span><br><span class="line">            tmp &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=highestOneBit<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            num = num ^(<span class="number">1</span>&lt;&lt;i);  <span class="comment">//异或操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-创建每位都是1的二进制数值"><a href="#Approach-2-创建每位都是1的二进制数值" class="headerlink" title="Approach 2-创建每位都是1的二进制数值"></a>Approach 2-创建每位都是1的二进制数值</h3><h4 id="Analysis-9"><a href="#Analysis-9" class="headerlink" title="Analysis"></a>Analysis</h4><p>在不含前导零位时，把 <code>num</code> 和同位数的且每位都是1的二进制数进行与操作，即可得到结果。</p><p>因此，问题转化为求解一个和 <code>num</code> 位数一样且每位都是1的二进制数值 <code>mask</code>，最后进行异或操作（<code>mask ^ num</code>）即可。</p><p>例如，<code>5 = 101</code>，因此 <code>mask = 111</code>，进行异或操作 <code>mask ^ num = 111 ^ 101 = 010</code>。</p><p>得到每位都是1的二进制，如 <code>111</code>，可以通过<code>1000</code> 减去 1 得到。</p><h4 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = num;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mask -= <span class="number">1</span>;   <span class="comment">//1000-1 得到111</span></span><br><span class="line">        <span class="keyword">return</span> mask ^ num;  <span class="comment">//异或</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-3-转换为字符串-正则匹配"><a href="#Approach-3-转换为字符串-正则匹配" class="headerlink" title="Approach 3-转换为字符串+正则匹配"></a>Approach 3-转换为字符串+正则匹配</h3><h4 id="Analysis-10"><a href="#Analysis-10" class="headerlink" title="Analysis"></a>Analysis</h4><p>此处给出JS实现的特解</p><ol><li>先将 num 转化为二进制字符串</li><li>借助正则表达式查找，将字符串中的 0 替换成1</li><li>再将该字符串值转化成整数 <code>int</code></li><li>最后将该值和 <code>num</code>进行异或操作</li></ol><h4 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h4><ul><li>JS</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findComplement = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = num.toString(<span class="number">2</span>).replace(<span class="regexp">/0/g</span>,<span class="number">1</span>);  <span class="comment">//转换为11..11</span></span><br><span class="line">    <span class="keyword">return</span> (num) ^ <span class="built_in">parseInt</span>(str,<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录LeetCode题目笔记，汇总LeetCode解答记录&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://lbs0912.github.io/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-004</title>
    <link href="https://lbs0912.github.io/2020/02/23/leetcode-004/"/>
    <id>https://lbs0912.github.io/2020/02/23/leetcode-004/</id>
    <published>2020-02-23T06:35:26.000Z</published>
    <updated>2020-05-16T15:11:36.761Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录LeetCode题目笔记，汇总LeetCode解答记录</li></ul><a id="more"></a><h2 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h2><ul><li>2020/02/23，撰写</li><li>2020/02/23，整理完成</li></ul><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li><a href="https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/" target="_blank" rel="noopener">LeetCode-1342. Number of Steps to Reduce a Number to Zero（将数字变成 0 的操作次数）</a></li><li><a href="https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/" target="_blank" rel="noopener">LeetCode-1281. 整数的各位积和之差</a></li><li><a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">LeetCode-326. 3的幂</a></li><li><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">LeetCode-231. 2的幂</a></li><li><a href="https://leetcode-cn.com/problems/power-of-four/" target="_blank" rel="noopener">LeetCode-342. 4的幂</a></li></ul><h2 id="1342-Number-of-Steps-to-Reduce-a-Number-to-Zero（将数字变成-0-的操作次数）"><a href="#1342-Number-of-Steps-to-Reduce-a-Number-to-Zero（将数字变成-0-的操作次数）" class="headerlink" title="1342. Number of Steps to Reduce a Number to Zero（将数字变成 0 的操作次数）"></a>1342. Number of Steps to Reduce a Number to Zero（将数字变成 0 的操作次数）</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/" target="_blank" rel="noopener">LeetCode-1342. Number of Steps to Reduce a Number to Zero（将数字变成 0 的操作次数）</a></li></ul><h3 id="Approach-1"><a href="#Approach-1" class="headerlink" title="Approach 1"></a>Approach 1</h3><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><p>题目较为简单，直接求解即可，不再赘述。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSteps</span> <span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">            num = (num%<span class="number">2</span> == <span class="number">0</span>) ? num&gt;&gt;<span class="number">1</span>:num-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1281-整数的各位积和之差"><a href="#1281-整数的各位积和之差" class="headerlink" title="1281. 整数的各位积和之差"></a>1281. 整数的各位积和之差</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/" target="_blank" rel="noopener">LeetCode-1281. 整数的各位积和之差</a></li></ul><h3 id="Approach-1-1"><a href="#Approach-1-1" class="headerlink" title="Approach 1"></a>Approach 1</h3><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><p>题目较为简单，直接求解即可，不再赘述。</p><p>通过取模运算得到数字 <code>n</code> 的最后一位，依次进行乘法和加法运算。</p><ul><li>时间复杂度：<code>O(log N)</code>。整数 N 的位数如下公式所示。根据换底公式，它和时间复杂度中常用的以 2 为底的 <code>log</code> 只相差一个常数，因此时间复杂度可以表示为 <code>O(log N)</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">⌈log10(N+1)⌉</span><br></pre></td></tr></table></figure><ul><li>空间复杂度：<code>O(1)</code></li></ul><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> subtractProductAndSum(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">int</span> mul = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            mul *= n%<span class="number">10</span>;</span><br><span class="line">            add += n%<span class="number">10</span>;</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mul-add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326. 3的幂"></a>326. 3的幂</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">LeetCode-326. 3的幂</a></li></ul><h3 id="Approach-1-循环迭代"><a href="#Approach-1-循环迭代" class="headerlink" title="Approach 1-循环迭代"></a>Approach 1-循环迭代</h3><h4 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h4><p>常规基本方法，使用循环求解。</p><p>如果数字 <code>num</code> 是3的幂，则对 <code>num</code> 不断除3，并对3取模都是0，直到 <code>num=1</code> 停止。</p><p>需要注意，1是3的0次幂，在判断时候不要忘记对1的处理。</p><ul><li>时间复杂度：如下，<code>b</code> 表示进制基数，此处为3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(log_&#123;b&#125;(N))</span><br></pre></td></tr></table></figure><ul><li>空间复杂度：<code>O(1)</code></li></ul><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;  <span class="comment">//1是3的0次幂</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span> &amp;&amp; n != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//1是3的0次幂</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">3</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = n/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-基准转换"><a href="#Approach-2-基准转换" class="headerlink" title="Approach 2-基准转换"></a>Approach 2-基准转换</h3><h4 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h4><p>对于10的次幂，其10进制格式为1，10，100，1000……</p><p>对于2的次幂，其2进制格式为1，10，100，1000……</p><p>类比可得，</p><p>对于3的次幂，其3进制格式为1，10，100，1000……</p><p>因此，对于给定的数字，如果其3进制格式可以表示为 <code>^10*$</code> （即以数字1开头，以0个或者多个0结尾），则该数字就是3的次幂。</p><ul><li>时间复杂度：如下，<code>b</code> 表示进制基数，此处为3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(log_&#123;b&#125;(N))</span><br></pre></td></tr></table></figure><ul><li>空间复杂度：如下，<code>b</code> 表示进制基数，此处为3。此处，我们使用2个附加变量，一个是正则表达式的字符串（常量大小），一个是以3为基数表示数字的字符串，大小为 <code>O(log3(N))</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(log_&#123;b&#125;(N))</span><br></pre></td></tr></table></figure><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><blockquote><p>Java 内置的 <code>Integer.toString(number,base)</code>可以将数字转换为 <code>base</code> 进制的字符串</p><p>Java 内置的 <code>matches</code> 方法可以用于正则匹配</p></blockquote><p>本方法中，使用Java内置的字符串转换和正则匹配实现，相比于方法1的迭代求解，内存消耗方面两种方法基本一样，但是该方法的执行用时（37ms）是大于迭代求解的（17ms）。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public boolean is<span class="constructor">PowerOfThree(<span class="params">int</span> <span class="params">n</span>)</span> &#123;</span><br><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">n</span>, 3)</span>.matches(<span class="string">"^10*$"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-3-换底公式"><a href="#Approach-3-换底公式" class="headerlink" title="Approach 3-换底公式"></a>Approach 3-换底公式</h3><h4 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n=3^i</span><br><span class="line"></span><br><span class="line">i = log_&#123;3&#125;(n) = log_&#123;b&#125;(n)/log_&#123;b&#125;(3)</span><br></pre></td></tr></table></figure><p>如果 n 是3的次幂，即可以表示为 <code>3^i</code>的形式。如上所示，可以根据换底公式求解出 <code>i</code>。</p><p>因此若 <code>i</code> 是整数，则可以判断 n 是3的次幂。</p><ul><li>时间复杂度：<code>Unknown</code>。消耗时间的运算主要是 <code>Math.log</code>，它限制了我们算法的时间复杂性。实现依赖于我们使用的语言和编译器。</li><li>空间复杂度： <code>O(1)</code>。没有使用任何额外的内存。<code>epsilon</code> 变量可以是内联的。</li></ul><p><strong>需要注意的是，这个解决方案是有问题的，因为如果数值类型为 <code>double</code>，这意味着我们会遇到精度错误，在比较双精度数时不应使用 <code>==</code>。</strong></p><p>这是因为 <code>Math.log10(n)/Math.log10(3)</code> 的结果可能是 <code>5.0000001</code> 或 <code>4.9999999</code>。使用 <code>Math.log()</code> 函数而不是 <code>Math.log10()</code> 可以观察到这种效果。</p><p>为了解决这个问题，我们需要将结果与 <code>epsilon</code> 进行比较。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (Math.<span class="built_in">log</span>(n) / Math.<span class="built_in">log</span>(<span class="number">3</span>) + <span class="built_in">epsilon</span>) % <span class="number">1</span> &lt;= <span class="number">2</span> * <span class="built_in">epsilon</span>;</span><br></pre></td></tr></table></figure><h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Math.log10(n) / Math.log10(<span class="number">3</span>)) % <span class="number">1</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-4-整数限制"><a href="#Approach-4-整数限制" class="headerlink" title="Approach 4-整数限制"></a>Approach 4-整数限制</h3><h4 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h4><p>题目限定了输入数值为 <code>int</code> 类型，最大为32位，因此输入数值的最大值为 <code>2^31</code>，在此范围内3的最大次幂为 <code>3^19=1162261467</code>。</p><ul><li>因此，本题中可能返回 <code>true</code> 的数值只能是 <code>3^0</code>，<code>3^1</code> …… <code>3^19</code></li><li>如果使用 <code>3^19</code> 除以数值 <code>n</code>，若余数为0，则表示数值 <code>n</code>是3的次幂</li><li>需要注意的是，这种方式只适合基数为质数的情况。此处，3为质数，<code>3^19</code> 的约数字只有 <code>3^0</code>，<code>3^1</code> …… <code>3^19</code>。如果对于基数为偶数的情况，如 <code>4</code>，<code>4^4</code>的约数除了 <code>4^0</code>，<code>4^1</code>，<code>4^2</code>，<code>4^3</code>，<code>4^4</code>外，还有数字 <code>2</code>。</li></ul><h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((n &gt; <span class="number">0</span>) &amp;&amp; ((<span class="number">1162261467</span> % n) == <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">        <span class="comment">//return (n&gt;0) &amp;&amp; (Math.pow(3,19) % n ==0);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231. 2的幂"></a>231. 2的幂</h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">LeetCode-231. 2的幂</a></li></ul><p>本题同 <a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">LeetCode-326. 3的幂</a>，对于相同的原理，此处不再赘述。</p><p>此处仅补充 <code>Approach 5-二进制位运算</code> 特解方法。</p><h3 id="Approach-1-循环迭代-1"><a href="#Approach-1-循环迭代-1" class="headerlink" title="Approach 1-循环迭代"></a>Approach 1-循环迭代</h3><ul><li>Java</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>ean isPowerOfTwo(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;  <span class="comment">//1是2的0次幂</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-基准转换-1"><a href="#Approach-2-基准转换-1" class="headerlink" title="Approach 2-基准转换"></a>Approach 2-基准转换</h3><ul><li>Java</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public boolean is<span class="constructor">PowerOfTwo(<span class="params">int</span> <span class="params">n</span>)</span> &#123;</span><br><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">n</span>, 2)</span>.matches(<span class="string">"^10*$"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-3-换底公式-1"><a href="#Approach-3-换底公式-1" class="headerlink" title="Approach 3-换底公式"></a>Approach 3-换底公式</h3><ul><li>Java</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>ean isPowerOfTwo(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> (Math.log10(n) / Math.log10(<span class="number">2</span>)) % <span class="number">1</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-4-整数限制-1"><a href="#Approach-4-整数限制-1" class="headerlink" title="Approach 4-整数限制"></a>Approach 4-整数限制</h3><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (n&gt;<span class="number">0</span>) &amp;&amp; (Math.pow(<span class="number">2</span>,<span class="number">32</span>) % n ==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-5-二进制位运算（特解）"><a href="#Approach-5-二进制位运算（特解）" class="headerlink" title="Approach 5-二进制位运算（特解）"></a>Approach 5-二进制位运算（特解）</h3><h4 id="Analysis-6"><a href="#Analysis-6" class="headerlink" title="Analysis"></a>Analysis</h4><p>若 <code>num</code> 是 2 的整数幂，则其二进制数值为 <code>100..00</code> 的形式，<code>num-1</code> 的二进制数值为 <code>011...1</code> 的形式。因此，<code>n &amp; (n-1)</code> 一定为0。利用该方法可以求解。</p><p>需要注意的是，该方法使用了位运算，因此只适用于2的次幂求解，不具有通用性。</p><h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>ean isPowerOfTwo(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> (n&gt;<span class="number">0</span>) &amp;&amp; ((n &amp; (n<span class="number">-1</span>)) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (n&gt;<span class="number">0</span>) &amp;&amp; ((n &amp; (n<span class="number">-1</span>)) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="342-4的幂"><a href="#342-4的幂" class="headerlink" title="342. 4的幂"></a>342. 4的幂</h2><h3 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode-cn.com/problems/power-of-four/" target="_blank" rel="noopener">LeetCode-342. 4的幂</a></li></ul><p>本题同 <a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">LeetCode-326. 3的幂</a>，对于相同的原理，此处不再赘述。</p><p>该方法只适合基数为质数的情况。此处，3为质数，<code>3^19</code> 的约数字只有 <code>3^0</code>，<code>3^1</code> …… <code>3^19</code>。如果对于基数为偶数的情况，如 <code>4</code>，<code>4^4</code>的约数除了 <code>4^0</code>，<code>4^1</code>，<code>4^2</code>，<code>4^3</code>，<code>4^4</code>外，还有数字 <code>2</code> 和数字 <code>8</code> 等。</p><h3 id="Approach-1-循环迭代-2"><a href="#Approach-1-循环迭代-2" class="headerlink" title="Approach 1-循环迭代"></a>Approach 1-循环迭代</h3><ul><li>Java</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>ean isPowerOfFour(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;  <span class="comment">//1是2的0次幂</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-基准转换-2"><a href="#Approach-2-基准转换-2" class="headerlink" title="Approach 2-基准转换"></a>Approach 2-基准转换</h3><ul><li>Java</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public boolean is<span class="constructor">PowerOfFour(<span class="params">int</span> <span class="params">n</span>)</span> &#123;</span><br><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">n</span>, 4)</span>.matches(<span class="string">"^10*$"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-3-换底公式-2"><a href="#Approach-3-换底公式-2" class="headerlink" title="Approach 3-换底公式"></a>Approach 3-换底公式</h3><ul><li>Java</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>ean isPowerOfFour(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> (Math.log10(n) / Math.log10(<span class="number">4</span>)) % <span class="number">1</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录LeetCode题目笔记，汇总LeetCode解答记录&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://lbs0912.github.io/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-002</title>
    <link href="https://lbs0912.github.io/2020/02/23/leetcode-002/"/>
    <id>https://lbs0912.github.io/2020/02/23/leetcode-002/</id>
    <published>2020-02-23T02:35:26.000Z</published>
    <updated>2020-02-23T08:48:04.365Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录LeetCode题目笔记，汇总LeetCode解答记录</li></ul><a id="more"></a><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">LeetCode-206. Reverse Linked List（反转链表）</a> - 链表操作</li><li><a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">LeetCode-617. Merge Two Binary Trees</a> - 二叉树</li><li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">LeetCode-104. Maximum Depth of Binary Tree（二叉树的最大深度）</a> - 遍历二叉树</li><li><a href="https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/" target="_blank" rel="noopener">LeetCode-1290. Convert Binary Number in a Linked List to Integer（二进制链表转整数）</a></li><li><a href="https://leetcode.com/problems/to-lower-case/" target="_blank" rel="noopener">LeetCode-709. To Lower Case（转换成小写字母）</a></li></ul><h2 id="206-Reverse-Linked-List（反转链表）"><a href="#206-Reverse-Linked-List（反转链表）" class="headerlink" title="206. Reverse Linked List（反转链表）"></a>206. Reverse Linked List（反转链表）</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">LeetCode-206.Reverse Linked List（反转链表）</a></li></ul><h3 id="Approach-1-迭代"><a href="#Approach-1-迭代" class="headerlink" title="Approach 1-迭代"></a>Approach 1-迭代</h3><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>遍历列表，将当前节点的 <code>next</code> 指针改为指向前一个元素，实现对列表的反转。最后，返回新的头引用。</li><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode nextTemp = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *curr = head;</span><br><span class="line">        ListNode *prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode *tmpNext = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev= curr;</span><br><span class="line">            curr = tmpNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-递归"><a href="#Approach-2-递归" class="headerlink" title="Approach 2-递归"></a>Approach 2-递归</h3><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode/" target="_blank" rel="noopener">LeetCode-206.反转列表 | 官方题解</a></li><li>从递归角度分析该问题，假设列表的其余部分已经被反转，现考虑该如何反转</li><li>对于列表，假设其 $[n_{k-1},n_{m}]$ 部分已完成反转，当前对节点 $n_{k}$ 进行操作，使得 $n_{k+1}$ 的下一个节点指向 $n_{k}$，即 $n_{k}.next.next = n_{k}$。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">n_&#123;1&#125;\rightarrow ... \rightarrow n_&#123;k-1&#125; \rightarrow n_&#123;k&#125; \rightarrow n_&#123;k+1&#125; \leftarrow ... \leftarrow n_&#123;m&#125; \leftarrow null</span><br></pre></td></tr></table></figure><ul><li>需要小心的是节点 $n_{1}$ 的 <code>next</code> 指针需要指向 <code>null</code>。若忽略了这一点，链表中可能会产生循环。（使用大小为 2 的链表测试，可能会捕获此错误）</li><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code>：由于使用递归，将会使用隐式栈空间，递归深度可能会达到 <code>n</code> 层</li></ul><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode reverseTmpList = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> reverseTmpList;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       &#125;</span><br><span class="line">        ListNode *reverseTmpList = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> reverseTmpList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="617-Merge-Two-Binary-Trees（合并二叉树）"><a href="#617-Merge-Two-Binary-Trees（合并二叉树）" class="headerlink" title="617. Merge Two Binary Trees（合并二叉树）"></a>617. Merge Two Binary Trees（合并二叉树）</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">LeetCode-617.Merge Two Binary Trees（合并二叉树）</a></li></ul><h3 id="Approach-1-递归"><a href="#Approach-1-递归" class="headerlink" title="Approach 1-递归"></a>Approach 1-递归</h3><h4 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>使用递归方法求解</li><li>时间复杂度：<code>O(m)</code> 。递归方法中，共有 <code>m</code> 个节点需要遍历（<code>m</code> 为给定的两个二叉树节点数目的最小值）</li><li>空间复杂度：<code>O(m)</code> 。递归栈的深度，最差情况下最大值可为 <code>m</code>。递归深度平均值为 <code>log(m)</code></li></ul><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span>(t2 == <span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        t1.val += t2.val;</span><br><span class="line">        t1.left = mergeTrees(t1.left,t2.left);</span><br><span class="line">        t1.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="104-Maximum-Depth-of-Binary-Tree（二叉树的最大深度）"><a href="#104-Maximum-Depth-of-Binary-Tree（二叉树的最大深度）" class="headerlink" title="104. Maximum Depth of Binary Tree（二叉树的最大深度）"></a>104. Maximum Depth of Binary Tree（二叉树的最大深度）</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">LeetCode-104. Maximum Depth of Binary Tree（二叉树的最大深度）</a></li></ul><h3 id="Approach-1-递归-1"><a href="#Approach-1-递归-1" class="headerlink" title="Approach 1-递归"></a>Approach 1-递归</h3><h4 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>使用递归方法求解</li><li>时间复杂度：<code>O(n)</code> ：每个节点均遍历一次，其中 <code>n</code> 为节点数</li><li>空间复杂度：<code>O(n)</code>：最糟糕情况下，树是完全不平衡的，例如每个节点只有左子节点，递归将被调用 <code>n</code> 次（树的高度），最差空间复杂度为 <code>O(n)</code>。最好情况下（树是完全平衡的），树的高度为 <code>log(n)</code></li><li>递归栈的深度，最差情况下最大值可为 <code>m</code>。递归深度平均值为 <code>log(n)</code>，此时空间复杂度是 <code>O(log(n))</code>。</li></ul><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">  public <span class="built_in">int</span> max<span class="constructor">Depth(TreeNode <span class="params">root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root<span class="operator"> == </span>null) &#123;</span><br><span class="line">      return <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">int</span> left_height = max<span class="constructor">Depth(<span class="params">root</span>.<span class="params">left</span>)</span>;</span><br><span class="line">      <span class="built_in">int</span> right_height = max<span class="constructor">Depth(<span class="params">root</span>.<span class="params">right</span>)</span>;</span><br><span class="line">      return java.lang.<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(left_height, right_height) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1290-Convert-Binary-Number-in-a-Linked-List-to-Integer（二进制链表转整数）"><a href="#1290-Convert-Binary-Number-in-a-Linked-List-to-Integer（二进制链表转整数）" class="headerlink" title="1290. Convert Binary Number in a Linked List to Integer（二进制链表转整数）"></a>1290. Convert Binary Number in a Linked List to Integer（二进制链表转整数）</h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/" target="_blank" rel="noopener">LeetCode-1290. Convert Binary Number in a Linked List to Integer（二进制链表转整数）</a></li></ul><h3 id="Approach-1-模拟二进制转十进制-位操作"><a href="#Approach-1-模拟二进制转十进制-位操作" class="headerlink" title="Approach 1-模拟二进制转十进制+位操作"></a>Approach 1-模拟二进制转十进制+位操作</h3><h4 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>由于链表中从高位到低位存放了数字的二进制表示，因此可以使用二进制转十进制的方法，在遍历一遍链表的同时，得到数字的十进制值。</li><li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是链表中的节点个数</li><li>空间复杂度：<code>O(1)</code></li></ul><p>需要注意的是，在求解过程中（如下）</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int<span class="built_in"> sum</span> = <span class="number">0</span>;</span><br><span class="line">while<span class="built_in">(head</span> != null)&#123;</span><br><span class="line">    //sum = <span class="number">2</span><span class="built_in">*sum</span> +<span class="built_in"> head</span>.val;</span><br><span class="line">   <span class="built_in"> sum</span> =<span class="built_in"> sum</span>&lt;&lt;<span class="number">1</span> |<span class="built_in"> head</span>.val;</span><br><span class="line">   <span class="built_in"> head</span> =<span class="built_in"> head</span>.<span class="keyword">next</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span><span class="built_in"> sum</span>;</span><br></pre></td></tr></table></figure><p>使用 <code>sum = 2*sum + head.val</code> 计算，乘法操作耗时是大于位操作的。因此，该步骤可优化为</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//<span class="built_in">sum</span> = <span class="number">2</span>*<span class="built_in">sum</span> + head.val;</span><br><span class="line"><span class="built_in">sum</span> = <span class="built_in">sum</span>&lt;&lt;<span class="number">1</span> | <span class="type">head</span>.val;</span><br></pre></td></tr></table></figure><blockquote><p>LeetCode平台，C++语言，使用乘法操作 <code>sum = 2*sum + head.val</code>，耗时4ms，内存消耗8.4M；使用位操作 <code>sum = sum&lt;&lt;1 | head.val;</code>，耗时0ms，内存消耗8.3M</p></blockquote><h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode <span class="keyword">next</span>;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int getDecimalValue(ListNode<span class="built_in"> head</span>) &#123;</span><br><span class="line">        int<span class="built_in"> sum</span> = <span class="number">0</span>;</span><br><span class="line">        while<span class="built_in">(head</span> != null)&#123;</span><br><span class="line">            //sum = <span class="number">2</span><span class="built_in">*sum</span> +<span class="built_in"> head</span>.val;</span><br><span class="line">           <span class="built_in"> sum</span> =<span class="built_in"> sum</span>&lt;&lt;<span class="number">1</span> |<span class="built_in"> head</span>.val;</span><br><span class="line">           <span class="built_in"> head</span> =<span class="built_in"> head</span>.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span><span class="built_in"> sum</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="type">Definition</span> <span class="keyword">for</span> singly-linked <span class="built_in">list</span>.</span><br><span class="line"> * <span class="keyword">struct</span> <span class="type">ListNode</span> &#123;</span><br><span class="line"> *     <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line"> *     <span class="type">ListNode</span> *next;</span><br><span class="line"> *     <span class="type">ListNode</span>(<span class="built_in">int</span> x) : <span class="keyword">val</span>(x), next(<span class="type">NULL</span>) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> getDecimalValue(<span class="type">ListNode</span>* head) &#123;</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            sum = sum&lt;&lt;<span class="number">1</span> | head-&gt;<span class="keyword">val</span>;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="709-To-Lower-Case（转换成小写字母）"><a href="#709-To-Lower-Case（转换成小写字母）" class="headerlink" title="709. To Lower Case（转换成小写字母）"></a>709. To Lower Case（转换成小写字母）</h2><h3 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode.com/problems/to-lower-case/" target="_blank" rel="noopener">LeetCode-709. To Lower Case（转换成小写字母）</a></li></ul><h3 id="Approach-1-ASCII编码转换"><a href="#Approach-1-ASCII编码转换" class="headerlink" title="Approach 1-ASCII编码转换"></a>Approach 1-ASCII编码转换</h3><h4 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>使用 ASCII 编码进行大小写字母转换。大写字母 <code>A~Z</code> 的 ASCII值为 <code>65~90</code>;小写字母 <code>a~z</code> 的 ASCII值为 <code>97~122</code>。小写字母 <code>a</code> 和大写字母 <code>A</code> 的 ASCII 码差值为 32。</li><li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是字符串长度</li><li>空间复杂度：<code>O(1)</code></li></ul><p>更进一步，观察大小写字母 ASCII 码的二进制</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A---<span class="number">-65</span>----<span class="number">-1000001</span></span><br><span class="line">a---<span class="number">-97</span>----<span class="number">-1100001</span></span><br></pre></td></tr></table></figure><p>因此，在大小转换时，可使用位运算，进行或操作</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c = (<span class="name">char</span>)(<span class="name">str</span>.charAt(<span class="name">i</span>) | (<span class="name">char</span>)(<span class="number">32</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public String <span class="keyword">to</span><span class="constructor">LowerCase(String <span class="params">str</span>)</span> &#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> <span class="constructor">StringBuilder()</span>;</span><br><span class="line">        for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;str.length<span class="literal">()</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">char</span> c = (<span class="built_in">char</span>)(str.<span class="built_in">char</span><span class="constructor">At(<span class="params">i</span>)</span> <span class="pattern-match">| (<span class="built_in">char</span>)(32));</span></span><br><span class="line"><span class="pattern-match">            res.append(c);</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">        return res.<span class="keyword">to</span><span class="constructor">String()</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure><p>上述方法，耗时0ms，内存34.2MB。如果使用Java内置的 <code>toLowerCase()</code> 方法，耗时0ms，内存34.1MB。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String toLowerCase(String <span class="keyword">str</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">str</span>.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string toLowerCase(string <span class="keyword">str</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">str</span>.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">str</span>[i] &gt;= <span class="string">'A'</span> &amp;&amp; <span class="keyword">str</span>[i] &lt;= <span class="string">'Z'</span>)&#123;</span><br><span class="line">                <span class="keyword">str</span>[i] += <span class="number">32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">str</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录LeetCode题目笔记，汇总LeetCode解答记录&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://lbs0912.github.io/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>动态规划经典题目整理</title>
    <link href="https://lbs0912.github.io/2020/02/22/algorithm-dp-1/"/>
    <id>https://lbs0912.github.io/2020/02/22/algorithm-dp-1/</id>
    <published>2020-02-22T06:25:26.000Z</published>
    <updated>2020-02-23T08:48:04.363Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录和汇总动态规划经典题目</li></ul><a id="more"></a><h2 id="买苹果"><a href="#买苹果" class="headerlink" title="买苹果"></a>买苹果</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://www.nowcoder.com/questionTerminal/61cfbb2e62104bc8aa3da5d44d38a6ef?toCommentId=449308" target="_blank" rel="noopener">动态规划-买苹果 | 牛客网</a></li><li>小易去附近的商店买苹果，奸诈的商贩使用了捆绑交易，只提供 6 个每袋和 8 个每袋的包装(包装不可拆分)。 可是小易现在只想购买恰好 <code>n</code> 个苹果，小易想购买尽量少的袋数方便携带。如果不能购买恰好 <code>n</code> 个苹果，小易将不会购买。</li><li>输入描述: 输入一个整数n，表示小易想购买 <code>n(1 ≤ n ≤ 100)</code> 个苹果</li><li>输出描述: 输出一个整数表示最少需要购买的袋数，如果不能买恰好 <code>n</code> 个苹果则输出 <code>-1</code></li><li>测试用例</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//input</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="Approach-1-动态规划（通解）"><a href="#Approach-1-动态规划（通解）" class="headerlink" title="Approach 1-动态规划（通解）"></a>Approach 1-动态规划（通解）</h3><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>采用动态规划方法求解。</li><li>创建一个 <code>vector</code> 容器 <code>steps</code>，<code>steps[i]</code> 表示购买 <code>i</code> 个苹果所需的最小袋数。</li><li>初始化为 <code>steps</code> 容器为 <code>INT_MAX</code>。</li><li>从购买1个苹果开始遍历，若 <code>steps[i]</code> 为 <code>INT_MAX</code>，表示无法购买该个数的苹果，直接开始下次循环。</li><li>若 <code>steps[i]</code> 不为 <code>INT_MAX</code>，表示该个数的苹果可以购买，进行动态规划求解。</li><li>动态规划的转移方程为</li></ul><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">steps<span class="string">[i+j]</span> = min(steps<span class="string">[i]</span>+<span class="number">1</span>,steps<span class="string">[i+j]</span>)   //j为<span class="number">6</span>或<span class="number">8</span></span><br><span class="line">steps<span class="string">[0]</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>动态规划的过程如下图所示</li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/nowcode-buy-apple-1.png" alt="nowcode-buy-apple-1.png"></p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amounts;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;amounts;</span><br><span class="line">    <span class="comment">//小于6情况处理</span></span><br><span class="line">    <span class="keyword">if</span>(amounts &lt; <span class="number">6</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; steps(amounts+<span class="number">1</span>,INT_MAX);</span><br><span class="line">    steps[<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">    steps[<span class="number">8</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">6</span>;i&lt;=amounts;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(steps[i] == INT_MAX)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">6</span> &lt;= amounts)&#123;</span><br><span class="line">                steps[i+<span class="number">6</span>] = min(steps[i]+<span class="number">1</span>,steps[i+<span class="number">6</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">8</span> &lt;= amounts)&#123;</span><br><span class="line">                steps[i+<span class="number">8</span>] = min(steps[i]+<span class="number">1</span>,steps[i+<span class="number">8</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    steps[amounts] = (steps[amounts] == INT_MAX)? <span class="number">-1</span>:steps[amounts];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;steps[amounts]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-贪婪算法"><a href="#Approach-2-贪婪算法" class="headerlink" title="Approach 2-贪婪算法"></a>Approach 2-贪婪算法</h3><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>采用贪婪算法求解。</li><li>优先选取每袋含有 8 个苹果的包装。若还有余数，则再用 6 个装的包装去购买。</li><li>如果不行的话，则将 8 个装的个数减去 1 个，进行回溯，再用 6 包装的去购买。</li><li>如果还不行的话，再次回溯，直到购买 8 包装的个数为 0。</li></ul><blockquote><p><strong>贪婪算法并不一定能得到最优解，但是一个可行的，较好的解。</strong> 例如，给定硬币 <code>coins=[1,2,10,25]</code>，金额总数 <code>amounts=30</code>，不限制每种币值的硬币数量，要求用所给硬币凑出所需金额，并且硬币数量最少。若采用贪婪算法求解，需要 6 枚（25+5*1）硬币。 若采用动态规划求解，所需 3 枚（10+10+10）硬币。</p></blockquote><p>下面对使用贪婪算法能否得到最优解进行分析。</p><ul><li>首先，6 和 8 都是偶数。因此，能凑出的个数也一定是偶数。程序中若苹果总数是奇数，可以直接返回 <code>-1</code>。</li><li>再次，偶数个苹果数对 8 取模，其结果只可能为 <code>0,2,4,6</code>。</li><li>若余数为 6 或者 0，则可以直接用 6 包装情况处理，不需要回溯购买 8 包装的情况。</li><li>若余数为 4，只需回溯 1 次即可，因为<code>8+4=12</code>, <code>12%6=0</code>。</li><li>若余数为 2，只需回溯 2 次即可，因为<code>8+8+2=18, 18%6=0</code>。</li></ul><p>综上，本题情况使用贪婪算法一定能得到最优解。</p><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><ul><li>C++</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> maxPackages(<span class="built_in">int</span> <span class="built_in">num</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> mul, remains;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">num</span>%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//非偶数直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">num</span> % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        res += <span class="built_in">num</span> / <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        mul = <span class="built_in">num</span> / <span class="number">8</span>;  <span class="comment">//倍数</span></span><br><span class="line">        remains = <span class="built_in">num</span> % <span class="number">8</span>;</span><br><span class="line">        res += mul;</span><br><span class="line">        <span class="built_in">num</span> = <span class="built_in">num</span> % <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">while</span> (mul &gt;= <span class="number">0</span>) &#123;  <span class="comment">//回溯8包装</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">num</span> % <span class="number">6</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                res += <span class="built_in">num</span> / <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                mul--;  <span class="comment">//回溯  8包装购买袋数-1</span></span><br><span class="line">                res--;</span><br><span class="line">                <span class="built_in">num</span> = <span class="built_in">num</span> + <span class="number">8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">num</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; <span class="built_in">num</span>) &#123;</span><br><span class="line">        cout &lt;&lt; maxPackages(<span class="built_in">num</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-3-数字分析求解"><a href="#Approach-3-数字分析求解" class="headerlink" title="Approach 3-数字分析求解"></a>Approach 3-数字分析求解</h3><h4 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>对数字特征进行分析。</li><li>首先，6 和 8 都是偶数。因此，<strong>能凑出的个数也一定是偶数。程序中若苹果总数是奇数，可以直接返回-1。</strong></li><li>再次，偶数个苹果数对 8 取模，其结果只可能为 <code>0,2,4,6</code>。</li><li>若余数为 6 或者 0，则可以直接用 6 包装情况处理，不需要回溯购买 8 包装的情况。</li><li>若余数为 4，只需回溯 1 次即可，因为 <code>8+4=12, 12%6=0</code>。</li><li>若余数为 2，只需回溯 2 次即可，因为 <code>8+8+2=18, 18%6=0</code>。</li></ul><p>综上，可以采用如下思路进行处理。（由于数字 6 和 8 的特征，本方法只适用于本题，不具有通用性，动态规划为本题通用解法）</p><ul><li>情况1：若 <code>num</code> 不是偶数，则直接返回 <code>-1</code></li><li>情况2：若 <code>num%8=0</code>，则返回 <code>num/8</code></li><li>情况3：若 <code>num%8 !=0</code>，则只需回溯 1 次或者 2 次 8 包装购买个数，就可以求解。<ul><li>回溯 1 次，其结果为 <code>n/8-1+2= n/8+1</code></li><li>回溯 2 次，其结果为 <code>n/8-2+3 = n/8+1</code></li><li>因此，可以情况3下，可以返回 <code>n/8+1</code></li></ul></li></ul><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; num) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num%<span class="number">8</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;num/<span class="number">8</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>+num/<span class="number">8</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳石板"><a href="#跳石板" class="headerlink" title="跳石板"></a>跳石板</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li><a href="https://www.nowcoder.com/questionTerminal/4284c8f466814870bae7799a07d49ec8" target="_blank" rel="noopener">跳石板 | 牛客网</a></li></ul><p>小易来到了一条石板路前，每块石板上从1挨着编号为：1、2、3…….</p><p>这条石板路要根据特殊的规则才能前进：对于小易当前所在的编号为K的石板，小易单次只能往前跳K的一个约数(不含1和K)步，即跳到K+X(X为K的一个非1和本身的约数)的位置。 小易当前处在编号为N的石板，他想跳到编号恰好为M的石板去，小易想知道最少需要跳跃几次可以到达。</p><ul><li>例如</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">4</span>，M = <span class="number">24</span>：</span><br><span class="line"><span class="number">4</span>-&gt;<span class="number">6</span>-&gt;<span class="number">8</span>-&gt;<span class="number">12</span>-&gt;<span class="number">18</span>-&gt;<span class="number">24</span></span><br></pre></td></tr></table></figure><p>于是小易最少需要跳跃5次，就可以从4号石板跳到24号石板。</p><ul><li>输入描述</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入为一行，有两个整数N，M，以空格隔开。 (<span class="number">4</span> ≤ N ≤ <span class="number">100000</span>) (N ≤ M ≤ <span class="number">100000</span>)</span><br></pre></td></tr></table></figure><ul><li>输出描述</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出小易最少需要跳跃的步数,如果不能到达输出<span class="number">-1</span></span><br></pre></td></tr></table></figure><ul><li>测试用例</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">4</span> <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="Approach-1-动态规划"><a href="#Approach-1-动态规划" class="headerlink" title="Approach 1-动态规划"></a>Approach 1-动态规划</h3><h4 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h4><p>采用动态规划思想求解。创建一个 <code>vector</code> 容器 <code>steps</code>，<code>steps[i]</code> 表示到达 i 号石板所需的最小步数。</p><ul><li>初始化为 <code>steps</code> 容器为 <code>INT_MAX</code>。</li><li>从序号 N 的石板开始逐个遍历，若 <code>steps[i]</code>为 <code>INT_MAX</code>，表示该点不可到达，直接开始下次循环。</li><li>若 <code>steps[i]</code> 不为 <code>INT_MAX</code>，表示该点可以到达。</li></ul><p>动态规划的转移方程为</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">steps<span class="string">[i]</span> = INT_MAX    //初始化所有值为INT_MAX</span><br><span class="line">//i为石板编号，j=<span class="number">1</span>,<span class="number">2</span>...M-<span class="number">1</span></span><br><span class="line">// 若j为i的约数，则 steps<span class="string">[i+j]</span> = steps<span class="string">[i]</span>+<span class="number">1</span></span><br><span class="line">steps<span class="string">[i+j]</span> = min(steps<span class="string">[i]</span>+<span class="number">1</span>,steps<span class="string">[i+j]</span>)   </span><br><span class="line">steps<span class="string">[N]</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><p>下面给出代码实现</p><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,M;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; steps(M+<span class="number">1</span>,INT_MAX);</span><br><span class="line">        steps[N] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=N;i&lt;=M;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(steps[i] == INT_MAX)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;(j*j)&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%j == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i+j &lt;= M)&#123;</span><br><span class="line">                        steps[i+j] = min(steps[i]+<span class="number">1</span>,steps[i+j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果j是约数，那么(i/j)也是约数</span></span><br><span class="line">                    <span class="keyword">if</span>(i+(i/j) &lt;= M)&#123;</span><br><span class="line">                        steps[i+(i/j)] = min(steps[i]+<span class="number">1</span>,steps[i+(i/j)]);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(steps[M] == INT_MAX)&#123;</span><br><span class="line">            steps[M] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;steps[M]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/nowcode-dp-demo2-1.png" alt=""></p><p>此处给出一个常规的优化项说明，上述代码在判断 <code>for</code> 循环时，限制循环终止条件为 <code>(j*j)&lt;=i</code>，对于大于 <code>sqrt(i)</code> 的约数，在同一个for循环中进行判断，即</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for(<span class="name">int</span> j=2<span class="comment">;(j*j)&lt;=i;j++)&#123;</span></span><br><span class="line">    if(<span class="name">i</span>%j == <span class="number">0</span>)&#123;</span><br><span class="line">        if(<span class="name">i+j</span> &lt;= M)&#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">        //如果j是约数，那么(<span class="name">i/j</span>)也是约数</span><br><span class="line">        if(<span class="name">i+</span>(<span class="name">i/j</span>) &lt;= M)&#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述可以明显减少for循环次数，针对<code>N=4，M=24</code>的情况，上述代码会执行10次循环。如果使用下述代码，将会执行15次代码（在牛客网系统上，会被当做超时处理）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int <span class="built_in">j</span>=<span class="number">2</span>;<span class="built_in">j</span>&lt;<span class="built_in">i</span>;<span class="built_in">j</span>++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">i</span><span class="comment">%j == 0)&#123;</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">i</span>+<span class="built_in">j</span> &lt;= M)&#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-贪婪算法-1"><a href="#Approach-2-贪婪算法-1" class="headerlink" title="Approach 2-贪婪算法"></a>Approach 2-贪婪算法</h3><h4 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h4><p>(本题目，使用贪婪算法并不能AC，此处给出的贪婪算法，仅作为一个示例给出，用于分析贪婪算法的使用场景)</p><p><strong>贪婪算法并不一定能得到最优解，但是一个可行的，较好的解。</strong></p><p>该问题若采用贪婪算法求解，并不会得到最优解，只会得到一个可行的，较好的解。例如，下述程序中采用了贪婪算法求解。每次都选取最大的约数前进一步。若后续发生不可到达目标点，则进行回溯，取第2大的约数作为步进值。<strong>下述程序通过率为80%，并不能AC。例如，对于N=676, M=12948情况，贪婪算法求解为13步，而动态规划算法求解为10步。</strong></p><p>贪婪算法并不一定能得到最优解，但是一个可行的，较好的解。例如，给定硬币coins=[1,2,10,25]，金额总数amounts=30，不限制每种币值的硬币数量，要求用所给硬币凑出所需金额，并且硬币数量最少。若采用贪婪算法求解，需要6枚（25+5*1）硬币。 若采用动态规划求解，所需3枚（10+10+10）硬币。 — 贪婪算法</p><h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序通过率为80%，并不能AC</span></span><br><span class="line"><span class="comment">//对于N=676, M=12948情况，贪婪算法求解为13步，而动态规划算法求解为10步。</span></span><br><span class="line"><span class="comment">// 贪婪算法并不一定能得到最优解，但是一个可行的，较好的解。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stepSearch</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &gt; M) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (N == M) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i*(N / i) == N) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span> (stepSearch(N + N/i, M) != <span class="number">-1</span>) &#123;</span><br><span class="line">                res += stepSearch(N + N/i, M);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; stepSearch(N, M) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录和汇总动态规划经典题目&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://lbs0912.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://lbs0912.github.io/tags/Algorithm/"/>
    
      <category term="DP" scheme="https://lbs0912.github.io/tags/DP/"/>
    
      <category term="动态规划" scheme="https://lbs0912.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-001</title>
    <link href="https://lbs0912.github.io/2020/02/22/leetcode-001/"/>
    <id>https://lbs0912.github.io/2020/02/22/leetcode-001/</id>
    <published>2020-02-22T02:35:26.000Z</published>
    <updated>2020-02-23T08:48:04.364Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录LeetCode题目笔记，汇总LeetCode解答记录</li></ul><a id="more"></a><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li><a href="https://leetcode.com/problems/linked-list-cycle/?tab=Description" target="_blank" rel="noopener">LeetCode-141. Linked List Cycle（环形链表）</a> - 环形链表</li><li><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCode-142. Linked List Cycle II（环形链表 II）</a> - 环形链表</li><li><a href="https://leetcode.com/problems/add-digits/?tab=Description" target="_blank" rel="noopener">LeetCode-258. Add Digits（各位相加）</a> - 数字推导（数字根）</li><li><a href="https://leetcode.com/problems/hamming-distance/" target="_blank" rel="noopener">LeetCode-461. Hamming Distance（汉明距离）</a> - 位运算</li><li><a href="https://leetcode.com/problems/island-perimeter/?tab=Description" target="_blank" rel="noopener">LeetCode-463. Island Perimeter（岛屿的周长）</a> - 常规计算</li></ul><h2 id="141-Linked-List-Cycle（环形链表）"><a href="#141-Linked-List-Cycle（环形链表）" class="headerlink" title="141. Linked List Cycle（环形链表）"></a>141. Linked List Cycle（环形链表）</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode.com/problems/linked-list-cycle/?tab=Description" target="_blank" rel="noopener">LeetCode - 141. Linked List Cycle（环形链表）</a></li></ul><h3 id="Approach-1-Hash-Table"><a href="#Approach-1-Hash-Table" class="headerlink" title="Approach 1-Hash Table"></a>Approach 1-Hash Table</h3><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>使用哈希表解决，时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(n)</code>。</li><li>遍历链表，若遇到 <code>Null</code>，则 表明链表无环。若遍历的节点在哈希表中已存在，则表明链表有环。</li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ul><li>JavaScript</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nodesSeen = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">if</span>(head === <span class="literal">null</span>  || head.next === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nodesSeen.has(head))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            nodesSeen.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    Set&lt;ListNode&gt; nodesSeen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodesSeen.contains(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodesSeen.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Approach-2-Two-Pointers"><a href="#Approach-2-Two-Pointers" class="headerlink" title="Approach 2-Two Pointers"></a>Approach 2-Two Pointers</h3><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>使用快慢指针解决，时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(1)</code>。</li><li>Use two pointers, walker and runner. </li><li>Walker moves step by step. </li><li>Runner moves two steps at time.</li><li>If the Linked List has a cycle walker and runner will meet at some point.</li><li>Ref <ul><li><a href="https://leetcode.com/problems/linked-list-cycle/solution/" target="_blank" rel="noopener">LeetCode Solution</a></li><li><a href="http://www.cnblogs.com/AndyJee/p/4463998.html" target="_blank" rel="noopener">LeetCode 141/142 - Linked List Cycle | CNBlogs</a></li></ul></li></ul><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *walker = head; <span class="comment">//moves one step each time</span></span><br><span class="line">        ListNode *runner = head; <span class="comment">//moves two step each time</span></span><br><span class="line">        <span class="keyword">while</span>(runner-&gt;next != <span class="literal">NULL</span> &amp;&amp; runner-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            walker = walker-&gt;next;</span><br><span class="line">            runner = runner-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(walker == runner)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>JavaScript</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> walker = <span class="keyword">new</span> ListNode();</span><br><span class="line">    <span class="keyword">var</span> runner = <span class="keyword">new</span> ListNode();</span><br><span class="line">    walker = head;</span><br><span class="line">    runner = head;</span><br><span class="line">    <span class="keyword">while</span>(runner.next!==<span class="literal">null</span> &amp;&amp; runner.next.next!==<span class="literal">null</span>) &#123;</span><br><span class="line">        walker = walker.next;</span><br><span class="line">        runner = runner.next.next;</span><br><span class="line">        <span class="keyword">if</span>(walker === runner) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Java </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Python</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.next == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="142-Linked-List-Cycle-II-（环形链表II）"><a href="#142-Linked-List-Cycle-II-（环形链表II）" class="headerlink" title="142. Linked List Cycle II （环形链表II）"></a>142. Linked List Cycle II （环形链表II）</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCode - 142. Linked List Cycle II（环形链表II）</a></li></ul><h3 id="Approach-1-Two-Pointers"><a href="#Approach-1-Two-Pointers" class="headerlink" title="Approach 1-Two Pointers"></a>Approach 1-Two Pointers</h3><h4 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h4><p><a href="https://leetcode.com/problems/linked-list-cycle/?tab=Description" target="_blank" rel="noopener">LeetCode-141. Linked List Cycle</a>  中，完成了链表是否有环的判断。在此基础上，本题实现对环起点的判断和环长度的计算。</p><p>下面结合 <a href="http://www.cnblogs.com/AndyJee/p/4463998.html" target="_blank" rel="noopener">LeetCode 141/142 - Linked List Cycle | CNBlogs</a> 参考链接，对环起点的判断和环长度的计算进行分析。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/front-end-2019/leetcode-142.png" alt="leetcode-142.png"></p><p>设链表起点距离环的起点距离为<code>a</code>，圈长为<code>n</code>，当 <code>walker</code> 和 <code>runner</code> 相遇时，相遇点距离环起点距离为<code>b</code>，此时 <code>runner</code> 已绕环走了<code>k</code>圈，则</p><ul><li><code>walker</code> 走的距离为 <code>a+b</code>，步数为 <code>a+b</code></li><li><code>runner</code> 速度为 <code>walker</code> 的两倍，<code>runner</code> 走的距离为 <code>2*(a+b)</code>，步数为 <code>a+b</code></li><li><code>runner</code> 走的距离为 <code>a+b+k*n=2*(a+b)</code>，从而 <code>a+b=k*n</code>，<code>a=k*n-b</code></li><li>因此有，当 <code>walker</code> 走 <code>a</code> 步，<code>runner</code> 走 <code>(k*n-b)</code> 步。当 <code>k=1</code> 时，则为 <code>(n-b)</code> 步</li></ul><h5 id="环的起点"><a href="#环的起点" class="headerlink" title="环的起点"></a>环的起点</h5><p>令 <code>walker</code> 返回链表初始头结点，<code>runner</code> 仍在相遇点。此时，令 <code>walker</code> 和 <code>runner</code> 每次都走一步距离。当 <code>walker</code> 和 <code>runner</code> 相遇时，二者所在位置即环的起点。</p><p>证明过程如下。</p><p><code>walker</code> 走 <code>a</code> 步，到达环的起点；<code>runner</code> 初始位置为 <code>2(a+b)</code>，走了 <code>a</code> 步之后，即 <code>kn-b</code> 步之后，所在位置为 <code>2(a+b)+kn-b=2a+b+kn= a+(a+b)+kn=a+2kn</code>。因此，<code>runner</code> 位置是环的起点。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// runner走的位置</span><br><span class="line"><span class="number">2</span>(a+b) + a</span><br><span class="line">= <span class="number">3</span>a + <span class="number">2</span>b    //消去b  b = k*n - a</span><br><span class="line">= <span class="number">3</span>a + <span class="number">2</span>*(k*n - a)</span><br><span class="line">= a + <span class="number">2</span>kn</span><br></pre></td></tr></table></figure><h5 id="环的长度"><a href="#环的长度" class="headerlink" title="环的长度"></a>环的长度</h5><p>在上述判断环的起点的基础上，求解环的长度。</p><ul><li>当 <code>walker</code> 和 <code>runner</code> 相遇时，二者所在位置即环的起点。此后，再让 <code>walker</code> 每次运动一步。</li><li><code>walker</code> 走 <code>n</code> 步之后，<code>walker</code> 和 <code>runner</code> 再次相遇。<code>walker</code> 所走的步数即是环的长度。</li></ul><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><blockquote><p>注意，在 <code>while()</code> 中需要使用 <code>break</code> 及时跳出循环，否则提交时会出现超时错误 <code>Time Limit Exceeded</code></p></blockquote><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> hasCycle = <span class="literal">false</span>;</span><br><span class="line">        ListNode *walker = head; <span class="comment">//moves one step each time</span></span><br><span class="line">        ListNode *runner = head; <span class="comment">//moves two step each time</span></span><br><span class="line">        <span class="keyword">while</span>(runner-&gt;next != <span class="literal">NULL</span> &amp;&amp; runner-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            walker = walker-&gt;next;</span><br><span class="line">            runner = runner-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(walker == runner)&#123;</span><br><span class="line">                hasCycle = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">//跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(hasCycle == <span class="literal">true</span>)&#123;</span><br><span class="line">            walker = head;</span><br><span class="line">            <span class="keyword">while</span>(walker != runner)&#123;</span><br><span class="line">                walker = walker-&gt;next;</span><br><span class="line">                runner = runner-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> walker;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>JavaScript</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head === <span class="literal">null</span> || head.next === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Tip - new ListNode() 创建可省略，节省代码运行时间</span></span><br><span class="line">    <span class="comment">// let walker = new ListNode();   // one steps</span></span><br><span class="line">    <span class="comment">// let runner = new ListNode();   // two steps</span></span><br><span class="line">    <span class="keyword">let</span> walker = head;</span><br><span class="line">    <span class="keyword">let</span> runner = head;</span><br><span class="line">    <span class="keyword">let</span> hasCycle = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(runner.next !== <span class="literal">null</span> &amp;&amp; runner.next.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">        runner = runner.next.next;</span><br><span class="line">        walker = walker.next;</span><br><span class="line">        <span class="keyword">if</span>(runner === walker)&#123;</span><br><span class="line">            hasCycle = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//jump loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hasCycle)&#123;</span><br><span class="line">        walker = head;</span><br><span class="line">        <span class="keyword">while</span>(walker !== runner)&#123;</span><br><span class="line">            runner = runner.next;</span><br><span class="line">            walker = walker.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> walker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode walker = head;</span><br><span class="line">        ListNode runner = head;</span><br><span class="line">        <span class="keyword">boolean</span> hasCycle = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(runner.next != <span class="keyword">null</span> &amp;&amp; runner.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            walker = walker.next;</span><br><span class="line">            runner = runner.next.next;</span><br><span class="line">            <span class="keyword">if</span>(walker == runner)&#123;</span><br><span class="line">                hasCycle = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//jump loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(hasCycle)&#123;</span><br><span class="line">            walker = head;</span><br><span class="line">            <span class="keyword">while</span>(walker != runner)&#123;</span><br><span class="line">                walker = walker.next;</span><br><span class="line">                runner = runner.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> walker;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Python</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.next == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        runner = walker = head</span><br><span class="line">        hasCycle = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> runner <span class="keyword">and</span> runner.next:</span><br><span class="line">            runner = runner.next.next</span><br><span class="line">            walker = walker.next</span><br><span class="line">            <span class="keyword">if</span> runner == walker:</span><br><span class="line">                hasCycle = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> hasCycle:</span><br><span class="line">            walker = head</span><br><span class="line">            <span class="keyword">while</span> walker != runner:</span><br><span class="line">                walker = walker.next</span><br><span class="line">                runner = runner.next</span><br><span class="line">            <span class="keyword">return</span> walker</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="258-Add-Digits（各位相加）"><a href="#258-Add-Digits（各位相加）" class="headerlink" title="258. Add Digits（各位相加）"></a>258. Add Digits（各位相加）</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode.com/problems/add-digits/?tab=Description" target="_blank" rel="noopener">LeetCode-258. Add Digits（各位相加）</a></li></ul><h3 id="Approach-1-Digit-Root-公式"><a href="#Approach-1-Digit-Root-公式" class="headerlink" title="Approach 1-Digit Root 公式"></a>Approach 1-Digit Root 公式</h3><h4 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li><a href="https://leetcode.com/problems/add-digits/discuss/68580/Accepted-C%2B%2B-O(1)-time-O(1)-space-1-Line-Solution-with-Detail-Explanations" target="_blank" rel="noopener">Add Digits | LeetCode Discussion</a></li><li><a href="https://en.wikipedia.org/wiki/Digital_root" target="_blank" rel="noopener">Digit Root | Wikipedia</a></li></ul><blockquote><p>将一正整数的各个位数相加(即横向相加)后，若加完后的值大于等于10的话，则继续将各位数进行横向相加直到其值小于十为止所得到的数，即为数根 (<code>Digit Root</code>)</p></blockquote><p>本题目为求解一个非负整数的数根。参考 <a href="https://en.wikipedia.org/wiki/Digital_root" target="_blank" rel="noopener">Digit Root | Wikipedia</a> 可以了解数根的公式求解方法。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/leetcode-258-add-digits.png" alt=""></p><p>从上图总结规律，对于一个 <code>b</code> 进制的数字 (此处针对十进制数，<code>b</code>=10)，其 数字根 （<code>digit root</code>） 可以表达为</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dr(n) = <span class="number">0</span> <span class="keyword">if</span> n == <span class="number">0</span>    </span><br><span class="line"></span><br><span class="line">dr(n) = (b-<span class="number">1</span>) <span class="keyword">if</span> n != <span class="number">0</span> <span class="keyword">and</span> n % (b-<span class="number">1</span>) == <span class="number">0</span>  // <span class="number">9</span>的倍数且不为零，数根为<span class="number">9</span></span><br><span class="line"></span><br><span class="line">dr(n) = n mod (b-<span class="number">1</span>) <span class="keyword">if</span> n % (b-<span class="number">1</span>) != <span class="number">0</span>  // 不是<span class="number">9</span>的倍数且不为零，数根为对<span class="number">9</span>取模</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dr(n) = <span class="number">1</span> + (n - <span class="number">1</span>) % <span class="number">9</span></span><br></pre></td></tr></table></figure><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + (num - <span class="number">1</span>) % <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>JavaScript</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addDigits = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + (num - <span class="number">1</span>) % <span class="number">9</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">9</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num % <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Python</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addDigits</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num:int</span></span><br><span class="line"><span class="string">        :rtype :int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> num%<span class="number">9</span> == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">9</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> num%<span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="461-Hamming-Distance（汉明距离）"><a href="#461-Hamming-Distance（汉明距离）" class="headerlink" title="461. Hamming Distance（汉明距离）"></a>461. Hamming Distance（汉明距离）</h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode.com/problems/hamming-distance/" target="_blank" rel="noopener">LeetCode-461. Hamming Distance（汉明距离）</a></li></ul><h3 id="Approach-1-异或位运算"><a href="#Approach-1-异或位运算" class="headerlink" title="Approach 1-异或位运算"></a>Approach 1-异或位运算</h3><p>对输入参数进行异或位运算得到一个二进制数值，再计算其中的数字 <code>1</code> 的个数即可。</p><p>在代码实现中，可以结合语言内置的API或方法，简化求解过程。</p><h4 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>JavaScript</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; y</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hammingDistance = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xor = x^y;</span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;   <span class="comment">// Number型 占32位</span></span><br><span class="line">        total += (xor&gt;&gt;i) &amp;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于 <code>Number</code> 型占 32 位，因此，需要异或的结果进行32次移位，循环判断其中的数字 <code>1</code> 的个数。</p><p>下面考虑简化上述求解过程。</p><ol><li><a href="https://www.w3schools.com/jsref/jsref_tostring_number.asp" target="_blank" rel="noopener">number.toString(radix)</a> 方法可以将一个数字以 <code>radix</code> 进制格式转换为字符串。可以将异或结果转换为 2 进制字符串。</li><li>对上述 2 进制字符串，使用正则表达式，只保留其中 <code>1</code>，将 <code>0</code> 替换为空。</li><li>最后，计算所得字符串的长度，即所求结果。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; y</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hammingDistance = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (x ^ y).toString(<span class="number">2</span>).replace(<span class="regexp">/0/g</span>, <span class="string">''</span>).length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Java</li></ul><p>Java中，<a href="https://www.tutorialspoint.com/java/lang/integer_bitcount.htm" target="_blank" rel="noopener">Integer.bitCount()</a>  函数可以返回输入参数对应二进制格式数值中数字 <code>1</code> 的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(x^y);  <span class="comment">//XOR</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><p>C++ 中, <a href="http://www.xuebuyuan.com/828691.html" target="_blank" rel="noopener">int __builtin_popcount</a> 函数可以返回输入参数对应二进制格式数值中数字 <code>1</code> 的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __builtin_popcount(x^y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="463-Island-Perimeter（岛屿的周长）"><a href="#463-Island-Perimeter（岛屿的周长）" class="headerlink" title="463. Island Perimeter（岛屿的周长）"></a>463. Island Perimeter（岛屿的周长）</h2><h3 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h3><ul><li><a href="https://leetcode.com/problems/island-perimeter/?tab=Description" target="_blank" rel="noopener">LeetCode - 463. Island Perimeter（岛屿的周长） </a></li></ul><h3 id="Approach-1"><a href="#Approach-1" class="headerlink" title="Approach 1"></a>Approach 1</h3><h4 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h4><ul><li>遍历矩阵，找出 岛屿 <code>islands</code> 个数。若不考虑岛屿的周围，则对应的周长为 <code>4 * islands</code></li><li>对于岛屿，考虑其是否有左侧和顶部的邻居岛屿 <code>neighbours</code>。为了简化求解，对于所有岛屿，只考虑其左侧和顶部的邻居情况。</li><li>综上，最终所求的周长为 <code>4 * islands - 2 * neighbours</code></li></ul><h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> islands = <span class="number">0</span>, neighbours = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    islands++; <span class="comment">// count islands</span></span><br><span class="line">                    <span class="keyword">if</span> (i !=<span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="number">1</span>) neighbours++; <span class="comment">// count top neighbours</span></span><br><span class="line">                    <span class="keyword">if</span> (j !=<span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="number">1</span>) neighbours++; <span class="comment">// count left neighbours</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> islands * <span class="number">4</span> - neighbours * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, repeat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;grid.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;grid[i].size(); j++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (i!= <span class="number">0</span> &amp;&amp; grid[i<span class="number">-1</span>][j] == <span class="number">1</span>) repeat++;</span><br><span class="line">    <span class="keyword">if</span> (j!= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="number">1</span>) repeat++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> * count - repeat * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>JavaScript</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[][]&#125; grid</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> islandPerimeter = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> repeat=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;grid[i].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] === <span class="number">1</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>((i!==<span class="number">0</span>) &amp;&amp; (grid[i<span class="number">-1</span>][j]===<span class="number">1</span>))&#123;</span><br><span class="line">                    repeat++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>((j!==<span class="number">0</span>) &amp;&amp; (grid[i][j<span class="number">-1</span>]===<span class="number">1</span>))&#123;</span><br><span class="line">                    repeat++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>*count<span class="number">-2</span>*repeat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录LeetCode题目笔记，汇总LeetCode解答记录&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://lbs0912.github.io/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Git 进阶使用</title>
    <link href="https://lbs0912.github.io/2020/02/01/git-usage-improve/"/>
    <id>https://lbs0912.github.io/2020/02/01/git-usage-improve/</id>
    <published>2020-02-01T02:23:34.000Z</published>
    <updated>2020-02-23T08:48:04.364Z</updated>
    
    <content type="html"><![CDATA[<ul><li>总结日常开发中的 Git 进阶使用</li><li>记录多 <code>SSH</code> 配置，<code>git reflog</code> 解决 <code>detached-head</code> 代码丢失问题</li><li>总结团队协作下，如何保持 git 提交信息简洁</li></ul><a id="more"></a><h2 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h2><ul><li>2018/07/09，撰写</li><li>2019/03/10，添加多SSH配置</li><li>2019/04/26，添加 <code>git cherry-pick</code></li><li>2019/10/07，添加如何删除git所有历史提交信息</li><li>2019/10/14，添加 <code>git merge --no-ff</code></li><li>2019/12/14，添加 <code>git reflog</code> 使用</li><li>2020/02/01，添加 <em>删除所有历史提交记录</em></li><li>2020/02/01，添加 <em>团队协作下，如何保持 git 提交信息简洁</em></li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="http://gitup.co/" target="_blank" rel="noopener">GitUp</a></li><li><a href="https://www.zhihu.com/question/20070065/answer/480261314" target="_blank" rel="noopener">如何高效使用github</a></li></ul><h2 id="git-reflog-解决提交代码丢失-detached-head"><a href="#git-reflog-解决提交代码丢失-detached-head" class="headerlink" title="git reflog 解决提交代码丢失 detached-head"></a>git reflog 解决提交代码丢失 <code>detached-head</code></h2><p><code>reflog</code> 是 Git 操作的一道安全保障，它能够记录几乎所有本地仓库的改变。包括所有分支 commit 提交，已经删除（其实并未被实际删除）commit 都会被记录。总结而言，只要 HEAD 发生变化，就可以通过 <code>reflog</code> 查看到。</p><h3 id="detached-head-代码丢失找回"><a href="#detached-head-代码丢失找回" class="headerlink" title="detached-head 代码丢失找回"></a><code>detached-head</code> 代码丢失找回</h3><ul><li><a href="https://www.jianshu.com/p/f247a27851fb" target="_blank" rel="noopener">git提交到HEAD detached导致代码丢失</a></li><li><a href="https://stackoverflow.com/questions/4845505/gitx-how-do-i-get-my-detached-head-commits-back-into-master" target="_blank" rel="noopener">StackOverflow - gitx How do I get my ‘Detached HEAD’ commits back into master</a></li></ul><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>日常开发中，切换分支误操作，造成本地代码修改丢失。</p><p>此时，可以借助 <code>git reflog</code> 找回丢失的代码修改。</p><h4 id="丢失产生原因和步骤"><a href="#丢失产生原因和步骤" class="headerlink" title="丢失产生原因和步骤"></a>丢失产生原因和步骤</h4><p>首先在 <code>master</code> 分支上开发，此时线上出现 bug 且回到旧版本的 tag。这时 <code>master</code> 分支上有一部分代码修改但未提交。</p><p>在 <code>master</code> 分支上执行 <code>git status</code>，有未提交的代码，如下图所示</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-reflog-1.png" alt=""></p><p>在 <code>master</code> 分支上执行 <code>git tag</code>查看标签信息，如下图所示</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-reflog-2.png" alt=""></p><p>此时有未提交的代码，然后执行 <code>git checkout v1.0</code></p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-reflog-3.png" alt=""></p><p>这个时候，<strong>提示当前分支为 <code>detached HEAD</code></strong></p><p>然后再执行 <code>git add ./git commit</code> 和 <code>git checkout master</code>，切换回 <code>master</code> 分支。<strong>这个时候发现 <code>detached HEAD</code> 分支不见了，<code>master</code> 分支上未提交的代码也不见了。</strong></p><h4 id="代码找回"><a href="#代码找回" class="headerlink" title="代码找回"></a>代码找回</h4><p>执行 <code>git reflog</code> 查看提交记录</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-reflog-4.png" alt=""></p><p>查找对应提交的 <code>commitId</code> 为 <code>247e11b</code>，然后执行下述命令行，找回丢失的代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="number">247</span>e11b    <span class="comment">//检出对应的提交</span></span><br><span class="line">git checkout -<span class="selector-tag">b</span> diff    <span class="comment">//新建一个新的diff分支</span></span><br><span class="line">git checkout master     <span class="comment">//切换到master分支</span></span><br><span class="line">git merge diff          <span class="comment">//将新建的diff分支合并到master分支</span></span><br></pre></td></tr></table></figure><h2 id="删除所有历史提交记录"><a href="#删除所有历史提交记录" class="headerlink" title="删除所有历史提交记录"></a>删除所有历史提交记录</h2><ul><li><a href="https://stackoverflow.com/questions/13716658/how-to-delete-all-commit-history-in-github" target="_blank" rel="noopener">How to delete all commit history in github | Stackoverflow</a></li></ul><p>此处介绍如何删除所有历史提交记录，形成一个全新的仓库。</p><ul><li>1 - Checkout</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="comment">--orphan new_branch</span></span><br></pre></td></tr></table></figure><ul><li>2 - Add all the files</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> -A</span></span><br><span class="line"></span><br><span class="line">//等效于 git <span class="keyword">add</span><span class="bash"> --all 或 git add .</span></span><br></pre></td></tr></table></figure><blockquote><p> <code>git add</code> 中使用参数 <code>-A</code> 或 <code>--all</code> 表示追踪所有操作，包含新增、修改和删除</p><p> Git 2.0版开始，<code>-A</code> 参数为默认参数，即 <code>git add .</code> 等效于 <code>git add -A</code> 或 <code>git add --all</code></p></blockquote><ul><li>3 - Commit the changes</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -am <span class="string">"commit message"</span></span><br></pre></td></tr></table></figure><ul><li>4 - Delete the branch</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D <span class="keyword">master</span>   <span class="title">//同时删除本地和远程分支</span></span><br></pre></td></tr></table></figure><ul><li>5 - Rename the current branch to master</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-m master</span><br></pre></td></tr></table></figure><ul><li>6 - force update your repository</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> -f <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><p>下面对上述步骤进行说明</p><h3 id="git-checkout-–orphan"><a href="#git-checkout-–orphan" class="headerlink" title="git checkout –orphan"></a>git checkout –orphan</h3><p>如果你的某个分支上积累了无数次的无意义的提交，<code>git log</code> 信息满天飞，那么可以使用 <code>git checkout --orphan &lt;new_branch_name&gt;</code> </p><ul><li>基于当前分支创建一个新的“孤儿(<code>orphan</code>)”的分支，没有任何提交历史，但包含当前分支所有内容</li><li>执行上述命令后，工作区（<code>Workspace</code>）中所有文件均被认为在该操作中新增(<code>git statue</code> 查看状态，所有文件状态均为 <code>new file</code>，如下图所示)，此时执行 <code>git add .</code> 会把所有文件添加到缓存区（<code>Index</code>）</li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-checkout-orphan-1.png" alt=""></p><ul><li>严格意义上说，执行 <code>git checkout --orphan &lt;new_branch_name&gt;</code> 后，创建的并不是一个分支，因为此时 <code>HEAD</code> 指向的引用中没有 <code>commit</code> 值。只有在进行一次提交后，它才算得上真正的分支。</li></ul><blockquote><p><code>orphan</code> 译为“孤儿”，该参数表示创建一个孤立的分支，没有任何提交历史，且与当前分支不存在任何关系（查看提交信息，可发现其为一个孤立的点，如下图所示）</p><p>孤儿（<code>orphan</code>）无父辈信息，同理，创建的分支也不包含任何历史提交信息</p></blockquote><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-delete-all-info-1.png" alt=""></p><h3 id="git-commit-am"><a href="#git-commit-am" class="headerlink" title="git commit -am"></a>git commit -am</h3><ul><li><a href="https://segmentfault.com/q/1010000005900988" target="_blank" rel="noopener">git commit -m 与 git commit -am 的区别</a></li></ul><h3 id="git-branch-m"><a href="#git-branch-m" class="headerlink" title="git branch -m"></a>git branch -m</h3><p>重命名</p><h3 id="git-push-f-origin-master"><a href="#git-push-f-origin-master" class="headerlink" title="git push -f origin master"></a>git push -f origin master</h3><h2 id="git项目协作——保证git信息简洁"><a href="#git项目协作——保证git信息简洁" class="headerlink" title="git项目协作——保证git信息简洁"></a>git项目协作——保证git信息简洁</h2><h3 id="同一分支-git-pull-使用-rebase"><a href="#同一分支-git-pull-使用-rebase" class="headerlink" title="同一分支 git pull 使用 rebase"></a>同一分支 git pull 使用 rebase</h3><p>默认情况下，<code>git pull</code> 使用的是 <code>merge</code> 行为。多人协作开发时，会产生不必要的 <code>merge</code> 提交记录，造成提交链混乱不堪。</p><p>推荐在同一个分支更新代码时，使用 <code>git pull --rebase</code>。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为某个分支单独设置，这里是设置 dev 分支</span></span><br><span class="line">git<span class="built_in"> config </span>branch.dev.rebase <span class="literal">true</span></span><br><span class="line"><span class="comment"># 全局设置，所有的分支 git pull 均使用 --rebase</span></span><br><span class="line">git<span class="built_in"> config </span>--global pull.rebase <span class="literal">true</span></span><br><span class="line">git<span class="built_in"> config </span>--global branch.autoSetupRebase always</span><br></pre></td></tr></table></figure><h3 id="分支合并使用-merge-–no-ff"><a href="#分支合并使用-merge-–no-ff" class="headerlink" title="分支合并使用 merge –no-ff"></a>分支合并使用 merge –no-ff</h3><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><ul><li><code>Fast-Forward</code>：当前分支合并到另一分支时，如果没有冲突要解决，就会直接移动文件指针，并且不会产生合并提交记录。该过程中，存在<code>git</code> 文件指针快速移动， 因此该过程称为 <code>Fast-Forward</code>。</li><li><code>--no-ff</code>(<code>no fast foward</code>)：每一次的合并，都会创建一个新的 <code>commit</code> 记录。使用 <code>--no-ff</code>，可以保持原有分支提交链的完整性，并且当该分支被删除时，提交信息依旧存在。</li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-merge--no--ff-1.png" alt="git-merge--no-ff-1"></p><p>结合上图分析，在 <code>dev</code>（绿色） 分支上检出 <code>feature-1</code> 分支（蓝色），且 <code>dev</code> 分支不进行任何提交</p><ul><li>直接 <code>merge</code>，默认采用 <code>Fast-Forward</code>，两个分支的提交链会合并为一条直线，不利于后期代码审查和维护</li><li>使用 <code>git merge --no-ff feature-1</code> 合并代码，会产生一个新的提交，且两个分支的提交链不会重叠，利于后期代码审查和维护</li></ul><h4 id="merge-默认设置"><a href="#merge-默认设置" class="headerlink" title="merge 默认设置"></a>merge 默认设置</h4><p><code>git merge</code> 默认使用 <code>fast-forward</code>，可以通过如下方式，修改为默认使用 <code>--no-ff</code>。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global merge.commit <span class="literal">no</span></span><br><span class="line">git<span class="built_in"> config </span>--global merge.ff <span class="literal">no</span></span><br></pre></td></tr></table></figure><p>此外，SourceTree 在设置中也可以设置 <code>--no-ff</code>。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-merge--no-ff-2.png" alt="git-merge--no-ff-2"></p><h2 id="IDE中使用Git"><a href="#IDE中使用Git" class="headerlink" title="IDE中使用Git"></a>IDE中使用Git</h2><h3 id="VSCode中使用Git"><a href="#VSCode中使用Git" class="headerlink" title="VSCode中使用Git"></a>VSCode中使用Git</h3><ul><li><a href="https://juejin.im/post/5b00474951882542ba08087a" target="_blank" rel="noopener">VSCode 中使用Git实践</a></li><li>推荐安装 <code>Git Lens</code> 和 <code>Git History</code> 插件</li><li>克隆代码<ul><li><code>Ctrl + Shift + P</code> 打开命令面板，输入 <code>Git</code>，选择 <code>Git Clone</code> 进行克隆代码</li></ul></li><li>查看修改（VSCode会使用不同颜色进行标识）<ul><li>红色箭头 - 标识删除行</li><li>蓝色竖线 - 该处有修改</li><li>绿色箭头 - 该处为新增</li></ul></li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-vscode-usage-1.png?q-sign-algorithm=sha1&q-ak=AKIDnYCjAUImfNuHSSn8nHaihXEkvukPOAGM&q-sign-time=1570451528;1570453328&q-key-time=1570451528;1570453328&q-header-list=&q-url-param-list=&q-signature=b0ec61fae96fb0c37059f2afedbac8e2ad1b2753" alt=""></p><ul><li>提交代码<ul><li><code>Ctrl + Shift + G</code> 打开代码管理器进行操作</li></ul></li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-vscode-usage-2.png?q-sign-algorithm=sha1&q-ak=AKIDnYCjAUImfNuHSSn8nHaihXEkvukPOAGM&q-sign-time=1570453094;1570454894&q-key-time=1570453094;1570454894&q-header-list=&q-url-param-list=&q-signature=63ea253d235cba5fc2d3d5c525e5242d11bba407" alt=""></p><h2 id="git-clone-设置缓存区"><a href="#git-clone-设置缓存区" class="headerlink" title="git clone 设置缓存区"></a>git clone 设置缓存区</h2><p>当工程较大时，使用 <code>git clone</code> 拉取代码，可能会出现 <code>early EOF</code> 的报错或者拉取代码失败。</p><p>这是因为 <code>git clone</code> 本质上是建立一个 HTTP 连接，工程较大时会超过默认设置的缓存大小。</p><p>使用 <code>git config --list</code> 查看 <code>http.postbuffer</code> 的大小，确认是否小于下载的工程大小。</p><p>使用 <code>git config --global http.postbuffer 524288000 //500x1024x1024 设置为500M</code> 可以对缓存区大小进行设置。 </p><h2 id="git-clean"><a href="#git-clean" class="headerlink" title="git clean"></a>git clean</h2><ul><li><code>git clean -n</code> -  查看哪些文件将被 <code>git clean</code> 清除，只是查看，并不会真正执行清除操作</li><li><code>git clean -f</code>  - 删除未跟踪的文件 <code>untracked files</code> </li><li><code>git clean -fd</code> - 连同未跟踪的目录也一起删除  </li><li><code>git clean -fdx</code> - 删除未跟踪的文件和文件目录，并移除被忽略的文件。其中，<code>-x</code> 表示移除被忽略的文件并且 <code>.gitignore</code> 文件中指定的文件和文件夹也会清除或者清除更改</li></ul><h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><ul><li><code>git tag</code>： 显示所有标签</li><li><code>git tag -l &#39;v1.0.*&#39;</code>： 用通配符查看符合筛选条件的标签</li><li><code>git show xxx</code>： 查看标签信息（提交者，邮箱等）</li><li><code>git tag xxx</code>： 创建轻量标签</li><li><code>git tag -a xxx</code>： 创建含有附注的标签</li><li><code>git tag -a xxx -m &#39;xxxx&#39;</code>： 创建含有附注的标签，并附加提交信息（默认标签打到当前Head提交状态）</li><li><code>git tag -a xxx -m &#39;xxxx&#39; \&lt;commitID&gt;</code>： 创建补丁标签，即对之前的提交添加标签</li><li><code>git tag -d xxx</code>： 删除本地标签</li><li><code>git push origin --delete tag &lt;tagname&gt;</code>： 删除远程标签</li></ul><p>需要注意的是，<br>Git 使用的标签有 2 种类型：轻量级的（<code>lightweight</code>）和含附注的（<code>annotated</code>）。 —— <a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">git tag | Doc</a></p><ul><li>轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。</li><li>含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 <code>GNU Privacy Guard</code> (<code>GPG</code>) 来签署或验证。</li></ul><p><strong>一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。</strong></p><h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><ul><li><a href="https://juejin.im/post/5925a2d9a22b9d0058b0fd9b" target="_blank" rel="noopener">Cherry-Pick | 掘金</a></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>cherry</code> 译为樱桃，<code>pick</code> 译挑选。<code>git cherry-pick</code> 即选择某一个分支中的一个或几个提交，合并到其他分支中（选择的提交即所需的樱桃），主要使用场景为</p><ul><li>情况1： 把弄错分支的提交移动到正确的分支上</li><li>情况2： 将其他分支的提交添加到当前分支</li></ul><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>假设工程有个稳定版分支 <code>v2.0</code>，还有个开发版分支 <code>v3.0</code>。开发分支还未彻底完成，不能直接把两个分支合并，这样会导致稳定版本混乱，但是又想增加一个 <code>v3.0</code> 中的功能到 <code>v2.0</code> 中，这里就可以使用 <code>cherry-pick</code> 了。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先在v3.0中查看要合并的commit的commit id</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment">// 假设是 commit f79b0b1ffe445cab6e531260743fa4e08fb4048b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切到v2.0中</span></span><br><span class="line">git checkout v2.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并commit</span></span><br><span class="line">git cherry-pick f79b0b1ffe445cab6e531260743fa4e08fb4048b     </span><br><span class="line">git cherry-pick -x f79b0b1ffe445cab6e531260743fa4e08fb4048b   <span class="comment">//表示保留原提交的作者信息进行提交</span></span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><code>git cherry_pick commitID</code>：将其他分支的 <code>commitID</code> 提交合并到当前分支</li><li><code>git cherry_pick commitID</code>：将其他分支的 <code>commitID</code> 提交合并到当前分支，<code>-x</code> 表示保留原提交的作者信息进行提交</li><li><code>git cherry_pick &lt;start-commit-id&gt;…&lt;end-commit-id&gt;</code>: 该功能在Git 1.7.2 版本后才支持，将一个连续区间范围的提交，合并到到当前分支。提交范围区间左开右闭，即<code>(start, end]</code></li><li><code>git cherry_pick &lt;start-commit-id&gt;^ … &lt;end-commit-id&gt;</code>: 同上，使用 <code>^</code> 表示包含 <code>start-commit-id</code>，即<code>[start, end]</code></li></ul><blockquote><p>JetBranins 系列IDE，内置了git cherry-pick 快捷键（樱桃图标）</p></blockquote><h2 id="git命令行代理设置"><a href="#git命令行代理设置" class="headerlink" title="git命令行代理设置"></a>git命令行代理设置</h2><h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http<span class="selector-class">.proxy</span> <span class="string">'socks5://127.0.0.1:1086'</span></span><br><span class="line">git config --global https<span class="selector-class">.proxy</span> <span class="string">'socks5://127.0.0.1:1086'</span></span><br></pre></td></tr></table></figure><h3 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global --unset http.proxy</span><br><span class="line">git<span class="built_in"> config </span>--global --unset https.proxy</span><br></pre></td></tr></table></figure><h2 id="GitUp"><a href="#GitUp" class="headerlink" title="GitUp"></a>GitUp</h2><blockquote><p>Work quickly, safely, and without headaches.<br>The Git interface you’ve been missing<br>all your life has finally arrived.</p></blockquote><ul><li><a href="http://gitup.co/" target="_blank" rel="noopener">GitUp</a></li><li><a href="http://qinghua.github.io/gitup/" target="_blank" rel="noopener">Tutorial</a></li></ul><h2 id="GitG"><a href="#GitG" class="headerlink" title="GitG"></a>GitG</h2><ul><li><code>gitg</code>是一个git图形化界面。</li><li>安装</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install gitg   <span class="comment">//安装</span></span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitg  <span class="comment">// 在目录终端下输入gitg即可</span></span><br></pre></td></tr></table></figure><h2 id="Git-代码回滚"><a href="#Git-代码回滚" class="headerlink" title="Git 代码回滚"></a>Git 代码回滚</h2><ul><li><a href="https://sunmengyuan.github.io/garden/2017/06/15/git-revert.html?page=2" target="_blank" rel="noopener">谈谈 Git 代码回滚</a></li></ul><h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>某项目，并行开发着n个需求。提测时，各需求的代码被合并到测试分支。不久之后，要求把部分需求代码从测试分支抽离出去。使用下图场景进行描述。并行开发3个需求，分别是<code>feature1</code>，<code>feature2</code>，<code>feature3</code>。测试分支为<code>master</code>。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-1.jpg" alt="git-rollback"></p><p><code>feature2</code>与<code>feature3</code>对同一文件进行修改，故意制造一个冲突。 </p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-2.jpg" alt="git-rollback"></p><p>提测时，各分支代码被合并到测试分支（<code>master</code>）。首先，<code>featuer1</code>分支被合并到测试分支。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-3.jpg" alt="git-rollback"></p><p>之后，<code>featuer2</code>分支也被合并到测试分支。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-4.jpg" alt="git-rollback"></p><p>最后，合并<code>feature3</code>至测试分支。合并时，产生了与<code>feature2</code>代码的冲突。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-5.jpg" alt="git-rollback"></p><p>解决冲突之后，继续将<code>feature3</code>合并至测试分支。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-6.jpg" alt="git-rollback"></p><p>在<code>feature3</code>提测后，在测试分支上继续修复几个bug。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-7.jpg" alt="git-rollback"></p><p>注意，此时<code>feature2</code>虽已提测但并未进入测试，此时的bug修复均是针对 <code>feature1</code>与<code>feature3</code>。</p><p>几天之后，收到通知，<code>feature2</code>的测试无法正常进行，需将代码从测试分支上抽出。</p><h3 id="代码回滚操作"><a href="#代码回滚操作" class="headerlink" title="代码回滚操作"></a>代码回滚操作</h3><h4 id="Step-1-切换分支"><a href="#Step-1-切换分支" class="headerlink" title="Step 1 切换分支"></a>Step 1 切换分支</h4><p>首先，切换到<code>featuer2</code>分支。以防万一，创建<code>feature2-copy</code>分支，对该分支进行备份。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature2   <span class="comment">//切换到feature2分支</span></span><br><span class="line"></span><br><span class="line">git checkout -b feature2-<span class="built_in">copy</span>   <span class="comment">//创建并切换到feature2-copy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第2行代码等同于</span></span><br><span class="line">git branch feature2-<span class="built_in">copy</span>  <span class="comment">//创建feature2-copy分支</span></span><br><span class="line">git checkout feature2-<span class="built_in">copy</span> <span class="comment">//切换到feature2-copy分支</span></span><br></pre></td></tr></table></figure><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-8.jpg" alt="git-rollback"></p><h4 id="Step-2-确定要回滚的提交记录"><a href="#Step-2-确定要回滚的提交记录" class="headerlink" title="Step 2 确定要回滚的提交记录"></a>Step 2 确定要回滚的提交记录</h4><p>使用<code>git log</code>查看<code>feature2-copy</code>分支的提交记录（输入<code>q</code>退出<code>git log</code>环境）。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-9.jpg" alt="git-rollback"></p><p>如图所示，需要回滚最新的3个提交。实际情况中，针对某需求的提交绝不止3个。若是将提交逐一<code>revert</code>，工作量是非常大的。需要考虑将<code>n</code>个<code>commit</code>合并为一个<code>commit</code>，最后一同<code>revert</code>。</p><h4 id="Step-3-git-rebase-合并提交"><a href="#Step-3-git-rebase-合并提交" class="headerlink" title="Step 3 git rebase 合并提交"></a>Step 3 git rebase 合并提交</h4><p>使用<code>git rebase -i</code>来合并<code>commit</code>，传入需要拼接回滚至的提交的<code>hashcode</code>。（此处，将所有回滚的提交合并到需要回滚的<code>commit</code>集合中第一个提交）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hashcode为需要回滚的commit集合中第一个提交</span></span><br><span class="line">git rebase -<span class="selector-tag">i</span> e08ddaf558b9ad84422db5e4b620dcab97623fde</span><br></pre></td></tr></table></figure><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-10.jpg" alt="git-rollback"></p><p>将最近2次提交的<code>command</code>从<code>pick</code>改为<code>s</code>。</p><blockquote><p>在Vim中，</p><ol><li>输入<code>i</code>，进入<code>INSERT</code>模式。</li><li>输入<code>ESC</code>，进入命令行模式。</li><li>输入<code>:wq</code>，保存并退出VIM编辑器。</li></ol></blockquote><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-11.jpg" alt="git-rollback"></p><p>修改后，保存并退出，进入如下对话框。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-12.jpg" alt="git-rollback"></p><p>此时，对最初一次的提交的<code>commit message</code>进行修改。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-13.jpg" alt="git-rollback"></p><p>修改后保存并退出，使用<code>git log</code> 再次查看 <code>feature2-copy</code> 分支的信息。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-14.jpg" alt="git-rollback"></p><p>如上图所示，3次提交被成功合并。</p><h4 id="Step-4-git-revert-撤销提交"><a href="#Step-4-git-revert-撤销提交" class="headerlink" title="Step 4 git revert 撤销提交"></a>Step 4 git revert 撤销提交</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">revert </span>e544464c3de69adef5ca7556001abebaf40b218b</span><br></pre></td></tr></table></figure><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-15.jpg" alt="git-rollback"></p><p>保存并退出，再次查看<code>feature2-copy</code>分支的提交记录。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-16.jpg" alt="git-rollback"></p><h4 id="Step-5-git-cherry-pick"><a href="#Step-5-git-cherry-pick" class="headerlink" title="Step 5 git cherry-pick"></a>Step 5 git cherry-pick</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="keyword">master</span>   <span class="title">//切换到测试分支</span></span><br><span class="line"><span class="title">git</span> cherry-pick b309f7944d2422d8fe647dca61bda518b192628f</span><br></pre></td></tr></table></figure><p>切换到测试分支，并执行 <code>git cherry-pick</code> 命令。至此，成功的将<code>feature2</code>分支从测试分支上抽离。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-rollback-17.jpg" alt="git-rollback"></p><h2 id="Git代码管理与团队协作"><a href="#Git代码管理与团队协作" class="headerlink" title="Git代码管理与团队协作"></a>Git代码管理与团队协作</h2><ul><li><a href="https://segmentfault.com/l/1500000015442316/play" target="_blank" rel="noopener">视频教程 | Segmentfault</a></li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-team-usage-3.png" alt="git-team-usage"></p><p>代码最终提交效果如上图所示。</p><ul><li>主分支为<code>master</code>，创建一个<code>develop</code>分支用于开发。</li><li>开发者<code>leo</code>和<code>jack</code>创建自己的分支<code>leo</code>和<code>jack</code>进行开发。开发完成后，将其合并到<code>develop</code>分支上。</li><li>项目进展到需要发布时，从<code>develop</code>分支创建<code>release</code>分支，用于测试。测试通过后，将<code>release</code>分支合并到<code>develop</code>分支和<code>master</code>分支上。</li></ul><h3 id="Demo目录和初始化"><a href="#Demo目录和初始化" class="headerlink" title="Demo目录和初始化"></a>Demo目录和初始化</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span>目录结构</span><br><span class="line">-- c4</span><br><span class="line"><span class="params">---</span>|<span class="params">---</span> origin   <span class="string">//</span>模拟远程仓库  git init <span class="params">--bare</span> 创建</span><br><span class="line"><span class="params">---</span>|<span class="params">---</span> leo    <span class="string">//</span>开发者1  设置user.name = 'leo'</span><br><span class="line"><span class="params">---</span>|<span class="params">---</span> jack    <span class="string">//</span>开发者2  设置user.name = 'jack'</span><br></pre></td></tr></table></figure><blockquote><p><code>git init --bare</code> 用于创建一个“裸仓库”——只含有 <code>.git</code> 目录，不含源文件。详情参考 <a href="https://segmentfault.com/q/1010000004683286" target="_blank" rel="noopener">Ref</a>。</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mkdir</span> <span class="string">c4</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">c4</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">origin </span></span><br><span class="line"><span class="attr">cd</span> <span class="string">origin </span></span><br><span class="line"><span class="attr">git</span> <span class="string">init --bare   //创建一个裸仓库</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cd</span> <span class="string">..</span></span><br><span class="line"></span><br><span class="line"><span class="meta">//克隆远程仓库至两个开发者目录——leo,</span> <span class="string">jack</span></span><br><span class="line"><span class="attr">git</span> <span class="string">clone origin leo</span></span><br><span class="line"><span class="attr">git</span> <span class="string">clone origin jack</span></span><br></pre></td></tr></table></figure><p>为了模拟团队协作，对两个开发者目录，分别设置不同的 <code>user.name</code> 信息。</p><blockquote><p><code>git config --local</code>，使用 <code>--local</code> 参数，只对本地参数进行配置。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> leo</span><br><span class="line">git config --<span class="built_in">local</span> user.name <span class="string">'leo'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> jack</span><br><span class="line">git config --<span class="built_in">local</span> user.name <span class="string">'jack'</span></span><br></pre></td></tr></table></figure><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><h4 id="master-分支初始化"><a href="#master-分支初始化" class="headerlink" title="master 分支初始化"></a>master 分支初始化</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd leo </span><br><span class="line">echo <span class="selector-tag">a</span> = <span class="number">1</span> &gt; leo1<span class="selector-class">.py</span>  <span class="comment">// 将a=1写入leo1.py文件</span></span><br><span class="line">cat leo1<span class="selector-class">.py</span>           <span class="comment">//显示文件的内容</span></span><br><span class="line"></span><br><span class="line">git add . </span><br><span class="line">git commit -m <span class="string">"c4 项目初始化"</span></span><br><span class="line"></span><br><span class="line">git tag <span class="number">0.0</span>.<span class="number">1</span>  <span class="comment">//添加标签 方便管理</span></span><br></pre></td></tr></table></figure><h4 id="创建develop分支"><a href="#创建develop分支" class="headerlink" title="创建develop分支"></a>创建develop分支</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git checkout -<span class="selector-tag">b</span> develop</span><br><span class="line"></span><br><span class="line">echo <span class="selector-tag">b</span> = <span class="number">2</span> &gt; leo1.py</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"建立开发分支并提交"</span></span><br><span class="line"></span><br><span class="line">git push origin develop  <span class="comment">//推送到远程分支</span></span><br><span class="line"></span><br><span class="line">gitg   <span class="comment">// 使用gitg图形化工具查看提交信息</span></span><br></pre></td></tr></table></figure><h4 id="leo进行开发"><a href="#leo进行开发" class="headerlink" title="leo进行开发"></a>leo进行开发</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git checkout -<span class="selector-tag">b</span> leo</span><br><span class="line">echo c=<span class="number">3</span> &gt; leo2.py</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"创建leo分支并开发"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//合并当前开发到dev分支</span></span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff leo  <span class="comment">//合并分支 并保留leo分支信息</span></span><br><span class="line"></span><br><span class="line">gitg  <span class="comment">//查看提交历史树  gui</span></span><br></pre></td></tr></table></figure><blockquote><p><code>git merge --no-ff leo</code>，合并分支，并保留<code>leo</code>分支的信息。关于参数<code>--no-ff</code>的详情，参考 <a href="https://segmentfault.com/q/1010000002477106" target="_blank" rel="noopener">Ref</a>。</p></blockquote><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-team-usage-1.png" alt="git-team-usage"></p><p>最后，将开发分支推送到远程。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> develop</span><br><span class="line"></span><br><span class="line">gitg</span><br></pre></td></tr></table></figure><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-team-usage-2.png" alt="git-team-usage"></p><h4 id="jack进行开发"><a href="#jack进行开发" class="headerlink" title="jack进行开发"></a>jack进行开发</h4><p>首先，从远程拉取最新代码。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git pull origin</span></span><br></pre></td></tr></table></figure><p>之后，jack进行日常开发，流程同leo开发，此处不再赘述。</p><h4 id="release分支测试"><a href="#release分支测试" class="headerlink" title="release分支测试"></a>release分支测试</h4><p>项目进展到需发布时，从<code>develop</code>分支创建<code>release</code>分支，用于测试。测试通过后，将<code>release</code>分支合并到<code>develop</code>分支和<code>master</code>分支上。</p><h2 id="远程多分支代码拉取"><a href="#远程多分支代码拉取" class="headerlink" title="远程多分支代码拉取"></a>远程多分支代码拉取</h2><p>此处记录如何拉取远程所有分支，并建立本地分支追踪远程分支。</p><ul><li>Step 1： <code>clone</code> 远程代码</li><li>Step 2： 在sourcetree中可以看出，远程分支有<code>origin/master</code>，<code>origin/dev</code>和<code>origin/webtest</code>。此时本地分支为<code>dev</code>，并建立了追踪关系。</li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-pull-branches-1.png" alt="git pull branches"></p><ul><li>Step 3： 在对应的远程分支（<code>origin/master</code>）上点击，检出分支，设定本地分支名，并追踪远程分支即可。</li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-pull-branches-2.png" alt="git pull branches"></p><ul><li>Step 4： 最终效果如下图，检出本地分支并追踪远程。</li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/programming-2019/git-pull-branches-3.png" alt="git pull branches"></p><blockquote><p>Tip</p><p><code>git branch -r</code>： 查看远程分支</p><p><code>git branch -a</code>： 查看所有分支</p><p>Ref: <a href="https://gaohaoyang.github.io/2016/07/07/git-clone-not-master-branch/" target="_blank" rel="noopener">Blog</a></p></blockquote><h2 id="多SSH配置"><a href="#多SSH配置" class="headerlink" title="多SSH配置"></a>多SSH配置</h2><ol><li>取消全局账户和邮箱设置</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--unset --global user.name</span><br><span class="line">git<span class="built_in"> config </span>--unset --global user.email</span><br></pre></td></tr></table></figure><ol start="2"><li>新建SSH key：</li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"liubaoshuai1@jd.com"</span> </span><br><span class="line">Enter <span class="built_in">file</span> <span class="keyword">in</span> which <span class="built_in">to</span> save <span class="keyword">the</span> key (/User/lbs/.ssh/id_rsa): id_rsa_jd  <span class="comment"># 输入文件名</span></span><br></pre></td></tr></table></figure><ol start="3"><li>新密钥添加到 SSH Agent</li></ol><p>默认只读取 <code>id_rsa</code>，为了让 SSH 识别新的私钥，需将其添加到 SSH Agent 中</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-<span class="keyword">add</span><span class="bash"> ~/.ssh/id_rsa_jd</span></span><br></pre></td></tr></table></figure><p>若出现 <code>Could not open a connection to your authentication agent</code> 错误，执行以下命令</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ssh</span>-agent <span class="keyword">bash</span></span><br><span class="line"><span class="keyword">ssh-add </span>~/.ssh/id_rsa_jd</span><br></pre></td></tr></table></figure><ol start="4"><li>修改 <code>config</code> 文件</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim<span class="built_in"> config </span>     # 若没有，可创建  touch config</span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">default</span> <span class="selector-tag">user</span> (lbs1203940926<span class="variable">@163</span>.com)</span><br><span class="line"><span class="selector-tag">Host</span> <span class="selector-tag">github</span><span class="selector-class">.com</span></span><br><span class="line">   <span class="selector-tag">HostName</span> <span class="selector-tag">github</span><span class="selector-class">.com</span></span><br><span class="line">   <span class="selector-tag">User</span> <span class="selector-tag">lbs1203940926</span>@<span class="selector-tag">163</span><span class="selector-class">.com</span></span><br><span class="line">   <span class="selector-tag">PreferredAuthentications</span> <span class="selector-tag">publickey</span></span><br><span class="line">   <span class="selector-tag">IdentityFile</span> /<span class="selector-tag">Users</span>/<span class="selector-tag">lbs</span>/<span class="selector-class">.ssh</span>/<span class="selector-tag">id_rsa</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="selector-tag">jd-gitlab</span>(liubaoshuai1<span class="variable">@jd</span>.com))</span><br><span class="line"><span class="selector-tag">Host</span> <span class="selector-tag">git</span><span class="selector-class">.jd</span><span class="selector-class">.com</span></span><br><span class="line">   <span class="selector-tag">HostName</span> <span class="selector-tag">git</span><span class="selector-class">.jd</span><span class="selector-class">.comm</span></span><br><span class="line">   <span class="selector-tag">User</span> <span class="selector-tag">liubaoshuai1</span>@<span class="selector-tag">jd</span><span class="selector-class">.com</span></span><br><span class="line">   <span class="selector-tag">PreferredAuthentications</span> <span class="selector-tag">publickey</span></span><br><span class="line">   <span class="selector-tag">IdentityFile</span> /<span class="selector-tag">Users</span>/<span class="selector-tag">lbs</span>/<span class="selector-class">.ssh</span>/<span class="selector-tag">id_rs_jd</span></span><br></pre></td></tr></table></figure><ol start="5"><li>拉取JD代码</li></ol><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 测试暂不支持SourceTree中远程拉取，需要终端命令行拉取</span></span><br><span class="line"><span class="meta"># 且暂只支持https协议</span></span><br><span class="line"></span><br><span class="line">git clone http:<span class="comment">//git.jd.com/jdreact/jdreact-jsbundle-jdreactonehourarrive</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># UserName: liubaoshuai</span></span><br><span class="line"><span class="meta"># PassWord: ERP's password</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;总结日常开发中的 Git 进阶使用&lt;/li&gt;
&lt;li&gt;记录多 &lt;code&gt;SSH&lt;/code&gt; 配置，&lt;code&gt;git reflog&lt;/code&gt; 解决 &lt;code&gt;detached-head&lt;/code&gt; 代码丢失问题&lt;/li&gt;
&lt;li&gt;总结团队协作下，如何保持 git 提交信息简洁&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Develop Tools" scheme="https://lbs0912.github.io/categories/Develop-Tools/"/>
    
    
      <category term="Develop Tools" scheme="https://lbs0912.github.io/tags/Develop-Tools/"/>
    
      <category term="Git" scheme="https://lbs0912.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础知识梳理</title>
    <link href="https://lbs0912.github.io/2020/01/31/redis-basic/"/>
    <id>https://lbs0912.github.io/2020/01/31/redis-basic/</id>
    <published>2020-01-31T02:25:26.000Z</published>
    <updated>2020-02-23T08:48:04.366Z</updated>
    
    <content type="html"><![CDATA[<ul><li>对 Redis 基础知识进行梳理，包括Redis的5种数据类型，事务，过期时间，消息通知，优先级队列，管道，数据持久化，复制，哨兵，事务等</li></ul><a id="more"></a><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><ul><li>2020/01/30，撰写</li></ul><h2 id="学习资料汇总"><a href="#学习资料汇总" class="headerlink" title="学习资料汇总"></a>学习资料汇总</h2><ul><li><a href="https://redis.io/" target="_blank" rel="noopener">Redis官网</a></li><li><a href="http://www.redis.cn/" target="_blank" rel="noopener">Redis中文官网</a></li><li><a href="https://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">Redis菜鸟教程</a></li><li><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Redis源码</a> —— 使用C语言开发，源码只有3万多行，降低了用户通过修改Redis源码来提升性能的门槛</li></ul><h2 id="Redis-初识"><a href="#Redis-初识" class="headerlink" title="Redis 初识"></a>Redis 初识</h2><ul><li>Redis = Remote Dictionary Server，远程字典服务器</li><li>Redis 是一个 高性能的 <code>key-value</code> 存储系统，通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和有序集合(sorted sets)等类型。</li><li>Redis 与其他 <code>key - value</code> 缓存产品有以下3个特点<ol><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储</li><li>Redis支持数据的备份，即master-slave模式的数据备份</li></ol></li><li>Redis 性能极高，读取速度是110000次/s，写入的速度是81000次/s。Redis数据库中的所有数据都存储在内存中，内存读写速度远快于磁盘。</li><li>Redis功能丰富，除了用于数据库开发，还可以用于缓存，队列系统等。</li><li>Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li></ul><h2 id="Redis环境配置"><a href="#Redis环境配置" class="headerlink" title="Redis环境配置"></a>Redis环境配置</h2><h3 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h3><ul><li>Mac上，建议使用Homebrew安装Redis</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">brew install redis    <span class="comment">//会默认安装当前最新的稳定版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 此处安装路径为 usr/local/Cellar/redis/5.0.7</span></span><br><span class="line"><span class="comment">//==&gt; Caveats</span></span><br><span class="line"><span class="comment">// To have launchd start redis now and restart at login:</span></span><br><span class="line"><span class="comment">//  brew services start redis</span></span><br><span class="line"><span class="comment">//Or, if you don't want/need a background service you can just run:</span></span><br><span class="line"><span class="comment">//  redis-server /usr/local/etc/redis.conf</span></span><br><span class="line"><span class="comment">//==&gt; Summary</span></span><br><span class="line"><span class="comment">//🍺  /usr/local/Cellar/redis/5.0.7: 13 files, 3.1MB</span></span><br></pre></td></tr></table></figure><ul><li>如果需要后台运行Redis服务，使用命令 <code>brew services start redis</code></li><li>如果不需要后台运行Redis服务，使用命令 <code>redis-server /usr/local/etc/redis.conf</code></li></ul><h3 id="启动-停止Redis"><a href="#启动-停止Redis" class="headerlink" title="启动/停止Redis"></a>启动/停止Redis</h3><p>执行 <code>brew services start redi</code> 命令，第一次启动 Redis 后，在 <code>/usr/local/bin</code> 目录下，会生成如下文件夹</p><table><thead><tr><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td>redis-server</td><td>redis 服务器</td></tr><tr><td>redis-cli</td><td>redis 命令行客户端</td></tr><tr><td>redis-benchmark</td><td>redis 性能测试工具</td></tr><tr><td>redis-check-aof</td><td>AOF 文件修复工具</td></tr><tr><td>redis-check-dump</td><td>RDB 文件检查工具</td></tr><tr><td>redis-sentinel</td><td>Sentinel 服务器</td></tr></tbody></table><ul><li>启动Redis</li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-<span class="keyword">server</span>   <span class="comment">//默认端口号 6379</span></span><br><span class="line"></span><br><span class="line">redis-<span class="keyword">server</span> --port <span class="number">6380</span>  <span class="comment">//指定端口号</span></span><br></pre></td></tr></table></figure><ul><li>停止Redis</li></ul><p>考虑到 Redis 有可能正在将内存中数据同步到硬盘中，强行终止Redis进程可能会导致数据丢失。因此，正确停止Redis的方式应该是向Redis发送 <code>SHUTDOWN</code> 命令，方法为</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli <span class="built_in">SHUTDOWN</span></span><br></pre></td></tr></table></figure><p>当 Redis 收到 <code>SHUTDOWN</code>  命令后，会先断开所有客户端连接，然后根据配置执行数据持久化，最后完成退出。</p><p>Redis 可以妥善处理 <code>SIGTERM</code> 信号，所以使用 <code>kill</code> Redis 进程的 PID，也可以正常结束 Redis，效果和发送 <code>SHUTDOWN</code> 命令一样。</p><h3 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h3><p>Redis 命令用于在 Redis 服务上执行操作。要在 Redis 服务上执行命令需要一个 Redis 客户端。</p><p><code>redis-cli</code> 是Redis自带的基于命令行的Redis客户端，下面介绍如果通过 <code>redis-cli</code> 向 Redis 发送命令。</p><p>通过 <code>redis-cli</code> 向 Redis 发送命令有2种方式</p><ul><li>方式1：将命令作为 <code>redis-cli</code> 的参数执行。例如 <code>redis-cli SHUTDOWN</code></li><li>方式2：执行 <code>redis-cli</code>（不附带任何参数），进入交互模式后，可以自由输入命令</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：将命令作为 redis-cli 的参数执行</span></span><br><span class="line"></span><br><span class="line">redis-cli SHUTDOWN</span><br><span class="line"></span><br><span class="line"><span class="comment">//redis默认服务器地址127.0.0.1，默认端口号6379 </span></span><br><span class="line"><span class="comment">//也可以使用-h指定服务器地址，-p指定端口号</span></span><br><span class="line">redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">//使用PING命令测试客户端和Redis的连接是否正常</span></span><br><span class="line">redis-cli PING  <span class="comment">//返回PONG 表示连接正常</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式2: 执行 redis-cli（不附带任何参数），进入交互模式后，可以自由输入命令</span></span><br><span class="line">lbsMacBook-Pro:~ lbs$ redis-cli</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; PING</span><br><span class="line">PONG</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h3><p>Redis 是一个字典结构的存储服务器，<strong>一个 Redis 实例</strong>提供了多个用来存储的字典，可以把其中的每个字典都理解成一个独立的数据库。</p><ul><li>每个数据库对外都是一个从0开始的递增数字命名，Redis默认支持16个数据库</li><li>Redis不支持自定义数据库名称，每个数据库都以编号命名</li><li>需要注意的是，一个Redis实例的多个数据库之间并不是完全隔离的，比如 <code>FLUSHALL</code> 命令可以清空一个 Redis 实例中所有数据库中的数据。综上所述，这些数据库更像是一种命名空间，而不适宜存储不同应用程序的数据。比如，可以使用0号数据库存储应用A的生产环境数据，使用1号数据库存储应用A的测试环境数据，而不应该使用1号数据库存储应用B的数据。</li><li><strong>不同的应用，应该使用不同的Redis实例存储数据。</strong> 由于Redis非常轻量，一个空的Redis实例占用的内存只有1MB，所以不用担心多个Redis实例会额外占用很多内存。</li></ul><h2 id="Redis-入门"><a href="#Redis-入门" class="headerlink" title="Redis 入门"></a>Redis 入门</h2><h3 id="命令行基础"><a href="#命令行基础" class="headerlink" title="命令行基础"></a>命令行基础</h3><ol><li>获得符合规则的键名列表</li></ol><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEYS <span class="built_in">pattern</span></span><br></pre></td></tr></table></figure><p><code>pattern</code> 支持 <code>glob</code> 风格通配符格式，具体如下</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>?</td><td>匹配一个字符</td></tr><tr><td>*</td><td>匹配任意个（包括0个）字符</td></tr><tr><td>[]</td><td>匹配括号间的任一字符，可以使用 <code>-</code> 表示一个范围，如 <code>[1-9]</code></td></tr><tr><td>\x</td><td>用于转义字符</td></tr></tbody></table><p>例如，查询当前的所有键名列表</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">set</span> bar <span class="comment">1</span></span><br><span class="line">OK</span><br><span class="line">&gt; KEYS <span class="comment">*</span></span><br><span class="line">1) <span class="string">"bar"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>判断一个键是否存在</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXISTS <span class="built_in">key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回(integer) 1，表示存在</span></span><br><span class="line"><span class="comment">//返回(integer) 0，表示不存在</span></span><br></pre></td></tr></table></figure><ol start="3"><li>删除键</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEL <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回(integer) 1，表示删除成功</span></span><br><span class="line"><span class="comment">//返回(integer) 0，表示删除不成功</span></span><br></pre></td></tr></table></figure><ol start="4"><li>获得键值的数据类型</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TYPE</span> <span class="built_in">key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 string list 等</span></span><br></pre></td></tr></table></figure><h3 id="Redis-5-种数据类型"><a href="#Redis-5-种数据类型" class="headerlink" title="Redis 5 种数据类型"></a>Redis 5 种数据类型</h3><p>Redis 支持5种数据类型</p><ul><li>string（字符串）</li><li>hash（哈希或散列）</li><li>list（列表）</li><li>set（集合）</li><li>zset(sorted set，有序集合)</li></ul><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><ol><li>赋值和取值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">GET</span> <span class="keyword">key</span>   //当键不存在时会返回空结果</span><br></pre></td></tr></table></figure><ol start="2"><li>递增数字</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">INCR key</span></span><br></pre></td></tr></table></figure><p>当要操作的键不存在时，默认键值为0，所以第一次递增后结果为1，如下所示</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; INCR  num</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line">&gt; INCR  num</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">2</span></span><br></pre></td></tr></table></figure><ol start="3"><li>增加指定的整数</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">INCRBY key increment</span></span><br></pre></td></tr></table></figure><ol start="4"><li>减少指定的整数</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DECR <span class="built_in">key</span></span><br><span class="line"></span><br><span class="line">DECRBY <span class="built_in">key</span> increment</span><br></pre></td></tr></table></figure><ol start="5"><li>增加指定浮点数</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">INCRBYFLOAT key  increment</span></span><br></pre></td></tr></table></figure><ol start="6"><li>向尾部追加值</li></ol><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPEND <span class="built_in">key</span>  <span class="built_in">value</span></span><br></pre></td></tr></table></figure><p><code>APPEND</code> 命令中，若键不存在，则将该键的值设为 <code>value</code>，相当于执行了 <code>SET key value</code>。</p><ol start="7"><li>获取字符串长度</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">STRLEN</span> <span class="built_in">key</span></span><br></pre></td></tr></table></figure><p>对于汉字，Redis使用UTF-8编码的中文，如下示例中，“你”和“好”两个字的UTF-8编码的长度都是3，所以返回的字符串长度为6。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">SET</span> key1 你好</span><br><span class="line">OK</span><br><span class="line">&gt; STRLEN <span class="comment">key1</span></span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure><ol start="8"><li>同时获得/设置多个键值</li></ol><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MSET key<span class="number">1</span> <span class="keyword">value</span><span class="number">1</span> key<span class="number">2</span> <span class="keyword">value</span><span class="number">2</span> key<span class="number">3</span> <span class="keyword">value</span><span class="number">3</span></span><br><span class="line"></span><br><span class="line">MGET key<span class="number">1</span> key<span class="number">2</span> key<span class="number">3</span></span><br></pre></td></tr></table></figure><ol start="9"><li>位操作</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GETBIT <span class="built_in">key</span> offset   <span class="comment">//获取一个字符串类型键指定位置的二进制位的值（0或1）</span></span><br><span class="line"> </span><br><span class="line">SETBIT <span class="built_in">key</span> offset value  <span class="comment">//设置指定位置的二进制位的值</span></span><br><span class="line"></span><br><span class="line">BITCOUNT <span class="built_in">key</span> [start] [<span class="keyword">end</span>] <span class="comment">//获得字符串类型键中值是1的二进制位个数</span></span><br><span class="line"></span><br><span class="line">BITOP operation destkey <span class="built_in">key</span> [<span class="built_in">key</span> ...] <span class="comment">//对多个字符串类型键进行位运算，结果存储在destkey</span></span><br></pre></td></tr></table></figure><p>一个字节由8个二进制位组成。Redis 提供了 4 个命令可以直接对二进制位操作。</p><p>下面进行示例分析。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> foo <span class="comment">bar</span></span><br></pre></td></tr></table></figure><p>“bar”的3个字母对应的ASCII码分别是98，97，114，转换为对应的二进制数值，<code>foo</code> 键中的二进制位结构为<code>01100010,01100001,01110010</code>。</p><p>(1) 使用 <code>GETBIT key offset</code> 获取一个字符串类型键指定位置的二进制位的值（0或1）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GETBIT foo <span class="number">6</span></span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果获取的二进制位的索引超出了键值的二进制位的实际长度，则默认返回 0</p><p>(2) <code>BITOP operation destkey key [key ...]</code> 可以对多个字符串类型键进行位运算，结果存储在 <code>destkey</code></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SET foo1 bar</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SET foo2 aar</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; BITOP OR res foo1 foo2  <span class="comment">//或运算</span></span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; GET res</span><br><span class="line"><span class="string">"car"</span></span><br></pre></td></tr></table></figure><h4 id="哈希（散列）类型"><a href="#哈希（散列）类型" class="headerlink" title="哈希（散列）类型"></a>哈希（散列）类型</h4><p>哈希（或散列）<code>hash</code> 类型的键值也是一种字典结构，其存储了字段（<code>field</code>）和字段值的映射，但字段值只能是字符串，不支持其他数据类型。</p><ol><li>赋值和取值</li></ol><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HSET <span class="built_in">key</span> field <span class="built_in">value</span>  <span class="comment">//不区分插入和更新操作，即更新数据时不用事先判断是否存在 </span></span><br><span class="line">HGET <span class="built_in">key</span> field</span><br><span class="line"></span><br><span class="line">HMSET <span class="built_in">key</span> field <span class="built_in">value</span> [field <span class="built_in">value</span> ...]</span><br><span class="line">HMGET <span class="built_in">key</span> field [field ...]</span><br><span class="line"></span><br><span class="line">HGETALL <span class="built_in">key</span></span><br></pre></td></tr></table></figure><ol start="2"><li>判断字段是否存在</li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">HEXISTS</span> key <span class="meta">field</span></span><br></pre></td></tr></table></figure><ol start="3"><li>仅仅在字段不存在是赋值</li></ol><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSETNX <span class="built_in">key</span> field <span class="built_in">value</span></span><br></pre></td></tr></table></figure><p><code>HSETNX</code> 和 <code>HSET</code> 命令类似，区别在于如果字段已经存在，<code>HSETNX</code> 命令将不执行任何操作。</p><p><code>HSETNX</code> 中的 <code>NX</code> 表示 <code>if Not eXists</code>。</p><ol start="4"><li>增加数字</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HINCRBY key filed increment</span></span><br></pre></td></tr></table></figure><ol start="5"><li>删除字段</li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">HDEL</span> key <span class="meta">field</span> [<span class="meta">field</span> ...]</span><br></pre></td></tr></table></figure><ol start="6"><li>只获取字段名称或字段值</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HKEYS <span class="built_in">key</span></span><br><span class="line"></span><br><span class="line">HVALS <span class="built_in">key</span></span><br></pre></td></tr></table></figure><ol start="7"><li>获得字段数量</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HLEN key</span></span><br></pre></td></tr></table></figure><h4 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h4><p>列表（<code>list</code>）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获取列表的某一个片段。</p><p>列表类型内部使用的是双向链表实现的，所以想列表两端添加元素的时间复杂度是 <code>O(1)</code>，获取越接近两端的元素速度就越快，但是通过索引访问元素会比较慢。因此，针对双向链表的特点，列表类型特别适合如下场景</p><ul><li>如社交网站的新鲜事，我们只关心最新内容，即使新鲜事达到几千万条，获取列表尾部的100条最新数据也是很快的</li><li>如日志记录场景，双向链表保证了插入新日志的速度不会受到已有日志数量的影响</li><li>借助列表类型，Redis还可以作为队列使用</li></ul><ol><li>向列表两端增加元素</li></ol><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSH <span class="built_in">key</span> <span class="built_in">value</span> [<span class="built_in">value</span> ...]   <span class="comment">//向列表左边插入元素</span></span><br><span class="line">RPUSH <span class="built_in">key</span> <span class="built_in">value</span> [<span class="built_in">value</span> ...]</span><br></pre></td></tr></table></figure><ol start="2"><li>从列表两端弹出元素</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPOP <span class="built_in">key</span> </span><br><span class="line">RPOP <span class="built_in">key</span></span><br></pre></td></tr></table></figure><ol start="3"><li>获取列表中元素个数</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN <span class="built_in">key</span>     <span class="comment">// 当键不存在则返回0</span></span><br></pre></td></tr></table></figure><ol start="4"><li>获得列表片段</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key <span class="literal">start</span> <span class="literal">stop</span>   //返回区间[<span class="literal">start</span>,<span class="literal">stop</span>]的列表片段（区间闭合），不改变原列表</span><br></pre></td></tr></table></figure><ol start="5"><li>删除列表中指定的值</li></ol><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LREM<span class="built_in"> key</span><span class="built_in"> count</span> <span class="keyword">value</span>  </span><br><span class="line">//删除列表中<span class="built_in">前count</span>个值为<span class="keyword">value</span>的元素，返回值是实际删除的元素个数</span><br></pre></td></tr></table></figure><p>当 <code>count</code> 大于0时，会从列表左边开始删除前<code>count</code> 个；当小于0时，会从列表右边边开始；当 <code>count</code> 等于0时，会删除列表中所有值为 <code>value</code> 的元素。</p><ol start="6"><li>获得/设置指定索引的元素值</li></ol><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LINDEX key <span class="keyword">index</span></span><br><span class="line"></span><br><span class="line">LSET <span class="keyword">key</span> <span class="keyword">index</span> <span class="keyword">value</span></span><br></pre></td></tr></table></figure><p>若 <code>index</code> 小于0，表示从列表右边开始计算索引，最右边的元素的索引值是 -1。</p><ol start="7"><li>只保留列表指定片段</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LTRIM key <span class="literal">start</span> <span class="literal">stop</span>   //只保留区间[<span class="literal">start</span>,<span class="literal">stop</span>]的列表片段（区间闭合），改变了原列表</span><br></pre></td></tr></table></figure><ol start="8"><li>向列表中插入元素</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LINSERT key <span class="keyword">BEFORE</span>|<span class="keyword">AFTER</span> pivot <span class="keyword">value</span>   </span><br><span class="line">//从左到右查找列表的pivot元素，在该元素前或后，插入<span class="keyword">value</span>元素</span><br></pre></td></tr></table></figure><ol start="9"><li>将元素从一个列表转到另一个列表</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RPOPLPUSH <span class="keyword">source</span> destination</span><br><span class="line"><span class="comment">//RPOPLPUSH表示先执行RPOP，再执行LPUSH</span></span><br></pre></td></tr></table></figure><h4 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h4><p>相比于列表，集合（<code>set</code>）中的元素是全局唯一的，并且是无序的。</p><p>集合（<code>set</code>）类型在Redis内部是使用值为空的散列表(<code>hash table</code>)实现的，所以向集合中插入或删除元素，判断元素是否存在，这些操作的时间复杂度都是 <code>O(1)</code>。</p><p>更方便的是，采用集合类型，多个集合类型之间还可以进行交集，并集和差集运算。</p><ol><li>增加/删除元素</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SADD <span class="built_in">key</span> <span class="built_in">member</span> [menber ...] //如果键不存在，则自动创建，返回值为成功加入的元素的数量</span><br><span class="line">SREM <span class="built_in">key</span> <span class="built_in">member</span> [menber ...]</span><br></pre></td></tr></table></figure><ol start="2"><li>获得集合找那个所有的元素</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SMEMBERS key</span></span><br></pre></td></tr></table></figure><ol start="3"><li>判断元素是否在集合中</li></ol><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度位O(1) 速度较快</span></span><br><span class="line">SISMEMBER key <span class="keyword">member</span></span><br></pre></td></tr></table></figure><ol start="4"><li>集合之间的运算</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDIFF  <span class="built_in">key</span> [<span class="built_in">key</span> ...]    <span class="comment">//差集</span></span><br><span class="line">SINTER <span class="built_in">key</span> [<span class="built_in">key</span> ...]    <span class="comment">//交集</span></span><br><span class="line">SUNION <span class="built_in">key</span> [<span class="built_in">key</span> ...]    <span class="comment">//并集</span></span><br></pre></td></tr></table></figure><ol start="5"><li>获取集合中元素个数</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SCARD key</span></span><br></pre></td></tr></table></figure><ol start="6"><li>进行集合运算并将结果存储</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDIFFSTORE destination <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br><span class="line">SINTERSTORE destination <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br><span class="line">SUNIONSTORE destination <span class="built_in">key</span> [<span class="built_in">key</span> ...]</span><br></pre></td></tr></table></figure><ol start="7"><li>随机获得集合中的元素</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SRANDMEMBER </span>key [<span class="built_in">count</span>]</span><br></pre></td></tr></table></figure><ol start="8"><li>从集合中弹出一个元素</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SPOP key</span></span><br></pre></td></tr></table></figure><h4 id="有序集合类型"><a href="#有序集合类型" class="headerlink" title="有序集合类型"></a>有序集合类型</h4><p>有序集合(<code>sorted list</code>)类型，是在集合类型的基础上，为每个元素关联一个分数（<code>score</code>，可以理解为索引值），使得元素有序。</p><p>Redis中，采用哈希表和跳跃表（<code>Skip list</code>）实现有序集合类型。所以即使读取位于中间部分的数据，速度也是很快的（时间复杂度是``O(logN)`）。</p><ol><li>增加元素</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//添加一个<span class="built_in">member</span>元素和该元素的分数score</span><br><span class="line">ZADD <span class="built_in">key</span> score <span class="built_in">member</span> [score <span class="built_in">member</span>]</span><br></pre></td></tr></table></figure><ol start="2"><li>获得元素的分数</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE <span class="built_in">key</span> <span class="built_in">member</span></span><br></pre></td></tr></table></figure><ol start="3"><li>获得排名在某个范围的元素列表</li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//按照元素分数从小到大的顺序，返回索引在区间[<span class="built_in">start</span>,<span class="built_in">stop</span>]的所有元素</span><br><span class="line">//如果有参数WITHSCORES，表示返回的元素列表包含分数信息</span><br><span class="line">ZRANGE key <span class="built_in">start</span> <span class="built_in">stop</span> [WITHSCORES]</span><br><span class="line"></span><br><span class="line">//类似ZRANGE，只不过是按照分数从大到小的顺序</span><br><span class="line">ZREVRANGE key <span class="built_in">start</span> <span class="built_in">stop</span> [WITHSCORES]</span><br></pre></td></tr></table></figure><ol start="4"><li>获得指定分数范围的元素</li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//按照元素分数从小到大的顺序，返回索引在区间[<span class="built_in">start</span>,<span class="built_in">stop</span>]的所有元素</span><br><span class="line">//如果有参数WITHSCORES，表示返回的元素列表包含分数信息</span><br><span class="line">ZRANGE key <span class="built_in">start</span> <span class="built_in">stop</span> [WITHSCORES]</span><br><span class="line"></span><br><span class="line">//类似ZRANGE，只不过是按照分数从大到小的顺序</span><br><span class="line">ZREVRANGE key <span class="built_in">start</span> <span class="built_in">stop</span> [WITHSCORES]</span><br></pre></td></tr></table></figure><ol start="5"><li>获得指定分数范围的元素</li></ol><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//按照元素分数从小到大，返回分数在区间[<span class="built_in">min</span>,<span class="built_in">max</span>]之间的元素</span><br><span class="line">//LIMIT <span class="built_in">offset</span> <span class="built_in">count</span> 表示在获得元素列表的基础上，向后偏移（跳过）<span class="built_in">offset</span>个元素，并且只获取之后的前<span class="built_in">count</span>个元素</span><br><span class="line">ZRANGEBYSCORE key <span class="built_in">min</span> <span class="built_in">max</span> [WITHSCORES] [LIMIT <span class="built_in">offset</span> <span class="built_in">count</span>]</span><br></pre></td></tr></table></figure><ol start="6"><li>增加某个元素的分数</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY <span class="built_in">key</span> increment <span class="built_in">member</span></span><br></pre></td></tr></table></figure><ol start="7"><li>获得集合中元素的数量</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ZCARD key</span></span><br></pre></td></tr></table></figure><ol start="8"><li>获得指定分数范围内的元素个数</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT <span class="built_in">key</span> <span class="built_in">min</span> <span class="built_in">max</span></span><br></pre></td></tr></table></figure><ol start="9"><li>按照排名范围删除元素</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照元素分数从小到大顺序，删除指定排名范围内的元素，并返回删除的元素数量</span></span><br><span class="line">ZREMRANGEBYRANK <span class="built_in">key</span> start <span class="keyword">stop</span></span><br></pre></td></tr></table></figure><ol start="10"><li>按照分数范围删除元素</li></ol><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回删除的元素数量</span></span><br><span class="line">ZREMRANGEBYSCORE <span class="built_in">key</span> <span class="built_in">min</span> <span class="built_in">max</span></span><br></pre></td></tr></table></figure><ol start="11"><li>获得元素的排名</li></ol><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZRANK key <span class="keyword">member</span>    <span class="comment">//按照分数从小到大顺序</span></span><br><span class="line">ZRANK key <span class="keyword">member</span>    <span class="comment">//按照分数从大到小顺序</span></span><br></pre></td></tr></table></figure><h2 id="Redis进阶"><a href="#Redis进阶" class="headerlink" title="Redis进阶"></a>Redis进阶</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="MULTI-EXEC"><a href="#MULTI-EXEC" class="headerlink" title="MULTI EXEC"></a>MULTI EXEC</h4><p>事务(<code>transaction</code>)是一组命令的集合，事务同命令一样，都是Redis的最小执行单位。一个事务中的命令要么都执行，要么都不执行。事务的应用非常普遍，如银行转账等。</p><p>Redis的事务还可以保证一个事务内的命令一次执行而不被其他命令插入。</p><p>事务的原理是先将属于一个事务的命令发送给Redis，然后再让Redis一次执行这些命令，例如</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt; SADD <span class="string">"user:1:following"</span> <span class="number">2</span></span><br><span class="line">QUEED</span><br><span class="line">redis&gt; SADD <span class="string">"user:2:following"</span> <span class="number">1</span></span><br><span class="line">QUEED</span><br><span class="line">redis&gt; EXEC</span><br><span class="line"><span class="number">1</span>) (<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"><span class="number">2</span>) (<span class="type">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>上面的代码演示了事务的使用方式。首先使用 <code>MULIL</code> 命令告诉Redis：“下面我发给你的命令属于同一个事务，你先不要执行，而是把它们暂时存起来”。</p><p>随后发送两个 <code>SADD</code> 命令执行事务操作，Redis返回 <code>QUEED</code> 表示这2条命令已经进入等待执行的事务队列中了。</p><p>最后，发送 <code>EXEC</code> 命令告诉Redis将等待执行的事务队列中的所有命令按照发送顺序执行。</p><p><strong>事务中的命令是在 <code>EXEC</code> 之后才执行的，因此，一个事务中，只有当所有命令都依次执行完成后，才能得到每个结果的返回值。</strong></p><h4 id="WATCH"><a href="#WATCH" class="headerlink" title="WATCH"></a>WATCH</h4><p><strong>一个事务中，只有当所有命令都依次执行完成后才能得到每个结果的返回值。</strong> 可是有些情况下，需要先获得一条命令的返回值，根据返回值再执行下一条命令。针对该情况，可以使用 <code>WATCH</code> 命令。</p><p><code>WATCH</code> 命令可以监控一个或多个键，一旦其中有一个键被修改或删除，之后的事务就不会执行。监控一直到 <code>EXEC</code> 命令。（事务中的命令是在 <code>EXEC</code> 之后才执行的，所以在 <code>MULTI</code> 命令后可以修改 <code>WATCH</code> 监控的键值）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; <span class="builtin-name">SET</span> key 1</span><br><span class="line">OK</span><br><span class="line">redis&gt; WATCH key</span><br><span class="line">OK</span><br><span class="line">redis&gt; <span class="builtin-name">SET</span> key 2</span><br><span class="line">OK</span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt; <span class="builtin-name">SET</span> key 3</span><br><span class="line">QUEED</span><br><span class="line">redis&gt; EXEC</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">redis&gt; <span class="builtin-name">GET</span> key</span><br><span class="line"><span class="string">"2"</span></span><br></pre></td></tr></table></figure><p>上例中，执行 <code>WATCH</code> 命令后，事务修改了 <code>key</code> 值，所以最后事务代码并没有执行，<code>EXEC</code> 命令返回结果为 <code>nil</code>。</p><p>执行 <code>EXEC</code> 命令后悔取消对所有键的监控。</p><h3 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h3><p>Redis 中可以使用 <code>EXPTRE</code> 命令设置一个键的过期时间，到时间后 Redis 会自动删除它。</p><ol><li>设置过期时间</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE <span class="built_in">key</span> seconds   <span class="comment">//seconds 单位为秒</span></span><br><span class="line"></span><br><span class="line">PEXPIRE <span class="built_in">key</span> milliseconds  <span class="comment">//milliseconds 单位为毫秒</span></span><br></pre></td></tr></table></figure><ol start="2"><li>查询键还有多少时间会被删除</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TTL <span class="built_in">key</span>   <span class="comment">//返回时间单位为秒</span></span><br><span class="line"></span><br><span class="line">PTTL <span class="built_in">key</span>  <span class="comment">//返回时间单位为毫秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 键不存在时，命令返回-2</span></span><br><span class="line"><span class="comment">// 键未设置过期时间时，命令返回-1</span></span><br></pre></td></tr></table></figure><ol start="3"><li>取消键的过期时间设置</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">PERSIST key</span></span><br></pre></td></tr></table></figure><p>除了 <code>PERSIST</code> 命令外，使用 <code>SET</code> 或 <code>GETSET</code> 命令为键赋值，也会同时清除键的过期时间。</p><h4 id="实现访问频率限制"><a href="#实现访问频率限制" class="headerlink" title="实现访问频率限制"></a>实现访问频率限制</h4><p>考虑如下场景——为了减轻服务器的压力，限制每个用户（IP）每分钟最多只能访问10次，就可以使用过期时间 <code>EXPIRE</code> 实现</p><ul><li>创建一个 <code>rate.limiting:userIP</code> 的键</li><li>设置 <code>EXPIRE key seconds</code>，过期时间为60s。一分钟后，该键会被自动删除</li><li>用户每次访问服务器，使用 <code>INCR</code> 递增该键值</li><li>当访问次数达到10后，提示用户稍后访问</li></ul><p>上述流程的伪代码如下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$isKeyExists</span> = EXISTS rate.limiting:<span class="variable">$IP</span></span><br><span class="line"><span class="keyword">if</span> isKeyExists is <span class="number">1</span></span><br><span class="line">    <span class="variable">$time</span> = INCR rate.limiting:<span class="variable">$IP</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$time</span> &gt; <span class="number">10</span></span><br><span class="line">        print 访问频率超过了限制，请稍后再试</span><br><span class="line">        <span class="keyword">exit</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    MULTI           <span class="regexp">//</span>使用事务，避免EXPIRE因为某种原因未执行，导致该键值一直存在</span><br><span class="line">    INCR rate.limiting:<span class="variable">$IP</span></span><br><span class="line">    EXPIRE <span class="variable">$keyName</span>, <span class="number">60</span></span><br><span class="line">    EXEC</span><br></pre></td></tr></table></figure><p>上述代码还有一个问题，比如用户在第1分钟的最后一秒访问了9次，又在下一分钟的第一秒访问了10次。这种访问是可以通过上述访问限制的，但实际上用户在2秒内访问了19次服务器。</p><p>为了处理上述场景，可以对代码进行优化</p><ul><li>使用一个列表存储用户最近10次访问服务器的时间</li><li>一旦键中的元素大于10个，就判断时间最早的元素距现在的时间是否小于1分钟。</li><li>如果是，则表示用户最近一分钟的访问次数超过了10次，进行限流提醒。</li><li>如果不是，就将现在的时间加入到列表中，同时把最早的元素删除。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$listLength</span> = LLEN rate<span class="selector-class">.limiting</span>:<span class="variable">$IP</span></span><br><span class="line"><span class="keyword">if</span> listLength &lt; <span class="number">10</span></span><br><span class="line">    LPUSH rate<span class="selector-class">.limiting</span>:<span class="variable">$IP</span>,now()</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="variable">$time</span> = LINDEX rate<span class="selector-class">.limiting</span>:<span class="variable">$IP</span>, -<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> now() - <span class="variable">$time</span> &gt; <span class="number">60</span></span><br><span class="line">        print 访问频率超过了限制，请稍后再试</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        LPUSH rate<span class="selector-class">.limiting</span>:<span class="variable">$IP</span>,now()</span><br><span class="line">        LTRIM rate<span class="selector-class">.limiting</span>:<span class="variable">$IP</span>,<span class="number">0</span>,<span class="number">9</span></span><br></pre></td></tr></table></figure><h4 id="实现缓存"><a href="#实现缓存" class="headerlink" title="实现缓存"></a>实现缓存</h4><p>为了提高服务器负载能力，常常需要将一些访问频率较高但是CPU或则IO资源消耗较大的操作的结果缓存起来，并希望让这些缓存过一段时间后自动过期。</p><p>实际开发中很难为缓存键设定合理的过期时间，为此可以限制Redis可以使用的最大内存，并让Redis按照一定的规则淘汰不需要的缓存键。这种方式在只将Redis用作缓存系统时非常实用。</p><p>Redis配置文件的 <code>maxmemory</code> 属性限定了Redis可以使用的最大内存。当超出这个限制时，Redis会依据 <code>maxmemory-policy</code> 参数指定的策略来删除不要的键值直到Redis占用的内存大小小于指定内存。</p><p><code>maxmemory-policy</code> 支持<code>LRU</code>(<code>Least Recently Used</code>) 算法规则，即“最近最少使用原则”，其认为最近最少使用的键在未来一段时间内也不会被用到，当内存不足时这些键是可以被删除的。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><code>SORT</code> 命令可以对列表类型，集合类型和有序集合类型键进行排序，并且可以完成和关系数据库中的连接查询类似的任务。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SORT key BY 参考键 <span class="builtin-name">GET</span> <span class="built_in">..</span>. STORE destkey</span><br></pre></td></tr></table></figure><ul><li><code>BY 参考键</code>中，如果提供了 <code>BY</code> 参数，<code>SORT</code> 命令将不再依据元素自身的值进行排序，而是对每个元素使用元素的值替换参考键中的第一个 <code>&quot;*&quot;</code> 并获取其值，然后依据该值对元素进行排序。</li></ul><p>例如，下述语句将读取如 <code>post:2</code>，<code>post:6</code>，<code>post:12</code>，<code>post:26</code> 几个散列键中的 <code>time</code> 字段的值并以此决定排序结果。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SORT</span> tag:ruby:posts <span class="keyword">BY</span> <span class="keyword">post</span>:*-&gt;time <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><ul><li><code>GET</code> 参数不影响排序，它的作用是使 <code>SORT</code> 命令的返回结果不再是元素自身的值，而是 <code>GET</code> 参数中指定的键值。</li><li><code>STORE</code> 参数用于将排序结果存储到指定的键中</li></ul><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p><code>SORT</code> 命令的时间复杂度是 <code>O(n+mlog(m))</code>，其中 <code>n</code> 表示要排序的列表（或集合或有序集合）中的元素个数，<code>m</code>表示要返回的元素个数。当 <code>n</code> 较大的时候，排序命令的性能相对较低，并且 Redis 在排序前会建立一个长度为 <code>n</code> 的容器来存储待排序的元素，虽然是一个临时的过程，但是如果同时进行较多的大数据量的排序操作则会严重影响性能。</p><p>所以开发中使用 <code>SORT</code> 命令需要注意</p><ol><li>尽可能减少待排序键中元素的数量（使 <code>n</code> 尽可能小）</li><li>使用 <code>LIMIT</code> 参数只获取需要的数据（使 <code>m</code> 尽可能小）</li><li>如果需要排序的数据量较大，尽可能使用 <code>STORE</code> 参数将结果缓存</li></ol><h3 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h3><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><p>任务队列，即“传递任务的队列”。和任务队列进行交互的实体有两类，一类是生产者（<code>producer</code>），另一类是消费者（<code>consumer</code>）。生产者会将需要处理的任务放入任务队列中，而消费者会不断地从任务队列中读入任务信息并执行。</p><p>使用任务队列的好处</p><ol><li>松耦合：生产者和消费者不需要知道彼此的实现细节，只需约定好的任务的描述格式即可。</li><li>易于扩展：消费者可以扩展到多个，而且可以分布在不同的服务器中，可以轻易地降低单台服务器的负载</li></ol><h4 id="使用Redis实现任务队列"><a href="#使用Redis实现任务队列" class="headerlink" title="使用Redis实现任务队列"></a>使用Redis实现任务队列</h4><p>使用Redis的列表结构和 <code>RPOP</code>，<code>LPUSH</code> 命令，可以实现简单的任务队列，伪代码如下所示</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无限循环读取任务队列中的内容</span></span><br><span class="line">loop</span><br><span class="line">    <span class="variable">$task</span> = RPOP queue</span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$task</span></span><br><span class="line">        # 如果任务队列中有任务则执行任务</span><br><span class="line">        execute(<span class="variable">$task</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        # 如果没有则等待1秒，以免过于频繁地请求数据</span><br><span class="line">        wait 1 second</span><br></pre></td></tr></table></figure><p>上述伪代码有个不足之处，当任务队列中没有任何任务时，消费者每秒都会调用一次 <code>RPOP</code> 命令查询是否有新任务。</p><p>如果可以实现一旦有新任务加入任务队列就通知消费者就好了。其实借助 <code>BRPOP</code> 命令就可以实现这样的需求。</p><p>如上伪代码可以优化为</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop</span><br><span class="line">    <span class="meta"># 如果任务队列中没有新任务，BRPOP命令会一直阻塞，不会执行execute()</span></span><br><span class="line">    $task = BRPOP queue, <span class="number">0</span></span><br><span class="line">    <span class="meta"># 返回值是一个数组，数组第2个元素是我们需要的任务</span></span><br><span class="line">    <span class="built_in">execute</span>($task[1])</span><br></pre></td></tr></table></figure><p><strong><code>BRPOP</code> 和 <code>RPOP</code> 命令类似，唯一的区别就是当列表中没有元素时，<code>BRPOP</code> 命令会一直阻塞连接，直到有新元素加入。</strong> </p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRPOP <span class="built_in">key</span> [<span class="built_in">key</span> ...] timeout</span><br></pre></td></tr></table></figure><p><code>BRPOP</code> 命令接收2个参数，第1个参数是键名，第2个参数是超时时间，单位是秒。当超过了此时间仍然没有获得新元素的话，就会返回 <code>nil</code>。如果传入时间参数为0（如下伪代码示例），则表示不限制等待时间，即如果没有新元素加入队列就会永远阻塞下去。</p><p>获得一个元素后，<code>BRPOP</code> 命令会返回一个数组，共2个值，分别是键名和元素值。第2个参数，元素值，就是待处理的任务。</p><h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><p>在实际开发中，针对多种不同的任务，经常会需要根据任务的优先级，去执行优先级较高的任务，即需要实现一个优先级队列。</p><p><code>BRPOP</code> 和 <code>BLPOP</code> 命令可以同时接收多个键，可以实现优先级队列。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRPOP <span class="built_in">key</span> [<span class="built_in">key</span> ...] timeout</span><br></pre></td></tr></table></figure><p>例如，<code>BLPOP queue:1 queue:2 0</code>，表示同时检测多个键——<code>queue:1</code> 和 <code>queue:2</code></p><ul><li>如果所有键都没元素则阻塞</li><li>如果有一个键有元素则会从该键中弹出元素</li><li>如果多个键都有元素，则按照<strong>从左到右</strong>顺序读取第一个键中的一个元素</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LPUSH queue:<span class="number">2</span> task1</span><br><span class="line"><span class="number">1</span>) (<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line">redis&gt; LPUSH queue:<span class="number">3</span> task2</span><br><span class="line"><span class="number">1</span>) (<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">redis&gt;BRPOP queue:<span class="number">1</span> queue:<span class="number">2</span> queue:<span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"queue:2"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"task1"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis&gt;BLPOP queue:<span class="number">1</span> queue:<span class="number">2</span> queue:<span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"queue:3"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"task2"</span></span><br></pre></td></tr></table></figure><p>使用 <code>BRPOP</code> 创建优先级队列时，<code>RPOP</code> 表示队列左进右出，因此有如下结构。即 <code>BRPOP queue:1 queue:2 queue:3 0</code> 命令中，越靠左的键优先级越高（<code>queue:1</code> 的优先级最高，因此会按照<strong>从左到右</strong>顺序读取第一个键中的一个元素。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(L-左进)--- | <span class="type">queue</span>:<span class="number">3</span>| <span class="type">queue</span>:<span class="number">2</span>| <span class="type">queue</span>:<span class="number">1</span>| <span class="type">--&gt; (R</span>-右出)</span><br></pre></td></tr></table></figure><p>使用 <code>BLPOP</code> 创建优先级队列时，<code>LPOP</code> 表示队列右进左出，因此有如下结构。即 <code>BLPOP queue:1 queue:2 queue:3 0</code> 命令中，越靠右的键优先级越高（<code>queue:3</code> 的优先级最高），因此会按照<strong>从右到左</strong>顺序读取第一个键中的一个元素。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(L-左出) &lt;--- | <span class="type">queue</span>:<span class="number">1</span>| <span class="type">queue</span>:<span class="number">2</span>| <span class="type">queue</span>:<span class="number">3</span>| <span class="type">--- (R</span>-右进)</span><br></pre></td></tr></table></figure><h4 id="“发布-订阅”模式"><a href="#“发布-订阅”模式" class="headerlink" title="“发布/订阅”模式"></a>“发布/订阅”模式</h4><p>“发布/订阅”模式包含两种角色，分别是发布者和订阅者。订阅者可以订阅一个或多个频道（<code>channel</code>），发布者可以向指定的频道发送消息，所有订阅该频道的订阅者都会受到改消息。</p><ul><li>发布消息</li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH channel <span class="keyword">message</span>   <span class="comment">//命令返回值表示接收到这条消息的订阅者的数量</span></span><br></pre></td></tr></table></figure><p>发布出去的消息不会被持久化，也就是说当有客户订阅该频道 <code>channel</code>后只能收到后续发布的消息，之前发送的消息就收不到了。</p><ul><li>订阅消息</li></ul><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE channel <span class="string">[channel ...]</span></span><br></pre></td></tr></table></figure><p>执行 <code>SUBSCRIBE</code> 命令后客户端会进入订阅状态，此状态下的客户端不能使用 <code>SUBSCRIBE</code>, <code>UNSUBSCRIBE</code>, <code>PSUBSCRIBE</code> 和 <code>PUNSUBSCRIBE</code> 这4个属于 “发布/订阅”模式的命令之外的命令，否则会报错。</p><p>进入订阅状态后的客户端，可能收到3种类型的回复，每种类型的回复都包括3个值。第一个值是消息类型，根据消息类型的不同，第二，第三个值的含义也不同。消息类型的取值可能有以下3个</p><ol><li><code>subscribe</code>。表示订阅消息成功的反馈。第2个值是订阅成功的频道名称，第3个值是当前客户端订阅的频道数量</li><li><code>message</code>。表示接收到的消息。第2个参数表示频道名称，第3个参数是消息内容</li><li><code>unscribe</code>。表示成功取消订阅某个频道。第2个参数表示频道名称，第3个参数是当前客户端订阅的频道数量，当该值为0时，客户端会退出订阅状态。</li></ol><p>下面看一个实例。</p><ol><li>首先Redis的一个实例RedisA在频道 <code>channel1.1</code> 发布一个消息</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RedisA</span></span><br><span class="line">redisA&gt; PUBLISH channel1<span class="number">.1</span> hi</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">0</span>     <span class="comment">//表示当前没有客户端订阅该消息</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Redis的另外一个实例RedisB 订阅频道 <code>channel1.1</code></li></ol><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RedisB</span></span><br><span class="line">redisB&gt; SUBSCRIBE channel1<span class="number">.1</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="number">1</span>) <span class="string">"subscribe"</span>   <span class="comment">//订阅消息成功</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"channel1.1"</span></span><br><span class="line"><span class="number">3</span>) (<span class="type">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="3"><li>实例RedisA继续在频道 <code>channel1.1</code> 发布一个消息</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RedisA</span></span><br><span class="line">redisA&gt; PUBLISH channel1<span class="number">.1</span> hello</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span>     <span class="comment">//表示当前没有客户端订阅该消息</span></span><br></pre></td></tr></table></figure><ol start="4"><li>此时，实例RedisB 会收到如下消息</li></ol><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">"message"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"channel1.1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><h4 id="按照规则订阅"><a href="#按照规则订阅" class="headerlink" title="按照规则订阅"></a>按照规则订阅</h4><p>可以使用 <code>PSUBSCRIBE</code> 订阅指定的规则，规则支持 <code>glob</code> 风格通配符格式。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>?</td><td>匹配一个字符</td></tr><tr><td>*</td><td>匹配任意个（包括0个）字符</td></tr><tr><td>[]</td><td>匹配括号间的任一字符，可以使用 <code>-</code> 表示一个范围，如 <code>[1-9]</code></td></tr><tr><td>\x</td><td>用于转义字符</td></tr></tbody></table><p>例如 <code>PSUBSCRIBE channel1.?*</code>命令中，规则 <code>channel1.?*</code> 可以匹配 <code>channel1.1</code> 和 <code>channel1.10</code>，但不会匹配 <code>channel1.1</code>。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul><li>客户端和Redis使用TCP协议连接。</li><li>不论是客户端向Redis发送命令，还是Redis向客户端返回命令结果，都需要经过网络传输。这两个部分的总耗时成为<strong>往返时延。</strong></li><li>大致来说，到本地回环地址（<code>loop back address</code>）的往返时间，在数量级上相当于Redis处理一条简单命令 (如 <code>LPUSH list 1 2 3</code>) 的时间。</li><li>Redis的底层通信协议对管道（<code>pipelining</code>）提供了支持。通过管道可以一次性发送多条命令并在执行完后一次性将结果返回。</li><li>当一组命令中每条命令都不依赖于之前命令的执行结果时就可以将这一组命令一起通过管道发出。管道通过减少客户端和Redis的通信次数，来实现降低往返时延累计值的目的。</li></ul><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2020/redis-basic-pipelining-1.png" alt=""></p><h3 id="节省空间"><a href="#节省空间" class="headerlink" title="节省空间"></a>节省空间</h3><p>Redis是一个基于内存的数据库，所有数据都存储在内存中。因此如何节省内存，控制成本，至关重要。节省内存空间，可以从以下方面考虑</p><ol><li>精简键名和键值</li><li>内部编码优化</li></ol><p>Redis为每种数据类型都提供了2种内部编码方式，用于节省内存空间。</p><p>以散列类型为例，散列类型是通过散列表实现的，这样可以实现时间复杂度 <code>O(1)</code> 的查找，赋值操作。然而当元素较少时，<code>O(1)</code>的操作并不会比 <code>O(n)</code> 有明显的性能提高。所以Redis会根据实际情况自动调整，采用一种更为紧凑但性能稍差（查找元素的复杂度为<code>O(n)</code>）的编码方式。</p><p><strong>内部编码方式的选择，对于开发者来说是透明的。</strong> 可以使用 <code>OBJECT ENCODING key</code> 命令查看某个键的内部编码方式。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; <span class="keyword">SET</span> foo <span class="comment">bar</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; OBJECT <span class="comment">ENCODING foo</span></span><br><span class="line"><span class="string">"raw"</span></span><br></pre></td></tr></table></figure><h2 id="Redis-脚本"><a href="#Redis-脚本" class="headerlink" title="Redis 脚本"></a>Redis 脚本</h2><p>Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本（和之后版本）通过内嵌支持 Lua 环境。执行脚本的常用命令为 <code>EVAL</code>。 使用脚本的好处包括</p><ol><li>减少网络开销：使用脚本可以将多个命令的多次请求，通过一次请求完成，减少网络往返时延</li><li>原子操作：Redis将整个脚本作为一个整体执行，中间不会被其他命令插入。即编写脚本过程中无需担心会出现竞态条件，也无需使用事务。事务可以完成的所有功能都可以使用脚本实现。</li><li>复用：客户端发送的脚本会永久存储在Redis中，其他客户端也可以复用这一脚本。</li></ol><h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><p>Redis 支持2种方式的持久化</p><ol><li><code>RDB</code> 方式：根据指定的规则“定时”将内存中的数据存储在硬盘上</li><li><code>AOF</code> 方式：每次执行命令后将命令本身记录下来</li></ol><p>通过 <code>RDB</code> 方式实现持久化，一旦 Redis 异常退出，就会丢失最后一次快照以后更改的所有数据。如果数据相对重要，希望损失降到最小，则可以使用 <code>AOF</code> 方式进行持久化。</p><p>Redis 允许同时开启 <code>RDB</code> 和 <code>AOF</code> 方式，既保证了数据安全又使得进行备份等操作十分容易。此时重新启动 Redis 后，Redis 会使用 AOF 文件来恢复数据，因为 AOF 方式的持久化可能丢失的数据更少。</p><h3 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h3><p><code>RDB</code> 方式的持久化是通过快照（<code>snapshoting</code>）完成的，当符合一定条件时 Redis 会自动将内存中的所有数据生成一份副本并存储在硬盘上，这个过程即“快照”。</p><h4 id="快照触发条件"><a href="#快照触发条件" class="headerlink" title="快照触发条件"></a>快照触发条件</h4><p>Redis 会在以下几种情况下对数据进行快照</p><ol><li>根据配置规则进行自动快照：每当时间窗口 M 内被更改的键的个数大于 N 时，即符合自动快照条件</li><li>用户执行 <code>SAVE</code> 或 <code>BGSAVE</code> 命令<ul><li>执行 <code>SAVE</code> 命令时，Redis同步地执行快照操作。快照执行过程中会阻塞所有来自客户端的请求。所以应该尽量避免在生产环境中执行该指令</li><li><code>BGSAVE</code> 命令可以在后台异步地执行快照操作，同时可以响应客户端的请求</li></ul></li><li>执行 <code>FLUSHALL</code> 命令<ul><li><code>FLUSHALL</code> 命令会清楚数据库中的所有操作</li><li>只要自动快照条件不为空（即使不满足该条件），执行 <code>FLUSHALL</code> 命令后，也会触发快照操作</li><li>当没有定义自动快照条件时，执行 <code>FLUSHALL</code> 命令不会触发快照操作</li></ul></li><li>执行复制（<code>replication</code>）时：设置了主从模式时，Redis会在复制初始化时进行自动快照</li></ol><h4 id="快照原理"><a href="#快照原理" class="headerlink" title="快照原理"></a>快照原理</h4><p>Redis 默认会将快照文件存储在 Redis 当前进程的工作目录种的 <code>dump.rdb</code> 文件中。快照的过程如下</p><ol><li>Redis 使用 <code>fork</code> 函数复制一份当前进程（父进程）的副本（子进程）</li><li>父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件</li><li>当子进程写入完成所有数据后会用该临时文件替换旧的 <code>RDB</code> 文件，至此一次快照操作完成。</li></ol><h3 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h3><p><code>AOF</code>(<code>append only file</code>) 方式可以将 Redis 执行的每一条命写命令追加到硬盘文件中，这一过程显然会降低 Redis 性能。但大部分情况下这个影响是可以接收的，另外使用较快的硬盘可以提高 <code>AOF</code> 的性能。</p><ul><li>开启AOF</li></ul><p>默认情况下没有开启AOF，执行如下命令可以开启AOF。默认情况下，AOF文件的保存位置和RDB文件的位置相同，默认的文件名是 <code>appendonly.aof</code>。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">appendonly</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><ul><li>AOF的实现</li></ul><p>AOF 文件的内容正是Redis客户端向Redis发送的原始通信协议的内容。</p><ul><li>同步硬盘数据</li></ul><p>由于操作系统的缓存机制，AOF文件数据并没有直接真正地写入硬盘，而是进入了系统的硬盘缓存。在默认情况下系统每 30 秒会执行一次同步操作，以便将硬盘缓存中的内容真正地写入硬盘。在这30秒内，如果系统异常退出则会导致硬盘缓存中的数据丢失。</p><p>一般来讲，启用AOF持久化的应用都无法容忍这样的损失。这就需要 Redis 在写入AOF 文件后主动要求系统将硬盘缓存内容同步到硬盘中。在 Redis 中，可以通过 <code>appendfsync</code> 参数设置同步的时机</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># appendfsync always</span></span><br><span class="line">appendfsync everysec   <span class="comment">//默认</span></span><br><span class="line"><span class="meta"># appendfsync no       //不主动进行同步操作，即交由操作系统处理（每30秒同步一次）</span></span><br></pre></td></tr></table></figure><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>同时拥有多个 Redis 服务器后，就会面临如果管理集群的问题，包括如何增加节点，故障恢复等操作。</p><h3 id="复制-replication"><a href="#复制-replication" class="headerlink" title="复制 replication"></a>复制 replication</h3><p>为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上。为此，Redis提供了复制 <code>replication</code> 功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库中。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在复制的概念中，数据库分为2种</p><ol><li>主数据库（<code>master</code>）：可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库</li><li>从数据库 （<code>slave</code>）：一般是只读的（也可以配置为可写入），并接受主数据库同步过来的数据</li></ol><p>Redis中，只需要在从数据库配置文件中加入如下配置，即可完成复制操作，主数据库不需要任何配置。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">salveof</span> 主数据库地址   主数据库端口</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol><li>启动一个Redis实例作为主数据库，默认端口号是6379</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$re</span>dis-server    <span class="comment">//默认端口号是6379</span></span><br></pre></td></tr></table></figure><ol start="2"><li>启动另一个Redis实例作为从数据库，监听端口号 6380</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$redis-server   --port <span class="number">6380</span> --slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>此时主数据库中任何数据变化，都会自动同步到从数据库中。</p><ol start="3"><li>打开 <code>redis-cli</code> 实例A并连接到主数据库。再打开 <code>redis-cli</code> 实例B并连接到从数据库</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$redis-cli -p <span class="number">6379</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br><span class="line"></span><br><span class="line">$redis-cli -p <span class="number">6380</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用 <code>INFO replication</code> 命令在实例A和实例B中查看复制相关的信息</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; INFO replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:<span class="number">1</span></span><br><span class="line">slave0:ip=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,port=<span class="number">6380</span>,state=online,offset=<span class="number">336</span>,lag=<span class="number">1</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>可以看到，实例A的角色是主数据库，其已连接的从数据库的个数是1。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; INFO replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">master_port:<span class="number">6379</span></span><br></pre></td></tr></table></figure><p>可以看到，实例B的角色是从数据库。</p><ol start="5"><li>在主数据库中添加键值，可以在从数据库中读取</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 主数据库写入</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SET foo bar</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 从数据库读取</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; GET foo</span><br><span class="line"><span class="string">"bar"</span></span><br></pre></td></tr></table></figure><h4 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h4><p>从数据库不仅可以接受主数据库的同步数据，自己也可以同时作为主数据库存在，形成类似图的结构，如下图所示。</p><p>主数据A的数据会同步到B和C，而B中的数据会同步到D和E中。向B中写入的数据不会同步到A或C中。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A<span class="string">[主数据库A]</span>--&gt;B<span class="string">[从数据库B]</span></span><br><span class="line">A<span class="string">[主数据库A]</span>--&gt;C<span class="string">[从数据库C]</span></span><br><span class="line"></span><br><span class="line">B<span class="string">[从数据库B]</span>--&gt;D<span class="string">[从数据库D]</span></span><br><span class="line">B<span class="string">[从数据库B]</span>--&gt;E<span class="string">[从数据库E]</span></span><br></pre></td></tr></table></figure><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><h4 id="面临的问题"><a href="#面临的问题" class="headerlink" title="面临的问题"></a>面临的问题</h4><p>为了提高性能，可以通过复制功能建立若干个从数据库，并在从数据库中启用持久化，同时在主数据中禁用持久化。这样可以保证主数据库的性能。</p><ol><li>当从数据库崩溃重启后，主数据库会自动将数据同步过来，所以无需担心数据丢失</li><li>当主数据库崩溃后，情况就比较复杂了。手动通过从数据库恢复主数据库数据时，需要严格执行如下2步<ul><li>在从数据库中使用 <code>SLAVE NO ONE</code> 命令将从数据库提升为主数据库继续服务</li><li>启动之前崩溃的主数据库，然后使用 <code>SLAVEOF</code> 命令将其设置成新的主数据库的从数据库，即可将数据同步回来</li></ul></li></ol><p>可见，手动维护主从数据库崩溃后的数据恢复是相当麻烦的。Redis提供了一种自动化方案——哨兵，避免了手工维护的麻烦和容易出错的问题。</p><h4 id="哨兵的功能"><a href="#哨兵的功能" class="headerlink" title="哨兵的功能"></a>哨兵的功能</h4><p>Redis 2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。</p><p>哨兵的作用就是监控 Redis 系统的运行状况，它的功能包括2个</p><ol><li>监控主数据库和从数据库是否正常工作</li><li>主数据库出现故障时自动将从数据库转换为主数据库</li></ol><p><strong>哨兵是一个独立的进程</strong>，使用哨兵的一个典型架构如下图所示。虚线表示主从复制关系，实线表示哨兵的监控路径。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2020/redis-basic-guard-1.png" alt=""></p><p>在一个一主多从的Redis系统中，可以使用多个哨兵进行监控任务以保证系统是足够稳健的，如下图所示。此时不仅哨兵会同时监控主从数据库，哨兵之间也会互相监控。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2020/redis-basic-guard-2.png" alt=""></p><h4 id="使用哨兵"><a href="#使用哨兵" class="headerlink" title="使用哨兵"></a>使用哨兵</h4><ol><li>创建哨兵配置文件，如 <code>sentinel.conf</code></li></ol><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor master-name  ip redis-port quorum</span></span><br><span class="line"></span><br><span class="line">sentinel<span class="built_in"> monitor </span>mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><p>其中，<code>mymaster</code> 是要监控的主数据库的名称，可以自定义一个。后面的参数是数据库的IP地址和端口号。</p><p>最后的参数 <code>1</code> 表示最低通过票数（<code>quorum</code>），即执行故障恢复操作前至少需要几个哨兵节点同意。一般情况下，取 <code>quorum</code> 的值为 <code>N/2 + 1</code>，其中 <code>N</code> 表示哨兵数目，即只有超过一半的哨兵同意后才会进行故障恢复。</p><ol start="2"><li>启动哨兵进程，并将上述配置文件的路径传递给哨兵</li></ol><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$redis-sentinel /path/<span class="keyword">to</span>/sentinel.conf</span><br></pre></td></tr></table></figure><p>需要注意的是，配置哨兵监控一个系统时，只需要配置其监控主数据库即可，哨兵会自动发现所有复制该主数据库的从数据库。</p><h3 id="集群-1"><a href="#集群-1" class="headerlink" title="集群"></a>集群</h3><p>Redis 3.0版本提供了集群（<code>Cluster</code>）特性。集群的特点在于拥有和单机实例同样的性能，同时在网络分区后能够提供一定的可访问性以及对主数据库故障恢复的支持。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;对 Redis 基础知识进行梳理，包括Redis的5种数据类型，事务，过期时间，消息通知，优先级队列，管道，数据持久化，复制，哨兵，事务等&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Back-End" scheme="https://lbs0912.github.io/categories/Back-End/"/>
    
    
      <category term="Back-End" scheme="https://lbs0912.github.io/tags/Back-End/"/>
    
      <category term="DataBase" scheme="https://lbs0912.github.io/tags/DataBase/"/>
    
      <category term="Redis" scheme="https://lbs0912.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Notes-000-Overview</title>
    <link href="https://lbs0912.github.io/2020/01/12/leetcode-000-overview/"/>
    <id>https://lbs0912.github.io/2020/01/12/leetcode-000-overview/</id>
    <published>2020-01-12T02:35:26.000Z</published>
    <updated>2020-11-01T03:50:27.594Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录LeetCode题目笔记，汇总LeetCode解答记录</li></ul><a id="more"></a><h2 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h2><ul><li>2019/02/13，撰写</li><li>2019/06/16，添加 <em>LeetCode Notes-1</em></li><li>2020/01/05，添加 <em>LeetCode Notes-2</em></li><li>2020/02/22，添加 <em>LeetCode Notes-3</em></li><li>2020/02/23，添加 <em>LeetCode Notes-4</em></li><li>2020/02/28，添加 <em>LeetCode Notes-5</em></li><li>2020/05/14，添加 <em>LeetCode Notes-6</em></li><li>2020/05/19，添加 <em>LeetCode Notes-7</em></li><li>2020/05/19，添加 <em>动态规划-思维脑图</em></li><li>2020/06/13，添加 <em>LeetCode Notes-8</em></li><li>2020/06/21，添加 <em>LeetCode Notes-9</em></li><li>2020/06/27，添加 <em>LeetCode Notes-10</em></li><li>2020/11/01，添加 <em>LeetCode Notes-11</em></li></ul><h2 id="学习资料汇总"><a href="#学习资料汇总" class="headerlink" title="学习资料汇总"></a>学习资料汇总</h2><ul><li><a href="https://leetcode.com/" target="_blank" rel="noopener">leetcode</a></li><li><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">leetcode-cn</a></li><li><a href="https://www.nowcoder.com/" target="_blank" rel="noopener">牛客网</a></li><li><a href="http://git.jd.com/algorithm-interest-group/AlgorithmShare" target="_blank" rel="noopener">AlgorithmShare @ JD</a></li><li><a href="https://github.com/MisterBooo/LeetCodeAnimation" target="_blank" rel="noopener">LeetCodeAnimation</a></li><li><a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">Leetcode Solution | github</a></li><li><a href="https://github.com/labuladong/fucking-algorithm" target="_blank" rel="noopener">fucking-algorithm | LeetCode</a></li><li><a href="https://zhuanlan.zhihu.com/p/106739847" target="_blank" rel="noopener">看阿里大佬们是如何刷《剑指 offer》的？ | 知乎</a></li><li><a href="https://leetcode-cn.com/problemset/lcof/" target="_blank" rel="noopener">剑指offer | LeetCode题库</a></li><li><a href="https://leetcode-cn.com/problemset/lcci/" target="_blank" rel="noopener">程序员面试经典（第6版） | LeetCode题库</a></li></ul><h2 id="题解记录模板"><a href="#题解记录模板" class="headerlink" title="题解记录模板"></a>题解记录模板</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## XXX（xxx）</span></span><br><span class="line"><span class="comment">### Description</span></span><br><span class="line">* [LeetCode-XX. XXX（xxx）]()</span><br><span class="line"></span><br><span class="line"><span class="comment">### Approach 1-XX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Analysis</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Solution</span></span><br><span class="line"></span><br><span class="line">* Java</span><br><span class="line">* C++</span><br><span class="line">* Python</span><br><span class="line">* JS</span><br></pre></td></tr></table></figure><h2 id="分类汇总"><a href="#分类汇总" class="headerlink" title="分类汇总"></a>分类汇总</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li><a href="https://leetcode.com/problems/linked-list-cycle/?tab=Description" target="_blank" rel="noopener">LeetCode-141. Linked List Cycle（环形链表）</a> - 环形链表</li><li><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCode-142. Linked List Cycle II（环形链表 II）</a> - 环形链表</li></ul><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><ul><li><a href="https://leetcode.com/problems/linked-list-cycle/?tab=Description" target="_blank" rel="noopener">LeetCode- 141. Linked List Cycle</a> - 环形链表</li><li><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCode- 142. Linked List Cycle II</a> - 环形链表</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li><a href="https://leetcode.com/problems/island-perimeter/?tab=Description" target="_blank" rel="noopener">LeetCode-463. Island Perimeter（岛屿的周长）</a> - 常规计算</li></ul><h3 id="PopCount（汉明距离）"><a href="#PopCount（汉明距离）" class="headerlink" title="PopCount（汉明距离）"></a>PopCount（汉明距离）</h3><ul><li><a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="noopener">LeetCode-191. Number of 1 Bits （位1的个数）</a></li><li><a href="https://leetcode.com/problems/counting-bits/" target="_blank" rel="noopener">LeetCode-338. Counting Bits（比特位计数）</a></li></ul><h3 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h3><ul><li><a href="https://leetcode.com/problems/longest-palindrome/" target="_blank" rel="noopener">LeetCode-409. Longest Palindrome （最长回文串）</a></li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/leetcode/dp-overview-leetcode.png" alt=""></p><ul><li><a href="https://leetcode.com/problems/counting-bits/" target="_blank" rel="noopener">LeetCode-338. Counting Bits（比特位计数）</a></li><li><a href="https://leetcode-cn.com/problems/maximum-subarray/submissions/" target="_blank" rel="noopener">LeetCode-53. 最大子序和</a> - DP+滚动数组</li><li><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">LeetCode-152. 乘积最大子数组</a>- DP+滚动数组</li></ul><h2 id="笔记目录"><a href="#笔记目录" class="headerlink" title="笔记目录"></a>笔记目录</h2><h3 id="Notes-1"><a href="#Notes-1" class="headerlink" title="Notes-1"></a>Notes-1</h3><ul><li><a href="https://leetcode.com/problems/linked-list-cycle/?tab=Description" target="_blank" rel="noopener">LeetCode-141. Linked List Cycle（环形链表）</a> - 环形链表</li><li><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCode-142. Linked List Cycle II（环形链表 II）</a> - 环形链表</li><li><a href="https://leetcode.com/problems/add-digits/?tab=Description" target="_blank" rel="noopener">LeetCode-258. Add Digits（各位相加）</a> - 数字推导（数字根）</li><li><a href="https://leetcode.com/problems/hamming-distance/" target="_blank" rel="noopener">LeetCode-461. Hamming Distance（汉明距离）</a> - 位运算</li><li><a href="https://leetcode.com/problems/island-perimeter/?tab=Description" target="_blank" rel="noopener">LeetCode-463. Island Perimeter（岛屿的周长）</a> - 常规计算</li></ul><h3 id="Notes-2"><a href="#Notes-2" class="headerlink" title="Notes-2"></a>Notes-2</h3><ul><li><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">LeetCode-206. Reverse Linked List（反转链表）</a> - 链表操作</li><li><a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">LeetCode-617. Merge Two Binary Trees</a> - 二叉树</li><li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">LeetCode-104. Maximum Depth of Binary Tree（二叉树的最大深度）</a> - 遍历二叉树</li><li><a href="https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/" target="_blank" rel="noopener">LeetCode-1290. Convert Binary Number in a Linked List to Integer（二进制链表转整数）</a></li><li><a href="https://leetcode.com/problems/to-lower-case/" target="_blank" rel="noopener">LeetCode-709. To Lower Case（转换成小写字母）</a></li></ul><h3 id="Notes-3"><a href="#Notes-3" class="headerlink" title="Notes-3"></a>Notes-3</h3><ul><li><a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="noopener">LeetCode-191. Number of 1 Bits （位1的个数）</a></li><li><a href="https://leetcode.com/problems/counting-bits/" target="_blank" rel="noopener">LeetCode-338. Counting Bits（比特位计数）</a></li><li><a href="https://leetcode.com/problems/longest-palindrome/" target="_blank" rel="noopener">LeetCode-409. Longest Palindrome （最长回文串）</a></li><li><a href="https://leetcode.com/problems/rectangle-area/?tab=Description" target="_blank" rel="noopener">LeetCode-223. Rectangle Area（矩形面积）</a></li><li><a href="https://leetcode.com/problems/number-complement/" target="_blank" rel="noopener">LeetCode-476. Number Complement（数字的补数）</a></li></ul><h3 id="Notes-4"><a href="#Notes-4" class="headerlink" title="Notes-4"></a>Notes-4</h3><ul><li><a href="https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/" target="_blank" rel="noopener">LeetCode-1342. Number of Steps to Reduce a Number to Zero（将数字变成 0 的操作次数）</a></li><li><a href="https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/" target="_blank" rel="noopener">LeetCode-1281. 整数的各位积和之差</a></li><li><a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">LeetCode-326. 3的幂</a></li><li><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">LeetCode-231. 2的幂</a></li><li><a href="https://leetcode-cn.com/problems/power-of-four/" target="_blank" rel="noopener">LeetCode-342. 4的幂</a></li></ul><h3 id="Notes-5"><a href="#Notes-5" class="headerlink" title="Notes-5"></a>Notes-5</h3><ul><li><a href="https://leetcode-cn.com/problems/sum-of-two-integers/" target="_blank" rel="noopener">LeetCode-371. 两整数之和</a></li><li><a href="https://leetcode-cn.com/problems/detect-capital/" target="_blank" rel="noopener">LeetCode-520. 检测大写字母</a></li><li><a href="https://leetcode-cn.com/problems/nim-game/" target="_blank" rel="noopener">LeetCode-292. Nim 游戏</a></li><li><a href="https://leetcode-cn.com/problems/rising-temperature/" target="_blank" rel="noopener">LeetCode-197. 上升的温度</a></li><li><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">LeetCode-136. 只出现一次的数字</a></li></ul><h3 id="Notes-6"><a href="#Notes-6" class="headerlink" title="Notes-6"></a>Notes-6</h3><ul><li><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">LeetCode-344. 反转字符串</a></li><li><a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">LeetCode-204.Count Primes</a></li><li><a href="https://leetcode-cn.com/problems/relative-ranks/" target="_blank" rel="noopener">LeetCode-506. 相对名次</a></li><li><a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">LeetCode-61. 旋转链表</a></li><li><a href="https://leetcode-cn.com/problems/create-target-array-in-the-given-order/" target="_blank" rel="noopener">LeetCode-1389. 按既定顺序创建目标数组</a></li></ul><h3 id="Notes-7"><a href="#Notes-7" class="headerlink" title="Notes-7"></a>Notes-7</h3><ul><li><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">LeetCode-560. 和为K的子数组</a></li><li><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">LeetCode-25. K 个一组翻转链表</a></li><li><a href="https://leetcode-cn.com/problems/maximum-subarray/submissions/" target="_blank" rel="noopener">LeetCode-53. 最大子序和</a> - DP+滚动数组</li><li><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">LeetCode-152. 乘积最大子数组</a>- DP+滚动数组</li><li><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">LeetCode-680. 验证回文字符串 II</a></li></ul><h3 id="Notes-8"><a href="#Notes-8" class="headerlink" title="Notes-8"></a>Notes-8</h3><ul><li><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener">LeetCode-1371. 每个元音包含偶数次的最长子字符串</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">LeetCode-5. 最长回文子串</a></li><li><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">LeetCode-207. 课程表</a></li><li><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">LeetCode-70. 爬楼梯</a>-动态规划</li><li><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">LeetCode-739. 每日温度</a></li></ul><h3 id="Notes-9"><a href="#Notes-9" class="headerlink" title="Notes-9"></a>Notes-9</h3><ul><li><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/" target="_blank" rel="noopener">LeetCode-1480. 一维数组的动态和</a></li><li><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">LeetCode-54. 螺旋矩阵</a></li><li><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">LeetCode-59. 螺旋矩阵 II</a></li><li><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">LeetCode-14. 最长公共前缀</a></li><li><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">LeetCode-1300. 转变数组后最接近目标值的数组和</a></li></ul><h3 id="Notes-10"><a href="#Notes-10" class="headerlink" title="Notes-10"></a>Notes-10</h3><ul><li><a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">LeetCode-771. 宝石与石头</a></li><li><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array/" target="_blank" rel="noopener">LeetCode-1486. 数组异或操作</a></li><li><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">LeetCode-16. 最接近的三数之和</a></li><li><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">LeetCode-15. 三数之和</a></li><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">LeetCode-1. 两数之和</a></li></ul><blockquote><p>第16，15，1题为同一类型题目。</p></blockquote><h3 id="Notes-11"><a href="#Notes-11" class="headerlink" title="Notes-11"></a>Notes-11</h3><ul><li><a href="https://leetcode-cn.com/problems/di-string-match/" target="_blank" rel="noopener">LeetCode-942. 增减字符串匹配</a></li><li><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">LeetCode-88. 合并两个有序数组组</a></li><li><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">LeetCode-209. 长度最小的子数组</a></li><li><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener">LeetCode-201. 数字范围按位与</a></li><li><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/" target="_blank" rel="noopener">LeetCode-187. 重复的DNA序列</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录LeetCode题目笔记，汇总LeetCode解答记录&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/categories/LeetCode/"/>
    
    
      <category term="Algorithm" scheme="https://lbs0912.github.io/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://lbs0912.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>React Native 实现下拉自动切换分类</title>
    <link href="https://lbs0912.github.io/2019/06/08/rn-tab-auto-change/"/>
    <id>https://lbs0912.github.io/2019/06/08/rn-tab-auto-change/</id>
    <published>2019-06-08T02:35:26.000Z</published>
    <updated>2019-11-09T15:22:38.601Z</updated>
    
    <content type="html"><![CDATA[<ul><li>记录 <code>React Native</code> 中如何实现下拉自动切换分类</li><li>针对 IOS 和 Android 平台差异，给出不同的切换分类触发条件</li></ul><a id="more"></a><h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>如图所示，整体为 <code>FlatList</code>，顶部分类栏吸顶，底部为 <code>feed</code> 流。要实现下拉商品列表到底后，继续下拉，自动切换到一下个分类的效果。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/front-end-2019/rn-flatlist-autochange-tab-android.png" alt="rn-flatlist-autochange-tab-android"></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>代码层面，可以在  <code>FlatList</code> 的 <code>onScrollEndDrag</code> 中添加自动 Tab 切换函数，借助 <code>FlatList</code> 实例的内容区高度 <code>contentLength</code>，滑动偏移量 <code>offset</code> 和可视区高度 <code>visibleLength</code> 三者关系，实现下拉自动切换Tab功能。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="IOS-平台实现"><a href="#IOS-平台实现" class="headerlink" title="IOS 平台实现"></a>IOS 平台实现</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//页面布局相关</span></span><br><span class="line"> &lt;FlatList</span><br><span class="line">    <span class="keyword">data</span> = &#123;[&#123;banner:[]&#125;,&#123;tab:[]&#125;,&#123;goodList:[]&#125;]&#125;</span><br><span class="line">    renderItem=&#123;<span class="keyword">this</span>.renderItem&#125;</span><br><span class="line">    stickyHeaderIndices=&#123;(Platform.OS !== <span class="string">'web'</span>)?[<span class="number">1</span>]:<span class="literal">null</span>&#125;</span><br><span class="line">    ListFooterComponent=&#123;<span class="keyword">this</span>._renderFooter&#125;</span><br><span class="line">    onScroll=&#123;<span class="keyword">this</span>._onScroll&#125; <span class="comment">//滑动监听</span></span><br><span class="line">    ref=&#123;<span class="keyword">this</span>._setScrollRef&#125;</span><br><span class="line">    keyExtractor = &#123;(item, index) =&gt; &#123; `hScrollView-$&#123;index&#125;` &#125;&#125;</span><br><span class="line">    refreshing=&#123;<span class="keyword">this</span>.state.isRefreshing&#125;</span><br><span class="line">    onRefresh=&#123;<span class="keyword">this</span>._onRefresh.bind(<span class="keyword">this</span>)&#125; <span class="comment">//下拉刷新</span></span><br><span class="line">    getItemLayout=&#123;(<span class="keyword">data</span>, index) =&gt; (</span><br><span class="line">        &#123;length: <span class="number">305</span>, offset: <span class="number">305</span> * index, index&#125;</span><br><span class="line">    )&#125;</span><br><span class="line">    onScrollEndDrag = &#123;()=&gt;&#123;  <span class="comment">//滑动到底监听函数</span></span><br><span class="line">        <span class="keyword">if</span>(Platform.OS != <span class="string">'web'</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>._onScrollEndDragFun();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取flatList 实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ref</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_setScrollRef = (ref) =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>._secondGoodFlatListRef = ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> isEmpty <span class="keyword">from</span> <span class="string">"lodash/isEmpty"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Platform&#125; <span class="keyword">from</span> <span class="string">"react-native"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;JDDevice&#125; <span class="keyword">from</span> <span class="string">"@jdreact/jdreact-core-lib"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 底部列表页滑动事件 实现上拉切换品类功能</span></span><br><span class="line"><span class="comment"> * @param e</span></span><br><span class="line"><span class="comment"> * @private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_onScrollEndDragFun = (e) =&gt; &#123;</span><br><span class="line">    let scrollMetrics = (<span class="keyword">this</span>._secondGoodFlatListRef &amp;&amp; <span class="keyword">this</span>._secondGoodFlatListRef._listRef</span><br><span class="line">        &amp;&amp; <span class="keyword">this</span>._secondGoodFlatListRef._listRef._scrollMetrics) || <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    let &#123;contentLength = <span class="number">0</span>, offset = <span class="number">0</span>, visibleLength = <span class="number">0</span>&#125; = scrollMetrics;</span><br><span class="line">    <span class="comment">// console.log('===scrollMetrics',scrollMetrics);</span></span><br><span class="line">    <span class="comment">// //判断是否最后一Tab 如果是就不却换下个目录</span></span><br><span class="line">    <span class="comment">// console.log('===this.props',this.props);</span></span><br><span class="line">    <span class="comment">// console.log('===this.state',this.state);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (contentLength &amp;&amp; offset &amp;&amp; visibleLength) &#123;</span><br><span class="line">        let &#123;selectedIndex = <span class="number">0</span>&#125; = <span class="keyword">this</span>.state; <span class="comment">//当前选中的三级分类index</span></span><br><span class="line">        let &#123;tabListData = []&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isEmpty(tabListData) &amp;&amp; (selectedIndex + <span class="number">1</span>) &lt; tabListData.length) &#123;  <span class="comment">//排除最后一个分类</span></span><br><span class="line">            let item = tabListData[selectedIndex + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (Platform.OS === <span class="string">'ios'</span>) &#123;</span><br><span class="line">                <span class="comment">//IOS 系统存在弹性上拉</span></span><br><span class="line">                <span class="keyword">if</span> (offset + visibleLength &gt; contentLength + JDDevice.getRpx(<span class="number">100</span>)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>._secondGoodFlatListRef.scrollToIndex(&#123;</span><br><span class="line">                        animated: <span class="literal">false</span>,</span><br><span class="line">                        index: <span class="number">0</span>,</span><br><span class="line">                        viewOffset: <span class="number">1</span>,</span><br><span class="line">                        viewPosition: <span class="number">0</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">this</span>.ItemCategory._clickCategoryTab2 &amp;&amp; <span class="keyword">this</span>.ItemCategory._clickCategoryTab2(item, selectedIndex + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//android 无弹性滑动，滑动到底时，offset + visibleLength = contentLength。IOS有弹性滑动，需要改变判断条件  lbs 2019-03-10</span></span><br><span class="line">                <span class="keyword">if</span> (offset + visibleLength &gt; contentLength - JDDevice.getRpx(<span class="number">10</span>)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>._secondGoodFlatListRef.scrollToIndex(&#123;</span><br><span class="line">                        animated: <span class="literal">false</span>,</span><br><span class="line">                        index: <span class="number">0</span>,</span><br><span class="line">                        viewOffset: <span class="number">1</span>,</span><br><span class="line">                        viewPosition: <span class="number">0</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">this</span>.ItemCategory._clickCategoryTab2 &amp;&amp; <span class="keyword">this</span>.ItemCategory._clickCategoryTab2(item, selectedIndex + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>其中，<code>contentLength</code> 为内容区高度，<code>offset</code> 为滑动偏移量，<code>visibleLength</code> 为可视区高度。</strong></p><blockquote><p>关于<span id="inline-purple">三种高度定义</span>，可参考 <a href="https://www.jianshu.com/p/33ec6ceeb638" target="_blank" rel="noopener">React Native中ListView和ScrollView实现上拉加载</a></p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scrollMetrics = (this._secondGoodFlatListRef<span class="operator"> &amp;&amp; </span>this.<span class="module-access"><span class="module"><span class="identifier">_secondGoodFlatListRef</span>.</span><span class="module"><span class="identifier">_listRef</span></span></span></span><br><span class="line"><span class="module-access"><span class="module"> </span></span><span class="operator">       &amp;&amp; </span>this.<span class="module-access"><span class="module"><span class="identifier">_secondGoodFlatListRef</span>.</span><span class="module"><span class="identifier">_listRef</span>.</span><span class="module"><span class="identifier">_scrollMetrics</span>)</span></span><span class="operator"> || </span>null;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    contentLength = <span class="number">0</span>,  <span class="comment">// 内容区高度</span></span><br><span class="line">    offset = <span class="number">0</span>,         <span class="comment">// 滑动偏移量</span></span><br><span class="line">    visibleLength = <span class="number">0</span>   <span class="comment">// 可视区高度</span></span><br><span class="line">&#125; = scrollMetrics;</span><br></pre></td></tr></table></figure><h3 id="Android-平台实现"><a href="#Android-平台实现" class="headerlink" title="Android 平台实现"></a>Android 平台实现</h3><p>对于 Android 平台，当 <code>offset + visibleLength = contentLength</code> 时，表示滑动到底部。为了以前进行切换，对条件进行修正，当滑动到距离底部 10px 时，触发切换 Tab 函数，如下代码所示</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android 无弹性滑动，滑动到底时，offset + visibleLength = contentLength。IOS有弹性滑动，需要改变判断条件  lbs 2019-03-10</span></span><br><span class="line"><span class="keyword">if</span> (offset + visibleLength &gt; contentLength - JDDevice.getRpx(<span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="keyword">this</span>._secondGoodFlatListRef.scrollToIndex(&#123;</span><br><span class="line">        animated: <span class="literal">false</span>,</span><br><span class="line">        index: <span class="number">0</span>, </span><br><span class="line">        viewOffset: <span class="number">1</span>,</span><br><span class="line">        viewPosition: <span class="number">0</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//切换Tab</span></span><br><span class="line">    <span class="keyword">this</span>.ItemCategory._clickCategoryTab2 &amp;&amp; <span class="keyword">this</span>.ItemCategory._clickCategoryTab2(item, selectedIndex + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 IOS 平台，因为 IOS 系统存在弹性上拉，如下图所示。因此对滑动到底条件修正为  <code>offset + visibleLength &gt; contentLength + JDDevice.getRpx(100)</code>。</p><p>其中，<code>JDDevice.getRpx(100)</code> 表示弹性上拉的高度，即下图中红色框的高度。</p><p><img src="https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/front-end-2019/rn-flatlist-autochange-tab-ios.png" alt="rn-flatlist-autochange-tab-ios"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Platform.OS === <span class="string">'ios'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (offset + visibleLength &gt; contentLength + JDDevice.getRpx(<span class="number">100</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>._secondGoodFlatListRef.scrollToIndex(&#123;</span><br><span class="line">            animated: <span class="literal">false</span>,</span><br><span class="line">            index: <span class="number">0</span>,</span><br><span class="line">            viewOffset: <span class="number">1</span>,</span><br><span class="line">            viewPosition: <span class="number">0</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.ItemCategory._clickCategoryTab2 &amp;&amp; <span class="keyword">this</span>.ItemCategory._clickCategoryTab2(item, selectedIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;记录 &lt;code&gt;React Native&lt;/code&gt; 中如何实现下拉自动切换分类&lt;/li&gt;
&lt;li&gt;针对 IOS 和 Android 平台差异，给出不同的切换分类触发条件&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="React Native" scheme="https://lbs0912.github.io/categories/React-Native/"/>
    
    
      <category term="React Native" scheme="https://lbs0912.github.io/tags/React-Native/"/>
    
  </entry>
  
</feed>
